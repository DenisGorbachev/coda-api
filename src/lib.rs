#[allow(unused_imports)]
pub use progenitor_client::{ByteStream, ClientInfo, Error, ResponseValue};
#[allow(unused_imports)]
use progenitor_client::{ClientHooks, OperationInfo, RequestBuilderExt, encode_path};

/// Types used as operation parameters and responses.
#[allow(clippy::all)]
pub mod types {
    /// Error types.
    pub mod error {
        /// Error from a `TryFrom` or `FromStr` implementation.
        pub struct ConversionError(::std::borrow::Cow<'static, str>);
        impl ::std::error::Error for ConversionError {}
        impl ::std::fmt::Display for ConversionError {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
                ::std::fmt::Display::fmt(&self.0, f)
            }
        }

        impl ::std::fmt::Debug for ConversionError {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
                ::std::fmt::Debug::fmt(&self.0, f)
            }
        }

        impl From<&'static str> for ConversionError {
            fn from(value: &'static str) -> Self {
                Self(value.into())
            }
        }

        impl From<String> for ConversionError {
            fn from(value: String) -> Self {
                Self(value.into())
            }
        }
    }

    ///Type of access.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Type of access.",
    ///  "type": "string",
    ///  "enum": [
    ///    "readonly",
    ///    "write",
    ///    "comment",
    ///    "none"
    ///  ],
    ///  "x-schema-name": "AccessType",
    ///  "x-tsEnumNames": [
    ///    "ReadOnly",
    ///    "Write",
    ///    "Comment",
    ///    "None"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum AccessType {
        #[serde(rename = "readonly")]
        Readonly,
        #[serde(rename = "write")]
        Write,
        #[serde(rename = "comment")]
        Comment,
        #[serde(rename = "none")]
        None,
    }

    impl ::std::convert::From<&Self> for AccessType {
        fn from(value: &AccessType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for AccessType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Readonly => f.write_str("readonly"),
                Self::Write => f.write_str("write"),
                Self::Comment => f.write_str("comment"),
                Self::None => f.write_str("none"),
            }
        }
    }

    impl ::std::str::FromStr for AccessType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "readonly" => Ok(Self::Readonly),
                "write" => Ok(Self::Write),
                "comment" => Ok(Self::Comment),
                "none" => Ok(Self::None),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for AccessType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for AccessType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for AccessType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Type of access (excluding none).
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Type of access (excluding none).",
    ///  "type": "string",
    ///  "enum": [
    ///    "readonly",
    ///    "write",
    ///    "comment"
    ///  ],
    ///  "x-schema-name": "AccessTypeNotNone",
    ///  "x-tsEnumNames": [
    ///    "ReadOnly",
    ///    "Write",
    ///    "Comment"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum AccessTypeNotNone {
        #[serde(rename = "readonly")]
        Readonly,
        #[serde(rename = "write")]
        Write,
        #[serde(rename = "comment")]
        Comment,
    }

    impl ::std::convert::From<&Self> for AccessTypeNotNone {
        fn from(value: &AccessTypeNotNone) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for AccessTypeNotNone {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Readonly => f.write_str("readonly"),
                Self::Write => f.write_str("write"),
                Self::Comment => f.write_str("comment"),
            }
        }
    }

    impl ::std::str::FromStr for AccessTypeNotNone {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "readonly" => Ok(Self::Readonly),
                "write" => Ok(Self::Write),
                "comment" => Ok(Self::Comment),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for AccessTypeNotNone {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for AccessTypeNotNone {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for AccessTypeNotNone {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///List of Permissions.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "List of Permissions.",
    ///  "type": "object",
    ///  "required": [
    ///    "href",
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "href": {
    ///      "description": "API link to these results",
    ///      "examples": [
    ///        "https://coda.io/apis/v1/docs/AbCDeFGH/acl?limit=20"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Permission"
    ///      }
    ///    },
    ///    "nextPageLink": {
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/nextPageLink"
    ///        },
    ///        {
    ///          "examples": [
    ///            "https://coda.io/apis/v1/docs/AbCDeFGH/acl?pageToken=eyJsaW1pd"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      ]
    ///    },
    ///    "nextPageToken": {
    ///      "$ref": "#/components/schemas/nextPageToken"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "Acl"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct Acl {
        ///API link to these results
        pub href: ::std::string::String,
        pub items: ::std::vec::Vec<Permission>,
        #[serde(rename = "nextPageLink", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_link: ::std::option::Option<NextPageLink>,
        #[serde(rename = "nextPageToken", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_token: ::std::option::Option<NextPageToken>,
    }

    impl ::std::convert::From<&Acl> for Acl {
        fn from(value: &Acl) -> Self {
            value.clone()
        }
    }

    ///Doc level metadata associated with ACL.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Doc level metadata associated with ACL.",
    ///  "type": "object",
    ///  "required": [
    ///    "canCopy",
    ///    "canShare",
    ///    "canShareWithOrg",
    ///    "canShareWithWorkspace"
    ///  ],
    ///  "properties": {
    ///    "canCopy": {
    ///      "description": "When true, the user of the api can copy the doc",
    ///      "type": "boolean"
    ///    },
    ///    "canShare": {
    ///      "description": "When true, the user of the api can share",
    ///      "type": "boolean"
    ///    },
    ///    "canShareWithOrg": {
    ///      "description": "When true, the user of the api can share with the
    /// org",
    ///      "type": "boolean"
    ///    },
    ///    "canShareWithWorkspace": {
    ///      "description": "When true, the user of the api can share with the
    /// workspace",
    ///      "type": "boolean"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "Acl"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct AclMetadata {
        ///When true, the user of the api can copy the doc
        #[serde(rename = "canCopy")]
        pub can_copy: bool,
        ///When true, the user of the api can share
        #[serde(rename = "canShare")]
        pub can_share: bool,
        ///When true, the user of the api can share with the org
        #[serde(rename = "canShareWithOrg")]
        pub can_share_with_org: bool,
        ///When true, the user of the api can share with the workspace
        #[serde(rename = "canShareWithWorkspace")]
        pub can_share_with_workspace: bool,
    }

    impl ::std::convert::From<&AclMetadata> for AclMetadata {
        fn from(value: &AclMetadata) -> Self {
            value.clone()
        }
    }

    ///Sharing settings for the doc.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Sharing settings for the doc.",
    ///  "type": "object",
    ///  "required": [
    ///    "allowCopying",
    ///    "allowEditorsToChangePermissions",
    ///    "allowViewersToRequestEditing"
    ///  ],
    ///  "properties": {
    ///    "allowCopying": {
    ///      "description": "When true, allows doc viewers to copy the doc.",
    ///      "type": "boolean"
    ///    },
    ///    "allowEditorsToChangePermissions": {
    ///      "description": "When true, allows editors to change doc permissions. When false, only doc owner can change doc permissions.\n",
    ///      "type": "boolean"
    ///    },
    ///    "allowViewersToRequestEditing": {
    ///      "description": "When true, allows doc viewers to request editing
    /// permissions.",
    ///      "type": "boolean"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "AclSettings"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct AclSettings {
        ///When true, allows doc viewers to copy the doc.
        #[serde(rename = "allowCopying")]
        pub allow_copying: bool,
        ///When true, allows editors to change doc permissions. When false,
        /// only doc owner can change doc permissions.
        #[serde(rename = "allowEditorsToChangePermissions")]
        pub allow_editors_to_change_permissions: bool,
        ///When true, allows doc viewers to request editing permissions.
        #[serde(rename = "allowViewersToRequestEditing")]
        pub allow_viewers_to_request_editing: bool,
    }

    impl ::std::convert::From<&AclSettings> for AclSettings {
        fn from(value: &AclSettings) -> Self {
            value.clone()
        }
    }

    ///Payload for adding a custom published doc domain.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Payload for adding a custom published doc domain.",
    ///  "type": "object",
    ///  "required": [
    ///    "customDocDomain"
    ///  ],
    ///  "properties": {
    ///    "customDocDomain": {
    ///      "description": "The custom domain.",
    ///      "examples": [
    ///        "example.com"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "AddCustomDocDomainRequest"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct AddCustomDocDomainRequest {
        ///The custom domain.
        #[serde(rename = "customDocDomain")]
        pub custom_doc_domain: ::std::string::String,
    }

    impl ::std::convert::From<&AddCustomDocDomainRequest> for AddCustomDocDomainRequest {
        fn from(value: &AddCustomDocDomainRequest) -> Self {
            value.clone()
        }
    }

    ///The result of adding a custom domain to a published doc.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The result of adding a custom domain to a published
    /// doc.",
    ///  "type": "object",
    ///  "additionalProperties": false,
    ///  "x-schema-name": "AddCustomDocDomainResponse"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct AddCustomDocDomainResponse {}
    impl ::std::convert::From<&AddCustomDocDomainResponse> for AddCustomDocDomainResponse {
        fn from(value: &AddCustomDocDomainResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for AddCustomDocDomainResponse {
        fn default() -> Self {
            Self {}
        }
    }

    ///Payload for creating a Go Link
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Payload for creating a Go Link",
    ///  "type": "object",
    ///  "required": [
    ///    "destinationUrl",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "creatorEmail": {
    ///      "description": "Optional creator email for the Go Link. Only
    /// organization admins can set this field.",
    ///      "examples": [
    ///        "foo@bar.com"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "maxLength": 512
    ///    },
    ///    "description": {
    ///      "description": "Optional description for the Go Link.",
    ///      "type": "string",
    ///      "maxLength": 512
    ///    },
    ///    "destinationUrl": {
    ///      "description": "The URL that the Go Link redirects to.",
    ///      "type": "string",
    ///      "maxLength": 2048
    ///    },
    ///    "name": {
    ///      "description": "The name of the Go Link that comes after go/. Only
    /// alphanumeric characters, dashes, and underscores are allowed.",
    ///      "type": "string",
    ///      "maxLength": 128,
    ///      "pattern": "^[a-zA-Z0-9\\-_]+$"
    ///    },
    ///    "urlPattern": {
    ///      "description": "Optional destination URL with {*} placeholders for
    /// variables to be inserted. Variables are specified like
    /// go/<name>/<var1>/<var2>.",
    ///      "examples": [
    ///        "https://example.com/{*}/{*}"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "maxLength": 2048
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "AddGoLinkRequest"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct AddGoLinkRequest {
        ///Optional creator email for the Go Link. Only organization admins can
        /// set this field.
        #[serde(rename = "creatorEmail", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub creator_email: ::std::option::Option<AddGoLinkRequestCreatorEmail>,
        ///Optional description for the Go Link.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<AddGoLinkRequestDescription>,
        ///The URL that the Go Link redirects to.
        #[serde(rename = "destinationUrl")]
        pub destination_url: AddGoLinkRequestDestinationUrl,
        ///The name of the Go Link that comes after go/. Only alphanumeric
        /// characters, dashes, and underscores are allowed.
        pub name: AddGoLinkRequestName,
        ///Optional destination URL with {*} placeholders for variables to be
        /// inserted. Variables are specified like go/<name>/<var1>/<var2>.
        #[serde(rename = "urlPattern", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub url_pattern: ::std::option::Option<AddGoLinkRequestUrlPattern>,
    }

    impl ::std::convert::From<&AddGoLinkRequest> for AddGoLinkRequest {
        fn from(value: &AddGoLinkRequest) -> Self {
            value.clone()
        }
    }

    ///Optional creator email for the Go Link. Only organization admins can set
    /// this field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Optional creator email for the Go Link. Only
    /// organization admins can set this field.",
    ///  "examples": [
    ///    "foo@bar.com"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 512
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct AddGoLinkRequestCreatorEmail(::std::string::String);
    impl ::std::ops::Deref for AddGoLinkRequestCreatorEmail {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<AddGoLinkRequestCreatorEmail> for ::std::string::String {
        fn from(value: AddGoLinkRequestCreatorEmail) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&AddGoLinkRequestCreatorEmail> for AddGoLinkRequestCreatorEmail {
        fn from(value: &AddGoLinkRequestCreatorEmail) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for AddGoLinkRequestCreatorEmail {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 512usize {
                return Err("longer than 512 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for AddGoLinkRequestCreatorEmail {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for AddGoLinkRequestCreatorEmail {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for AddGoLinkRequestCreatorEmail {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for AddGoLinkRequestCreatorEmail {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///Optional description for the Go Link.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Optional description for the Go Link.",
    ///  "type": "string",
    ///  "maxLength": 512
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct AddGoLinkRequestDescription(::std::string::String);
    impl ::std::ops::Deref for AddGoLinkRequestDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<AddGoLinkRequestDescription> for ::std::string::String {
        fn from(value: AddGoLinkRequestDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&AddGoLinkRequestDescription> for AddGoLinkRequestDescription {
        fn from(value: &AddGoLinkRequestDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for AddGoLinkRequestDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 512usize {
                return Err("longer than 512 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for AddGoLinkRequestDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for AddGoLinkRequestDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for AddGoLinkRequestDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for AddGoLinkRequestDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///The URL that the Go Link redirects to.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The URL that the Go Link redirects to.",
    ///  "type": "string",
    ///  "maxLength": 2048
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct AddGoLinkRequestDestinationUrl(::std::string::String);
    impl ::std::ops::Deref for AddGoLinkRequestDestinationUrl {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<AddGoLinkRequestDestinationUrl> for ::std::string::String {
        fn from(value: AddGoLinkRequestDestinationUrl) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&AddGoLinkRequestDestinationUrl> for AddGoLinkRequestDestinationUrl {
        fn from(value: &AddGoLinkRequestDestinationUrl) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for AddGoLinkRequestDestinationUrl {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 2048usize {
                return Err("longer than 2048 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for AddGoLinkRequestDestinationUrl {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for AddGoLinkRequestDestinationUrl {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for AddGoLinkRequestDestinationUrl {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for AddGoLinkRequestDestinationUrl {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///The name of the Go Link that comes after go/. Only alphanumeric
    /// characters, dashes, and underscores are allowed.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the Go Link that comes after go/. Only
    /// alphanumeric characters, dashes, and underscores are allowed.",
    ///  "type": "string",
    ///  "maxLength": 128,
    ///  "pattern": "^[a-zA-Z0-9\\-_]+$"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct AddGoLinkRequestName(::std::string::String);
    impl ::std::ops::Deref for AddGoLinkRequestName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<AddGoLinkRequestName> for ::std::string::String {
        fn from(value: AddGoLinkRequestName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&AddGoLinkRequestName> for AddGoLinkRequestName {
        fn from(value: &AddGoLinkRequestName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for AddGoLinkRequestName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 128usize {
                return Err("longer than 128 characters".into());
            }
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> = ::std::sync::LazyLock::new(|| ::regress::Regex::new("^[a-zA-Z0-9\\-_]+$").unwrap());
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[a-zA-Z0-9\\-_]+$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for AddGoLinkRequestName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for AddGoLinkRequestName {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for AddGoLinkRequestName {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for AddGoLinkRequestName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///Optional destination URL with {*} placeholders for variables to be
    /// inserted. Variables are specified like go/<name>/<var1>/<var2>.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Optional destination URL with {*} placeholders for
    /// variables to be inserted. Variables are specified like
    /// go/<name>/<var1>/<var2>.",
    ///  "examples": [
    ///    "https://example.com/{*}/{*}"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 2048
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct AddGoLinkRequestUrlPattern(::std::string::String);
    impl ::std::ops::Deref for AddGoLinkRequestUrlPattern {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<AddGoLinkRequestUrlPattern> for ::std::string::String {
        fn from(value: AddGoLinkRequestUrlPattern) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&AddGoLinkRequestUrlPattern> for AddGoLinkRequestUrlPattern {
        fn from(value: &AddGoLinkRequestUrlPattern) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for AddGoLinkRequestUrlPattern {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 2048usize {
                return Err("longer than 2048 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for AddGoLinkRequestUrlPattern {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for AddGoLinkRequestUrlPattern {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for AddGoLinkRequestUrlPattern {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for AddGoLinkRequestUrlPattern {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct AddGoLinkResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&AddGoLinkResponse> for AddGoLinkResponse {
        fn from(value: &AddGoLinkResponse) -> Self {
            value.clone()
        }
    }

    ///The result of adding a Go Link.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The result of adding a Go Link.",
    ///  "type": "object",
    ///  "additionalProperties": false,
    ///  "x-schema-name": "AddGoLinkResult"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct AddGoLinkResult {}
    impl ::std::convert::From<&AddGoLinkResult> for AddGoLinkResult {
        fn from(value: &AddGoLinkResult) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for AddGoLinkResult {
        fn default() -> Self {
            Self {}
        }
    }

    ///Payload for adding a Pack Category.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Payload for adding a Pack Category.",
    ///  "type": "object",
    ///  "required": [
    ///    "categoryName"
    ///  ],
    ///  "properties": {
    ///    "categoryName": {
    ///      "description": "Name of the publishing category.",
    ///      "examples": [
    ///        "Project management"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "AddPackCategoryRequest"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct AddPackCategoryRequest {
        ///Name of the publishing category.
        #[serde(rename = "categoryName")]
        pub category_name: ::std::string::String,
    }

    impl ::std::convert::From<&AddPackCategoryRequest> for AddPackCategoryRequest {
        fn from(value: &AddPackCategoryRequest) -> Self {
            value.clone()
        }
    }

    ///Confirmation of successfully adding a Pack category.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Confirmation of successfully adding a Pack category.",
    ///  "type": "object",
    ///  "additionalProperties": false,
    ///  "x-schema-name": "AddPackCategoryResponse"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct AddPackCategoryResponse {}
    impl ::std::convert::From<&AddPackCategoryResponse> for AddPackCategoryResponse {
        fn from(value: &AddPackCategoryResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for AddPackCategoryResponse {
        fn default() -> Self {
            Self {}
        }
    }

    ///Detail about why this request was rejected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why this request was rejected.",
    ///  "type": "object",
    ///  "properties": {
    ///    "validationErrors": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct AddPackCategoryResponseCodaDetail {
        #[serde(rename = "validationErrors", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub validation_errors: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&AddPackCategoryResponseCodaDetail> for AddPackCategoryResponseCodaDetail {
        fn from(value: &AddPackCategoryResponseCodaDetail) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for AddPackCategoryResponseCodaDetail {
        fn default() -> Self {
            Self {
                validation_errors: Default::default(),
            }
        }
    }

    ///Payload for adding a Pack maker.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Payload for adding a Pack maker.",
    ///  "type": "object",
    ///  "required": [
    ///    "loginId"
    ///  ],
    ///  "properties": {
    ///    "loginId": {
    ///      "description": "The email of the Pack maker.",
    ///      "examples": [
    ///        "api@coda.io"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "AddPackMakerRequest"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct AddPackMakerRequest {
        ///The email of the Pack maker.
        #[serde(rename = "loginId")]
        pub login_id: ::std::string::String,
    }

    impl ::std::convert::From<&AddPackMakerRequest> for AddPackMakerRequest {
        fn from(value: &AddPackMakerRequest) -> Self {
            value.clone()
        }
    }

    ///Confirmation of successfully adding a Pack maker.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Confirmation of successfully adding a Pack maker.",
    ///  "type": "object",
    ///  "additionalProperties": false,
    ///  "x-schema-name": "AddPackMakerResponse"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct AddPackMakerResponse {}
    impl ::std::convert::From<&AddPackMakerResponse> for AddPackMakerResponse {
        fn from(value: &AddPackMakerResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for AddPackMakerResponse {
        fn default() -> Self {
            Self {}
        }
    }

    ///Detail about why this request was rejected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why this request was rejected.",
    ///  "type": "object",
    ///  "properties": {
    ///    "validationErrors": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct AddPackMakerResponseCodaDetail {
        #[serde(rename = "validationErrors", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub validation_errors: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&AddPackMakerResponseCodaDetail> for AddPackMakerResponseCodaDetail {
        fn from(value: &AddPackMakerResponseCodaDetail) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for AddPackMakerResponseCodaDetail {
        fn default() -> Self {
            Self {
                validation_errors: Default::default(),
            }
        }
    }

    ///Payload for upserting a Pack permission.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Payload for upserting a Pack permission.",
    ///  "type": "object",
    ///  "required": [
    ///    "access",
    ///    "principal"
    ///  ],
    ///  "properties": {
    ///    "access": {
    ///      "$ref": "#/components/schemas/PackAccessType"
    ///    },
    ///    "principal": {
    ///      "$ref": "#/components/schemas/PackPrincipal"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "AddPackPermissionRequest"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct AddPackPermissionRequest {
        pub access: PackAccessType,
        pub principal: PackPrincipal,
    }

    impl ::std::convert::From<&AddPackPermissionRequest> for AddPackPermissionRequest {
        fn from(value: &AddPackPermissionRequest) -> Self {
            value.clone()
        }
    }

    ///Confirmation of successfully upserting a Pack permission.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Confirmation of successfully upserting a Pack
    /// permission.",
    ///  "type": "object",
    ///  "required": [
    ///    "permissionId"
    ///  ],
    ///  "properties": {
    ///    "permissionId": {
    ///      "description": "The ID of the permission created or updated.",
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "AddPackPermissionResponse"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct AddPackPermissionResponse {
        ///The ID of the permission created or updated.
        #[serde(rename = "permissionId")]
        pub permission_id: ::std::string::String,
    }

    impl ::std::convert::From<&AddPackPermissionResponse> for AddPackPermissionResponse {
        fn from(value: &AddPackPermissionResponse) -> Self {
            value.clone()
        }
    }

    ///Detail about why this request was rejected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why this request was rejected.",
    ///  "type": "object",
    ///  "properties": {
    ///    "validationErrors": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct AddPackPermissionResponseCodaDetail {
        #[serde(rename = "validationErrors", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub validation_errors: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&AddPackPermissionResponseCodaDetail> for AddPackPermissionResponseCodaDetail {
        fn from(value: &AddPackPermissionResponseCodaDetail) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for AddPackPermissionResponseCodaDetail {
        fn default() -> Self {
            Self {
                validation_errors: Default::default(),
            }
        }
    }

    ///Payload for granting a new permission.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Payload for granting a new permission.",
    ///  "type": "object",
    ///  "required": [
    ///    "access",
    ///    "principal"
    ///  ],
    ///  "properties": {
    ///    "access": {
    ///      "$ref": "#/components/schemas/AccessTypeNotNone"
    ///    },
    ///    "principal": {
    ///      "$ref": "#/components/schemas/AddedPrincipal"
    ///    },
    ///    "suppressEmail": {
    ///      "description": "When true suppresses email notification",
    ///      "type": "boolean"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "AddPermissionRequest"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct AddPermissionRequest {
        pub access: AccessTypeNotNone,
        pub principal: AddedPrincipal,
        ///When true suppresses email notification
        #[serde(rename = "suppressEmail", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub suppress_email: ::std::option::Option<bool>,
    }

    impl ::std::convert::From<&AddPermissionRequest> for AddPermissionRequest {
        fn from(value: &AddPermissionRequest) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct AddPermissionResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&AddPermissionResponse> for AddPermissionResponse {
        fn from(value: &AddPermissionResponse) -> Self {
            value.clone()
        }
    }

    ///The result of sharing a doc.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The result of sharing a doc.",
    ///  "type": "object",
    ///  "additionalProperties": false,
    ///  "x-schema-name": "AddPermissionResult"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct AddPermissionResult {}
    impl ::std::convert::From<&AddPermissionResult> for AddPermissionResult {
        fn from(value: &AddPermissionResult) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for AddPermissionResult {
        fn default() -> Self {
            Self {}
        }
    }

    ///`AddedAnyonePrincipal`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "type": {
    ///      "description": "The type of this principal.",
    ///      "type": "string",
    ///      "enum": [
    ///        "anyone"
    ///      ],
    ///      "x-tsType": "PrincipalType.Anyone"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct AddedAnyonePrincipal {
        ///The type of this principal.
        #[serde(rename = "type")]
        pub type_: AddedAnyonePrincipalType,
    }

    impl ::std::convert::From<&AddedAnyonePrincipal> for AddedAnyonePrincipal {
        fn from(value: &AddedAnyonePrincipal) -> Self {
            value.clone()
        }
    }

    ///The type of this principal.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of this principal.",
    ///  "type": "string",
    ///  "enum": [
    ///    "anyone"
    ///  ],
    ///  "x-tsType": "PrincipalType.Anyone"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum AddedAnyonePrincipalType {
        #[serde(rename = "anyone")]
        Anyone,
    }

    impl ::std::convert::From<&Self> for AddedAnyonePrincipalType {
        fn from(value: &AddedAnyonePrincipalType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for AddedAnyonePrincipalType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Anyone => f.write_str("anyone"),
            }
        }
    }

    impl ::std::str::FromStr for AddedAnyonePrincipalType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "anyone" => Ok(Self::Anyone),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for AddedAnyonePrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for AddedAnyonePrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for AddedAnyonePrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`AddedDomainPrincipal`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "domain",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "domain": {
    ///      "description": "Domain for the principal.",
    ///      "examples": [
    ///        "domain.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "description": "The type of this principal.",
    ///      "type": "string",
    ///      "enum": [
    ///        "domain"
    ///      ],
    ///      "x-tsType": "PrincipalType.Domain"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct AddedDomainPrincipal {
        ///Domain for the principal.
        pub domain: ::std::string::String,
        ///The type of this principal.
        #[serde(rename = "type")]
        pub type_: AddedDomainPrincipalType,
    }

    impl ::std::convert::From<&AddedDomainPrincipal> for AddedDomainPrincipal {
        fn from(value: &AddedDomainPrincipal) -> Self {
            value.clone()
        }
    }

    ///The type of this principal.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of this principal.",
    ///  "type": "string",
    ///  "enum": [
    ///    "domain"
    ///  ],
    ///  "x-tsType": "PrincipalType.Domain"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum AddedDomainPrincipalType {
        #[serde(rename = "domain")]
        Domain,
    }

    impl ::std::convert::From<&Self> for AddedDomainPrincipalType {
        fn from(value: &AddedDomainPrincipalType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for AddedDomainPrincipalType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Domain => f.write_str("domain"),
            }
        }
    }

    impl ::std::str::FromStr for AddedDomainPrincipalType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "domain" => Ok(Self::Domain),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for AddedDomainPrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for AddedDomainPrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for AddedDomainPrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`AddedEmailPrincipal`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "email",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "email": {
    ///      "description": "Email for the principal.",
    ///      "examples": [
    ///        "example@domain.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "description": "The type of this principal.",
    ///      "type": "string",
    ///      "enum": [
    ///        "email"
    ///      ],
    ///      "x-tsType": "PrincipalType.Email"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct AddedEmailPrincipal {
        ///Email for the principal.
        pub email: ::std::string::String,
        ///The type of this principal.
        #[serde(rename = "type")]
        pub type_: AddedEmailPrincipalType,
    }

    impl ::std::convert::From<&AddedEmailPrincipal> for AddedEmailPrincipal {
        fn from(value: &AddedEmailPrincipal) -> Self {
            value.clone()
        }
    }

    ///The type of this principal.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of this principal.",
    ///  "type": "string",
    ///  "enum": [
    ///    "email"
    ///  ],
    ///  "x-tsType": "PrincipalType.Email"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum AddedEmailPrincipalType {
        #[serde(rename = "email")]
        Email,
    }

    impl ::std::convert::From<&Self> for AddedEmailPrincipalType {
        fn from(value: &AddedEmailPrincipalType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for AddedEmailPrincipalType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Email => f.write_str("email"),
            }
        }
    }

    impl ::std::str::FromStr for AddedEmailPrincipalType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "email" => Ok(Self::Email),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for AddedEmailPrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for AddedEmailPrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for AddedEmailPrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`AddedGroupPrincipal`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "groupId",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "groupId": {
    ///      "description": "Group ID for the principal.",
    ///      "examples": [
    ///        "grp-6SM9xrKcqW"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "description": "The type of this principal.",
    ///      "type": "string",
    ///      "enum": [
    ///        "group"
    ///      ],
    ///      "x-tsType": "PrincipalType.Group"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct AddedGroupPrincipal {
        ///Group ID for the principal.
        #[serde(rename = "groupId")]
        pub group_id: ::std::string::String,
        ///The type of this principal.
        #[serde(rename = "type")]
        pub type_: AddedGroupPrincipalType,
    }

    impl ::std::convert::From<&AddedGroupPrincipal> for AddedGroupPrincipal {
        fn from(value: &AddedGroupPrincipal) -> Self {
            value.clone()
        }
    }

    ///The type of this principal.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of this principal.",
    ///  "type": "string",
    ///  "enum": [
    ///    "group"
    ///  ],
    ///  "x-tsType": "PrincipalType.Group"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum AddedGroupPrincipalType {
        #[serde(rename = "group")]
        Group,
    }

    impl ::std::convert::From<&Self> for AddedGroupPrincipalType {
        fn from(value: &AddedGroupPrincipalType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for AddedGroupPrincipalType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Group => f.write_str("group"),
            }
        }
    }

    impl ::std::str::FromStr for AddedGroupPrincipalType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "group" => Ok(Self::Group),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for AddedGroupPrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for AddedGroupPrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for AddedGroupPrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Metadata about a principal to add to a doc.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Metadata about a principal to add to a doc.",
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/AddedEmailPrincipal"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/AddedGroupPrincipal"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/AddedDomainPrincipal"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/AddedWorkspacePrincipal"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/AddedAnyonePrincipal"
    ///    }
    ///  ],
    ///  "x-schema-name": "AddedPrincipal"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum AddedPrincipal {
        EmailPrincipal(AddedEmailPrincipal),
        GroupPrincipal(AddedGroupPrincipal),
        DomainPrincipal(AddedDomainPrincipal),
        WorkspacePrincipal(AddedWorkspacePrincipal),
        AnyonePrincipal(AddedAnyonePrincipal),
    }

    impl ::std::convert::From<&Self> for AddedPrincipal {
        fn from(value: &AddedPrincipal) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<AddedEmailPrincipal> for AddedPrincipal {
        fn from(value: AddedEmailPrincipal) -> Self {
            Self::EmailPrincipal(value)
        }
    }

    impl ::std::convert::From<AddedGroupPrincipal> for AddedPrincipal {
        fn from(value: AddedGroupPrincipal) -> Self {
            Self::GroupPrincipal(value)
        }
    }

    impl ::std::convert::From<AddedDomainPrincipal> for AddedPrincipal {
        fn from(value: AddedDomainPrincipal) -> Self {
            Self::DomainPrincipal(value)
        }
    }

    impl ::std::convert::From<AddedWorkspacePrincipal> for AddedPrincipal {
        fn from(value: AddedWorkspacePrincipal) -> Self {
            Self::WorkspacePrincipal(value)
        }
    }

    impl ::std::convert::From<AddedAnyonePrincipal> for AddedPrincipal {
        fn from(value: AddedAnyonePrincipal) -> Self {
            Self::AnyonePrincipal(value)
        }
    }

    ///`AddedWorkspacePrincipal`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "type",
    ///    "workspaceId"
    ///  ],
    ///  "properties": {
    ///    "type": {
    ///      "description": "The type of this principal.",
    ///      "type": "string",
    ///      "enum": [
    ///        "workspace"
    ///      ],
    ///      "x-tsType": "PrincipalType.Workspace"
    ///    },
    ///    "workspaceId": {
    ///      "description": "WorkspaceId for the principal.",
    ///      "examples": [
    ///        "ws-sdfmsdf9"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct AddedWorkspacePrincipal {
        ///The type of this principal.
        #[serde(rename = "type")]
        pub type_: AddedWorkspacePrincipalType,
        ///WorkspaceId for the principal.
        #[serde(rename = "workspaceId")]
        pub workspace_id: ::std::string::String,
    }

    impl ::std::convert::From<&AddedWorkspacePrincipal> for AddedWorkspacePrincipal {
        fn from(value: &AddedWorkspacePrincipal) -> Self {
            value.clone()
        }
    }

    ///The type of this principal.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of this principal.",
    ///  "type": "string",
    ///  "enum": [
    ///    "workspace"
    ///  ],
    ///  "x-tsType": "PrincipalType.Workspace"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum AddedWorkspacePrincipalType {
        #[serde(rename = "workspace")]
        Workspace,
    }

    impl ::std::convert::From<&Self> for AddedWorkspacePrincipalType {
        fn from(value: &AddedWorkspacePrincipalType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for AddedWorkspacePrincipalType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Workspace => f.write_str("workspace"),
            }
        }
    }

    impl ::std::str::FromStr for AddedWorkspacePrincipalType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "workspace" => Ok(Self::Workspace),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for AddedWorkspacePrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for AddedWorkspacePrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for AddedWorkspacePrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Response representing the last day analytics were updated.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Response representing the last day analytics were
    /// updated.",
    ///  "type": "object",
    ///  "required": [
    ///    "docAnalyticsLastUpdated",
    ///    "packAnalyticsLastUpdated",
    ///    "packFormulaAnalyticsLastUpdated"
    ///  ],
    ///  "properties": {
    ///    "docAnalyticsLastUpdated": {
    ///      "description": "Date that doc analytics were last updated.",
    ///      "examples": [
    ///        "2022-05-01"
    ///      ],
    ///      "type": "string",
    ///      "format": "date"
    ///    },
    ///    "packAnalyticsLastUpdated": {
    ///      "description": "Date that Pack analytics were last updated.",
    ///      "examples": [
    ///        "2022-05-01"
    ///      ],
    ///      "type": "string",
    ///      "format": "date"
    ///    },
    ///    "packFormulaAnalyticsLastUpdated": {
    ///      "description": "Date that Pack formula analytics were last
    /// updated.",
    ///      "examples": [
    ///        "2022-05-01"
    ///      ],
    ///      "type": "string",
    ///      "format": "date"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "AnalyticsLastUpdatedResponse"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct AnalyticsLastUpdatedResponse {
        ///Date that doc analytics were last updated.
        #[serde(rename = "docAnalyticsLastUpdated")]
        pub doc_analytics_last_updated: ::chrono::naive::NaiveDate,
        ///Date that Pack analytics were last updated.
        #[serde(rename = "packAnalyticsLastUpdated")]
        pub pack_analytics_last_updated: ::chrono::naive::NaiveDate,
        ///Date that Pack formula analytics were last updated.
        #[serde(rename = "packFormulaAnalyticsLastUpdated")]
        pub pack_formula_analytics_last_updated: ::chrono::naive::NaiveDate,
    }

    impl ::std::convert::From<&AnalyticsLastUpdatedResponse> for AnalyticsLastUpdatedResponse {
        fn from(value: &AnalyticsLastUpdatedResponse) -> Self {
            value.clone()
        }
    }

    ///Quantization period over which to view analytics.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Quantization period over which to view analytics.",
    ///  "type": "string",
    ///  "enum": [
    ///    "daily",
    ///    "cumulative"
    ///  ],
    ///  "x-schema-name": "AnalyticsScale",
    ///  "x-tsEnumNames": [
    ///    "Daily",
    ///    "Cumulative"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum AnalyticsScale {
        #[serde(rename = "daily")]
        Daily,
        #[serde(rename = "cumulative")]
        Cumulative,
    }

    impl ::std::convert::From<&Self> for AnalyticsScale {
        fn from(value: &AnalyticsScale) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for AnalyticsScale {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Daily => f.write_str("daily"),
                Self::Cumulative => f.write_str("cumulative"),
            }
        }
    }

    impl ::std::str::FromStr for AnalyticsScale {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "daily" => Ok(Self::Daily),
                "cumulative" => Ok(Self::Cumulative),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for AnalyticsScale {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for AnalyticsScale {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for AnalyticsScale {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`AnyonePrincipal`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "type": {
    ///      "description": "The type of this principal.",
    ///      "type": "string",
    ///      "enum": [
    ///        "anyone"
    ///      ],
    ///      "x-tsType": "PrincipalType.Anyone"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct AnyonePrincipal {
        ///The type of this principal.
        #[serde(rename = "type")]
        pub type_: AnyonePrincipalType,
    }

    impl ::std::convert::From<&AnyonePrincipal> for AnyonePrincipal {
        fn from(value: &AnyonePrincipal) -> Self {
            value.clone()
        }
    }

    ///The type of this principal.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of this principal.",
    ///  "type": "string",
    ///  "enum": [
    ///    "anyone"
    ///  ],
    ///  "x-tsType": "PrincipalType.Anyone"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum AnyonePrincipalType {
        #[serde(rename = "anyone")]
        Anyone,
    }

    impl ::std::convert::From<&Self> for AnyonePrincipalType {
        fn from(value: &AnyonePrincipalType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for AnyonePrincipalType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Anyone => f.write_str("anyone"),
            }
        }
    }

    impl ::std::str::FromStr for AnyonePrincipalType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "anyone" => Ok(Self::Anyone),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for AnyonePrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for AnyonePrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for AnyonePrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Info about a resolved link to an API resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Info about a resolved link to an API resource.",
    ///  "type": "object",
    ///  "required": [
    ///    "href",
    ///    "resource",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "browserLink": {
    ///      "description": "Canonical browser-friendly link to the resolved
    /// resource.",
    ///      "examples": [
    ///        "https://coda.io/d/_dAbCDeFGH/Launch-Status_sumnO"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "href": {
    ///      "description": "Self link to this query.",
    ///      "examples": [
    ///        "https://coda.io/apis/v1/resolveBrowserLink?url=https%3A%2F%2Fcoda.io%2Fd%2F_dAbCDeFGH%2FLaunch-Status_sumnO"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "resource": {
    ///      "$ref": "#/components/schemas/ApiLinkResolvedResource"
    ///    },
    ///    "type": {
    ///      "description": "The type of this resource.",
    ///      "type": "string",
    ///      "enum": [
    ///        "apiLink"
    ///      ],
    ///      "x-tsType": "Type.ApiLink"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "ApiLink"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ApiLink {
        ///Canonical browser-friendly link to the resolved resource.
        #[serde(rename = "browserLink", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub browser_link: ::std::option::Option<::std::string::String>,
        ///Self link to this query.
        pub href: ::std::string::String,
        pub resource: ApiLinkResolvedResource,
        ///The type of this resource.
        #[serde(rename = "type")]
        pub type_: ApiLinkType,
    }

    impl ::std::convert::From<&ApiLink> for ApiLink {
        fn from(value: &ApiLink) -> Self {
            value.clone()
        }
    }

    ///Reference to the resolved resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Reference to the resolved resource.",
    ///  "type": "object",
    ///  "required": [
    ///    "href",
    ///    "id",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "href": {
    ///      "description": "API link to the resolved resource that can be
    /// queried to get further information.",
    ///      "examples": [
    ///        "https://coda.io/apis/v1/docs/AbCDeFGH/pages/canvas-IjkLmnO"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "id": {
    ///      "description": "ID of the resolved resource.",
    ///      "examples": [
    ///        "canvas-IjkLmnO"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "Name of the resource.",
    ///      "examples": [
    ///        "My Page"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "$ref": "#/components/schemas/Type"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "ApiLinkResolvedResource"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ApiLinkResolvedResource {
        ///API link to the resolved resource that can be queried to get further
        /// information.
        pub href: ::std::string::String,
        ///ID of the resolved resource.
        pub id: ::std::string::String,
        ///Name of the resource.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        #[serde(rename = "type")]
        pub type_: Type,
    }

    impl ::std::convert::From<&ApiLinkResolvedResource> for ApiLinkResolvedResource {
        fn from(value: &ApiLinkResolvedResource) -> Self {
            value.clone()
        }
    }

    ///The type of this resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of this resource.",
    ///  "type": "string",
    ///  "enum": [
    ///    "apiLink"
    ///  ],
    ///  "x-tsType": "Type.ApiLink"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum ApiLinkType {
        #[serde(rename = "apiLink")]
        ApiLink,
    }

    impl ::std::convert::From<&Self> for ApiLinkType {
        fn from(value: &ApiLinkType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ApiLinkType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::ApiLink => f.write_str("apiLink"),
            }
        }
    }

    impl ::std::str::FromStr for ApiLinkType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "apiLink" => Ok(Self::ApiLink),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ApiLinkType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ApiLinkType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ApiLinkType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Request for beginning an export of page content.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Request for beginning an export of page content.",
    ///  "type": "object",
    ///  "required": [
    ///    "outputFormat"
    ///  ],
    ///  "properties": {
    ///    "outputFormat": {
    ///      "$ref": "#/components/schemas/PageContentOutputFormat"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "BeginPageContentExportRequest"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct BeginPageContentExportRequest {
        #[serde(rename = "outputFormat")]
        pub output_format: PageContentOutputFormat,
    }

    impl ::std::convert::From<&BeginPageContentExportRequest> for BeginPageContentExportRequest {
        fn from(value: &BeginPageContentExportRequest) -> Self {
            value.clone()
        }
    }

    ///Response when beginning an export of page content.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Response when beginning an export of page content.",
    ///  "type": "object",
    ///  "required": [
    ///    "href",
    ///    "id",
    ///    "status"
    ///  ],
    ///  "properties": {
    ///    "href": {
    ///      "description": "The URL that reports the status of this export. Poll this URL to get the content URL when the export has completed.",
    ///      "examples": [
    ///        "https://coda.io/apis/v1/docs/somedoc/pages/somepage/export/some-request-id"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "The identifier of this export request.",
    ///      "examples": [
    ///        "AbCDeFGH"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "description": "The status of this export.",
    ///      "examples": [
    ///        "complete"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "BeginPageContentExportResponse"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct BeginPageContentExportResponse {
        ///The URL that reports the status of this export. Poll this URL to get
        /// the content URL when the export has completed.
        pub href: ::std::string::String,
        ///The identifier of this export request.
        pub id: ::std::string::String,
        ///The status of this export.
        pub status: ::std::string::String,
    }

    impl ::std::convert::From<&BeginPageContentExportResponse> for BeginPageContentExportResponse {
        fn from(value: &BeginPageContentExportResponse) -> Self {
            value.clone()
        }
    }

    ///The Pack plan to show the Pack can be accessed if the workspace is at
    /// least the given tier.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The Pack plan to show the Pack can be accessed if the
    /// workspace is at least the given tier.",
    ///  "type": "object",
    ///  "required": [
    ///    "createdAt",
    ///    "packId",
    ///    "packPlanId",
    ///    "pricing"
    ///  ],
    ///  "properties": {
    ///    "createdAt": {
    ///      "description": "Timestamp for when the Pack plan was created.",
    ///      "examples": [
    ///        "2018-04-11T00:18:57.946Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "packId": {
    ///      "type": "number"
    ///    },
    ///    "packPlanId": {
    ///      "type": "string"
    ///    },
    ///    "pricing": {
    ///      "$ref": "#/components/schemas/BundledPackPlanPricing"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "BundledPackPlan"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct BundledPackPlan {
        ///Timestamp for when the Pack plan was created.
        #[serde(rename = "createdAt")]
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        #[serde(rename = "packId")]
        pub pack_id: f64,
        #[serde(rename = "packPlanId")]
        pub pack_plan_id: ::std::string::String,
        pub pricing: BundledPackPlanPricing,
    }

    impl ::std::convert::From<&BundledPackPlan> for BundledPackPlan {
        fn from(value: &BundledPackPlan) -> Self {
            value.clone()
        }
    }

    ///Pricing used when workspaces have access to the Pack for free if their
    /// workspace is at least the given tier.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Pricing used when workspaces have access to the Pack
    /// for free if their workspace is at least the given tier.",
    ///  "type": "object",
    ///  "required": [
    ///    "minimumFeatureSet",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "minimumFeatureSet": {
    ///      "$ref": "#/components/schemas/PaidFeatureSet"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "BundledWithTier"
    ///      ],
    ///      "x-tsType": "PackPlanPricingType.BundledWithTier"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "BundledPackPlanPricing"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct BundledPackPlanPricing {
        #[serde(rename = "minimumFeatureSet")]
        pub minimum_feature_set: PaidFeatureSet,
        #[serde(rename = "type")]
        pub type_: BundledPackPlanPricingType,
    }

    impl ::std::convert::From<&BundledPackPlanPricing> for BundledPackPlanPricing {
        fn from(value: &BundledPackPlanPricing) -> Self {
            value.clone()
        }
    }

    ///`BundledPackPlanPricingType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "BundledWithTier"
    ///  ],
    ///  "x-tsType": "PackPlanPricingType.BundledWithTier"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum BundledPackPlanPricingType {
        BundledWithTier,
    }

    impl ::std::convert::From<&Self> for BundledPackPlanPricingType {
        fn from(value: &BundledPackPlanPricingType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for BundledPackPlanPricingType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::BundledWithTier => f.write_str("BundledWithTier"),
            }
        }
    }

    impl ::std::str::FromStr for BundledPackPlanPricingType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "BundledWithTier" => Ok(Self::BundledWithTier),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for BundledPackPlanPricingType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for BundledPackPlanPricingType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for BundledPackPlanPricingType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`ButtonColumnFormat`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Format of a button column.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/SimpleColumnFormat"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "action": {
    ///          "description": "Action formula for the button.",
    ///          "examples": [
    ///            "OpenUrl(\"www.google.com\")"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "disableIf": {
    ///          "description": "DisableIf formula for the button.",
    ///          "examples": [
    ///            "False()"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "label": {
    ///          "description": "Label formula for the button.",
    ///          "examples": [
    ///            "Click me"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  ],
    ///  "x-schema-name": "ButtonColumnFormat"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(deny_unknown_fields)]
    pub enum ButtonColumnFormat {}
    impl ::std::convert::From<&Self> for ButtonColumnFormat {
        fn from(value: &ButtonColumnFormat) -> Self {
            value.clone()
        }
    }

    ///An edit made to a particular cell in a row.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An edit made to a particular cell in a row.",
    ///  "type": "object",
    ///  "required": [
    ///    "column",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "column": {
    ///      "description": "Column ID, URL, or name (fragile and discouraged)
    /// associated with this edit.",
    ///      "examples": [
    ///        "c-tuVwxYz"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/Value"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "CellEdit"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct CellEdit {
        ///Column ID, URL, or name (fragile and discouraged) associated with
        /// this edit.
        pub column: ::std::string::String,
        pub value: Value,
    }

    impl ::std::convert::From<&CellEdit> for CellEdit {
        fn from(value: &CellEdit) -> Self {
            value.clone()
        }
    }

    ///All values that a row cell can contain.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "All values that a row cell can contain.",
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/Value"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/RichValue"
    ///    }
    ///  ],
    ///  "x-schema-name": "CellValue"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum CellValue {
        Value(Value),
        RichValue(RichValue),
    }

    impl ::std::convert::From<&Self> for CellValue {
        fn from(value: &CellValue) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<Value> for CellValue {
        fn from(value: Value) -> Self {
            Self::Value(value)
        }
    }

    impl ::std::convert::From<RichValue> for CellValue {
        fn from(value: RichValue) -> Self {
            Self::RichValue(value)
        }
    }

    ///Parameters for changing a workspace user role.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Parameters for changing a workspace user role.",
    ///  "type": "object",
    ///  "required": [
    ///    "email",
    ///    "newRole"
    ///  ],
    ///  "properties": {
    ///    "email": {
    ///      "description": "Email of the user.",
    ///      "examples": [
    ///        "hello@coda.io"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "newRole": {
    ///      "$ref": "#/components/schemas/WorkspaceUserRole"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "ChangeRole"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ChangeRole {
        ///Email of the user.
        pub email: ::std::string::String,
        #[serde(rename = "newRole")]
        pub new_role: WorkspaceUserRole,
    }

    impl ::std::convert::From<&ChangeRole> for ChangeRole {
        fn from(value: &ChangeRole) -> Self {
            value.clone()
        }
    }

    ///The result of changing a user's workspace user role.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The result of changing a user's workspace user role.",
    ///  "type": "object",
    ///  "required": [
    ///    "roleChangedAt"
    ///  ],
    ///  "properties": {
    ///    "roleChangedAt": {
    ///      "description": "Timestamp for when the user's role last changed in
    /// this workspace.",
    ///      "examples": [
    ///        "2018-04-11T00:18:57.946Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "ChangeRoleResult"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ChangeRoleResult {
        ///Timestamp for when the user's role last changed in this workspace.
        #[serde(rename = "roleChangedAt")]
        pub role_changed_at: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&ChangeRoleResult> for ChangeRoleResult {
        fn from(value: &ChangeRoleResult) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        401
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ChangeUserRoleResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&ChangeUserRoleResponse> for ChangeUserRoleResponse {
        fn from(value: &ChangeUserRoleResponse) -> Self {
            value.clone()
        }
    }

    ///`CheckboxColumnFormat`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Format of a checkbox column.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/SimpleColumnFormat"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "displayType"
    ///      ],
    ///      "properties": {
    ///        "displayType": {
    ///          "$ref": "#/components/schemas/CheckboxDisplayType"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  ],
    ///  "x-schema-name": "CheckboxColumnFormat"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(deny_unknown_fields)]
    pub enum CheckboxColumnFormat {}
    impl ::std::convert::From<&Self> for CheckboxColumnFormat {
        fn from(value: &CheckboxColumnFormat) -> Self {
            value.clone()
        }
    }

    ///How a checkbox should be displayed.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "How a checkbox should be displayed.",
    ///  "type": "string",
    ///  "enum": [
    ///    "toggle",
    ///    "check"
    ///  ],
    ///  "x-schema-name": "CheckboxDisplayType",
    ///  "x-tsEnumNames": [
    ///    "Toggle",
    ///    "Check"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum CheckboxDisplayType {
        #[serde(rename = "toggle")]
        Toggle,
        #[serde(rename = "check")]
        Check,
    }

    impl ::std::convert::From<&Self> for CheckboxDisplayType {
        fn from(value: &CheckboxDisplayType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for CheckboxDisplayType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Toggle => f.write_str("toggle"),
                Self::Check => f.write_str("check"),
            }
        }
    }

    impl ::std::str::FromStr for CheckboxDisplayType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "toggle" => Ok(Self::Toggle),
                "check" => Ok(Self::Check),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for CheckboxDisplayType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for CheckboxDisplayType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CheckboxDisplayType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Info about a column.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Info about a column.",
    ///  "type": "object",
    ///  "required": [
    ///    "format",
    ///    "href",
    ///    "id",
    ///    "name",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "calculated": {
    ///      "description": "Whether the column has a formula set on it.",
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "defaultValue": {
    ///      "description": "Default value formula for the column.",
    ///      "examples": [
    ///        "Test"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "display": {
    ///      "description": "Whether the column is the display column.",
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "format": {
    ///      "$ref": "#/components/schemas/ColumnFormat"
    ///    },
    ///    "formula": {
    ///      "description": "Formula on the column.",
    ///      "examples": [
    ///        "thisRow.Created()"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "href": {
    ///      "description": "API link to the column.",
    ///      "examples": [
    ///        "https://coda.io/apis/v1/docs/AbCDeFGH/tables/grid-pqRst-U/columns/c-tuVwxYz"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "id": {
    ///      "description": "ID of the column.",
    ///      "examples": [
    ///        "c-tuVwxYz"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "Name of the column.",
    ///      "examples": [
    ///        "Completed"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "description": "The type of this resource.",
    ///      "type": "string",
    ///      "enum": [
    ///        "column"
    ///      ],
    ///      "x-tsType": "Type.Column"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "Column"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct Column {
        ///Whether the column has a formula set on it.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub calculated: ::std::option::Option<bool>,
        ///Default value formula for the column.
        #[serde(rename = "defaultValue", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub default_value: ::std::option::Option<::std::string::String>,
        ///Whether the column is the display column.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub display: ::std::option::Option<bool>,
        pub format: ColumnFormat,
        ///Formula on the column.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub formula: ::std::option::Option<::std::string::String>,
        ///API link to the column.
        pub href: ::std::string::String,
        ///ID of the column.
        pub id: ::std::string::String,
        ///Name of the column.
        pub name: ::std::string::String,
        ///The type of this resource.
        #[serde(rename = "type")]
        pub type_: ColumnType,
    }

    impl ::std::convert::From<&Column> for Column {
        fn from(value: &Column) -> Self {
            value.clone()
        }
    }

    ///Info about a column.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Info about a column.",
    ///  "type": "object",
    ///  "required": [
    ///    "format",
    ///    "href",
    ///    "id",
    ///    "name",
    ///    "parent",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "calculated": {
    ///      "description": "Whether the column has a formula set on it.",
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "defaultValue": {
    ///      "description": "Default value formula for the column.",
    ///      "examples": [
    ///        "Test"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "display": {
    ///      "description": "Whether the column is the display column.",
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "format": {
    ///      "$ref": "#/components/schemas/ColumnFormat"
    ///    },
    ///    "formula": {
    ///      "description": "Formula on the column.",
    ///      "examples": [
    ///        "thisRow.Created()"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "href": {
    ///      "description": "API link to the column.",
    ///      "examples": [
    ///        "https://coda.io/apis/v1/docs/AbCDeFGH/tables/grid-pqRst-U/columns/c-tuVwxYz"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "id": {
    ///      "description": "ID of the column.",
    ///      "examples": [
    ///        "c-tuVwxYz"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "Name of the column.",
    ///      "examples": [
    ///        "Completed"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "parent": {
    ///      "$ref": "#/components/schemas/TableReference"
    ///    },
    ///    "type": {
    ///      "description": "The type of this resource.",
    ///      "type": "string",
    ///      "enum": [
    ///        "column"
    ///      ],
    ///      "x-tsType": "Type.Column"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "ColumnDetail"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ColumnDetail {
        ///Whether the column has a formula set on it.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub calculated: ::std::option::Option<bool>,
        ///Default value formula for the column.
        #[serde(rename = "defaultValue", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub default_value: ::std::option::Option<::std::string::String>,
        ///Whether the column is the display column.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub display: ::std::option::Option<bool>,
        pub format: ColumnFormat,
        ///Formula on the column.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub formula: ::std::option::Option<::std::string::String>,
        ///API link to the column.
        pub href: ::std::string::String,
        ///ID of the column.
        pub id: ::std::string::String,
        ///Name of the column.
        pub name: ::std::string::String,
        pub parent: TableReference,
        ///The type of this resource.
        #[serde(rename = "type")]
        pub type_: ColumnDetailType,
    }

    impl ::std::convert::From<&ColumnDetail> for ColumnDetail {
        fn from(value: &ColumnDetail) -> Self {
            value.clone()
        }
    }

    ///The type of this resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of this resource.",
    ///  "type": "string",
    ///  "enum": [
    ///    "column"
    ///  ],
    ///  "x-tsType": "Type.Column"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum ColumnDetailType {
        #[serde(rename = "column")]
        Column,
    }

    impl ::std::convert::From<&Self> for ColumnDetailType {
        fn from(value: &ColumnDetailType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ColumnDetailType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Column => f.write_str("column"),
            }
        }
    }

    impl ::std::str::FromStr for ColumnDetailType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "column" => Ok(Self::Column),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ColumnDetailType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ColumnDetailType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ColumnDetailType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Format of a column.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Format of a column.",
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ButtonColumnFormat"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/CheckboxColumnFormat"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/DateColumnFormat"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/DateTimeColumnFormat"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/DurationColumnFormat"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/EmailColumnFormat"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkColumnFormat"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/CurrencyColumnFormat"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ImageReferenceColumnFormat"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/NumericColumnFormat"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ReferenceColumnFormat"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/SelectColumnFormat"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/SimpleColumnFormat"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ScaleColumnFormat"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/SliderColumnFormat"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/TimeColumnFormat"
    ///    }
    ///  ],
    ///  "x-schema-name": "ColumnFormat"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum ColumnFormat {
        ButtonColumnFormat(ButtonColumnFormat),
        CheckboxColumnFormat(CheckboxColumnFormat),
        DateColumnFormat(DateColumnFormat),
        DateTimeColumnFormat(DateTimeColumnFormat),
        DurationColumnFormat(DurationColumnFormat),
        EmailColumnFormat(EmailColumnFormat),
        LinkColumnFormat(LinkColumnFormat),
        CurrencyColumnFormat(CurrencyColumnFormat),
        ImageReferenceColumnFormat(ImageReferenceColumnFormat),
        NumericColumnFormat(NumericColumnFormat),
        ReferenceColumnFormat(ReferenceColumnFormat),
        SelectColumnFormat(SelectColumnFormat),
        SimpleColumnFormat(SimpleColumnFormat),
        ScaleColumnFormat(ScaleColumnFormat),
        SliderColumnFormat(SliderColumnFormat),
        TimeColumnFormat(TimeColumnFormat),
    }

    impl ::std::convert::From<&Self> for ColumnFormat {
        fn from(value: &ColumnFormat) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<ButtonColumnFormat> for ColumnFormat {
        fn from(value: ButtonColumnFormat) -> Self {
            Self::ButtonColumnFormat(value)
        }
    }

    impl ::std::convert::From<CheckboxColumnFormat> for ColumnFormat {
        fn from(value: CheckboxColumnFormat) -> Self {
            Self::CheckboxColumnFormat(value)
        }
    }

    impl ::std::convert::From<DateColumnFormat> for ColumnFormat {
        fn from(value: DateColumnFormat) -> Self {
            Self::DateColumnFormat(value)
        }
    }

    impl ::std::convert::From<DateTimeColumnFormat> for ColumnFormat {
        fn from(value: DateTimeColumnFormat) -> Self {
            Self::DateTimeColumnFormat(value)
        }
    }

    impl ::std::convert::From<DurationColumnFormat> for ColumnFormat {
        fn from(value: DurationColumnFormat) -> Self {
            Self::DurationColumnFormat(value)
        }
    }

    impl ::std::convert::From<EmailColumnFormat> for ColumnFormat {
        fn from(value: EmailColumnFormat) -> Self {
            Self::EmailColumnFormat(value)
        }
    }

    impl ::std::convert::From<LinkColumnFormat> for ColumnFormat {
        fn from(value: LinkColumnFormat) -> Self {
            Self::LinkColumnFormat(value)
        }
    }

    impl ::std::convert::From<CurrencyColumnFormat> for ColumnFormat {
        fn from(value: CurrencyColumnFormat) -> Self {
            Self::CurrencyColumnFormat(value)
        }
    }

    impl ::std::convert::From<ImageReferenceColumnFormat> for ColumnFormat {
        fn from(value: ImageReferenceColumnFormat) -> Self {
            Self::ImageReferenceColumnFormat(value)
        }
    }

    impl ::std::convert::From<NumericColumnFormat> for ColumnFormat {
        fn from(value: NumericColumnFormat) -> Self {
            Self::NumericColumnFormat(value)
        }
    }

    impl ::std::convert::From<ReferenceColumnFormat> for ColumnFormat {
        fn from(value: ReferenceColumnFormat) -> Self {
            Self::ReferenceColumnFormat(value)
        }
    }

    impl ::std::convert::From<SelectColumnFormat> for ColumnFormat {
        fn from(value: SelectColumnFormat) -> Self {
            Self::SelectColumnFormat(value)
        }
    }

    impl ::std::convert::From<SimpleColumnFormat> for ColumnFormat {
        fn from(value: SimpleColumnFormat) -> Self {
            Self::SimpleColumnFormat(value)
        }
    }

    impl ::std::convert::From<ScaleColumnFormat> for ColumnFormat {
        fn from(value: ScaleColumnFormat) -> Self {
            Self::ScaleColumnFormat(value)
        }
    }

    impl ::std::convert::From<SliderColumnFormat> for ColumnFormat {
        fn from(value: SliderColumnFormat) -> Self {
            Self::SliderColumnFormat(value)
        }
    }

    impl ::std::convert::From<TimeColumnFormat> for ColumnFormat {
        fn from(value: TimeColumnFormat) -> Self {
            Self::TimeColumnFormat(value)
        }
    }

    ///Format type of the column
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Format type of the column",
    ///  "type": "string",
    ///  "enum": [
    ///    "text",
    ///    "person",
    ///    "lookup",
    ///    "number",
    ///    "percent",
    ///    "currency",
    ///    "date",
    ///    "dateTime",
    ///    "time",
    ///    "duration",
    ///    "email",
    ///    "link",
    ///    "slider",
    ///    "scale",
    ///    "image",
    ///    "imageReference",
    ///    "attachments",
    ///    "button",
    ///    "checkbox",
    ///    "select",
    ///    "packObject",
    ///    "reaction",
    ///    "canvas",
    ///    "other"
    ///  ],
    ///  "x-schema-name": "ColumnFormatType",
    ///  "x-tsEnumNames": [
    ///    "Text",
    ///    "Person",
    ///    "Lookup",
    ///    "Number",
    ///    "Percent",
    ///    "Currency",
    ///    "Date",
    ///    "DateTime",
    ///    "Time",
    ///    "Duration",
    ///    "Email",
    ///    "Link",
    ///    "Slider",
    ///    "Scale",
    ///    "Image",
    ///    "ImageReference",
    ///    "Attachments",
    ///    "Button",
    ///    "Checkbox",
    ///    "Select",
    ///    "PackObject",
    ///    "Reaction",
    ///    "Canvas",
    ///    "Other"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum ColumnFormatType {
        #[serde(rename = "text")]
        Text,
        #[serde(rename = "person")]
        Person,
        #[serde(rename = "lookup")]
        Lookup,
        #[serde(rename = "number")]
        Number,
        #[serde(rename = "percent")]
        Percent,
        #[serde(rename = "currency")]
        Currency,
        #[serde(rename = "date")]
        Date,
        #[serde(rename = "dateTime")]
        DateTime,
        #[serde(rename = "time")]
        Time,
        #[serde(rename = "duration")]
        Duration,
        #[serde(rename = "email")]
        Email,
        #[serde(rename = "link")]
        Link,
        #[serde(rename = "slider")]
        Slider,
        #[serde(rename = "scale")]
        Scale,
        #[serde(rename = "image")]
        Image,
        #[serde(rename = "imageReference")]
        ImageReference,
        #[serde(rename = "attachments")]
        Attachments,
        #[serde(rename = "button")]
        Button,
        #[serde(rename = "checkbox")]
        Checkbox,
        #[serde(rename = "select")]
        Select,
        #[serde(rename = "packObject")]
        PackObject,
        #[serde(rename = "reaction")]
        Reaction,
        #[serde(rename = "canvas")]
        Canvas,
        #[serde(rename = "other")]
        Other,
    }

    impl ::std::convert::From<&Self> for ColumnFormatType {
        fn from(value: &ColumnFormatType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ColumnFormatType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Text => f.write_str("text"),
                Self::Person => f.write_str("person"),
                Self::Lookup => f.write_str("lookup"),
                Self::Number => f.write_str("number"),
                Self::Percent => f.write_str("percent"),
                Self::Currency => f.write_str("currency"),
                Self::Date => f.write_str("date"),
                Self::DateTime => f.write_str("dateTime"),
                Self::Time => f.write_str("time"),
                Self::Duration => f.write_str("duration"),
                Self::Email => f.write_str("email"),
                Self::Link => f.write_str("link"),
                Self::Slider => f.write_str("slider"),
                Self::Scale => f.write_str("scale"),
                Self::Image => f.write_str("image"),
                Self::ImageReference => f.write_str("imageReference"),
                Self::Attachments => f.write_str("attachments"),
                Self::Button => f.write_str("button"),
                Self::Checkbox => f.write_str("checkbox"),
                Self::Select => f.write_str("select"),
                Self::PackObject => f.write_str("packObject"),
                Self::Reaction => f.write_str("reaction"),
                Self::Canvas => f.write_str("canvas"),
                Self::Other => f.write_str("other"),
            }
        }
    }

    impl ::std::str::FromStr for ColumnFormatType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "text" => Ok(Self::Text),
                "person" => Ok(Self::Person),
                "lookup" => Ok(Self::Lookup),
                "number" => Ok(Self::Number),
                "percent" => Ok(Self::Percent),
                "currency" => Ok(Self::Currency),
                "date" => Ok(Self::Date),
                "dateTime" => Ok(Self::DateTime),
                "time" => Ok(Self::Time),
                "duration" => Ok(Self::Duration),
                "email" => Ok(Self::Email),
                "link" => Ok(Self::Link),
                "slider" => Ok(Self::Slider),
                "scale" => Ok(Self::Scale),
                "image" => Ok(Self::Image),
                "imageReference" => Ok(Self::ImageReference),
                "attachments" => Ok(Self::Attachments),
                "button" => Ok(Self::Button),
                "checkbox" => Ok(Self::Checkbox),
                "select" => Ok(Self::Select),
                "packObject" => Ok(Self::PackObject),
                "reaction" => Ok(Self::Reaction),
                "canvas" => Ok(Self::Canvas),
                "other" => Ok(Self::Other),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ColumnFormatType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ColumnFormatType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ColumnFormatType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///List of columns.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "List of columns.",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "href": {
    ///      "description": "API link to these results",
    ///      "examples": [
    ///        "https://coda.io/apis/v1/docs/AbCDeFGH/tables/grid-pqRst-U/columns?limit=20"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Column"
    ///      }
    ///    },
    ///    "nextPageLink": {
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/nextPageLink"
    ///        },
    ///        {
    ///          "examples": [
    ///            "https://coda.io/apis/v1/docs/AbCDeFGH/tables/grid-pqRst-U/columns?pageToken=eyJsaW1pd"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      ]
    ///    },
    ///    "nextPageToken": {
    ///      "$ref": "#/components/schemas/nextPageToken"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "ColumnList"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ColumnList {
        ///API link to these results
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub href: ::std::option::Option<::std::string::String>,
        pub items: ::std::vec::Vec<Column>,
        #[serde(rename = "nextPageLink", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_link: ::std::option::Option<NextPageLink>,
        #[serde(rename = "nextPageToken", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_token: ::std::option::Option<NextPageToken>,
    }

    impl ::std::convert::From<&ColumnList> for ColumnList {
        fn from(value: &ColumnList) -> Self {
            value.clone()
        }
    }

    ///Reference to a column.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Reference to a column.",
    ///  "type": "object",
    ///  "required": [
    ///    "href",
    ///    "id",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "href": {
    ///      "description": "API link to the column.",
    ///      "examples": [
    ///        "https://coda.io/apis/v1/docs/AbCDeFGH/tables/grid-pqRst-U/columns/c-tuVwxYz"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "id": {
    ///      "description": "ID of the column.",
    ///      "examples": [
    ///        "c-tuVwxYz"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "description": "The type of this resource.",
    ///      "type": "string",
    ///      "enum": [
    ///        "column"
    ///      ],
    ///      "x-tsType": "Type.Column"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "ColumnReference"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ColumnReference {
        ///API link to the column.
        pub href: ::std::string::String,
        ///ID of the column.
        pub id: ::std::string::String,
        ///The type of this resource.
        #[serde(rename = "type")]
        pub type_: ColumnReferenceType,
    }

    impl ::std::convert::From<&ColumnReference> for ColumnReference {
        fn from(value: &ColumnReference) -> Self {
            value.clone()
        }
    }

    ///The type of this resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of this resource.",
    ///  "type": "string",
    ///  "enum": [
    ///    "column"
    ///  ],
    ///  "x-tsType": "Type.Column"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum ColumnReferenceType {
        #[serde(rename = "column")]
        Column,
    }

    impl ::std::convert::From<&Self> for ColumnReferenceType {
        fn from(value: &ColumnReferenceType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ColumnReferenceType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Column => f.write_str("column"),
            }
        }
    }

    impl ::std::str::FromStr for ColumnReferenceType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "column" => Ok(Self::Column),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ColumnReferenceType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ColumnReferenceType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ColumnReferenceType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The type of this resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of this resource.",
    ///  "type": "string",
    ///  "enum": [
    ///    "column"
    ///  ],
    ///  "x-tsType": "Type.Column"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum ColumnType {
        #[serde(rename = "column")]
        Column,
    }

    impl ::std::convert::From<&Self> for ColumnType {
        fn from(value: &ColumnType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ColumnType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Column => f.write_str("column"),
            }
        }
    }

    impl ::std::str::FromStr for ColumnType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "column" => Ok(Self::Column),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ColumnType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ColumnType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ColumnType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Details about a control.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Details about a control.",
    ///  "type": "object",
    ///  "required": [
    ///    "controlType",
    ///    "href",
    ///    "id",
    ///    "name",
    ///    "type",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "controlType": {
    ///      "$ref": "#/components/schemas/ControlTypeEnum"
    ///    },
    ///    "href": {
    ///      "description": "API link to the control.",
    ///      "examples": [
    ///        "https://coda.io/apis/v1/docs/AbCDeFGH/controls/ctrl-cDefGhij"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "id": {
    ///      "description": "ID of the control.",
    ///      "examples": [
    ///        "ctrl-cDefGhij"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "Name of the control.",
    ///      "examples": [
    ///        "Cost"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "parent": {
    ///      "$ref": "#/components/schemas/PageReference"
    ///    },
    ///    "type": {
    ///      "description": "The type of this resource.",
    ///      "type": "string",
    ///      "enum": [
    ///        "control"
    ///      ],
    ///      "x-tsType": "Type.Control"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/Value"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "Control"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct Control {
        #[serde(rename = "controlType")]
        pub control_type: ControlTypeEnum,
        ///API link to the control.
        pub href: ::std::string::String,
        ///ID of the control.
        pub id: ::std::string::String,
        ///Name of the control.
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub parent: ::std::option::Option<PageReference>,
        ///The type of this resource.
        #[serde(rename = "type")]
        pub type_: ControlType,
        pub value: Value,
    }

    impl ::std::convert::From<&Control> for Control {
        fn from(value: &Control) -> Self {
            value.clone()
        }
    }

    ///List of controls.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "List of controls.",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "href": {
    ///      "description": "API link to these results",
    ///      "examples": [
    ///        "https://coda.io/apis/v1/docs/AbCDeFGH/controls?limit=20"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ControlReference"
    ///      }
    ///    },
    ///    "nextPageLink": {
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/nextPageLink"
    ///        },
    ///        {
    ///          "examples": [
    ///            "https://coda.io/apis/v1/docs/AbCDeFGH/controls?pageToken=eyJsaW1pd"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      ]
    ///    },
    ///    "nextPageToken": {
    ///      "$ref": "#/components/schemas/nextPageToken"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "ControlList"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ControlList {
        ///API link to these results
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub href: ::std::option::Option<::std::string::String>,
        pub items: ::std::vec::Vec<ControlReference>,
        #[serde(rename = "nextPageLink", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_link: ::std::option::Option<NextPageLink>,
        #[serde(rename = "nextPageToken", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_token: ::std::option::Option<NextPageToken>,
    }

    impl ::std::convert::From<&ControlList> for ControlList {
        fn from(value: &ControlList) -> Self {
            value.clone()
        }
    }

    ///Reference to a control.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Reference to a control.",
    ///  "type": "object",
    ///  "required": [
    ///    "href",
    ///    "id",
    ///    "name",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "href": {
    ///      "description": "API link to the control.",
    ///      "examples": [
    ///        "https://coda.io/apis/v1/docs/AbCDeFGH/controls/ctrl-cDefGhij"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "id": {
    ///      "description": "ID of the control.",
    ///      "examples": [
    ///        "ctrl-cDefGhij"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "Name of the control.",
    ///      "examples": [
    ///        "Cost"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "parent": {
    ///      "$ref": "#/components/schemas/PageReference"
    ///    },
    ///    "type": {
    ///      "description": "The type of this resource.",
    ///      "type": "string",
    ///      "enum": [
    ///        "control"
    ///      ],
    ///      "x-tsType": "Type.Control"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "ControlReference"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ControlReference {
        ///API link to the control.
        pub href: ::std::string::String,
        ///ID of the control.
        pub id: ::std::string::String,
        ///Name of the control.
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub parent: ::std::option::Option<PageReference>,
        ///The type of this resource.
        #[serde(rename = "type")]
        pub type_: ControlReferenceType,
    }

    impl ::std::convert::From<&ControlReference> for ControlReference {
        fn from(value: &ControlReference) -> Self {
            value.clone()
        }
    }

    ///The type of this resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of this resource.",
    ///  "type": "string",
    ///  "enum": [
    ///    "control"
    ///  ],
    ///  "x-tsType": "Type.Control"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum ControlReferenceType {
        #[serde(rename = "control")]
        Control,
    }

    impl ::std::convert::From<&Self> for ControlReferenceType {
        fn from(value: &ControlReferenceType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ControlReferenceType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Control => f.write_str("control"),
            }
        }
    }

    impl ::std::str::FromStr for ControlReferenceType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "control" => Ok(Self::Control),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ControlReferenceType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ControlReferenceType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ControlReferenceType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The type of this resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of this resource.",
    ///  "type": "string",
    ///  "enum": [
    ///    "control"
    ///  ],
    ///  "x-tsType": "Type.Control"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum ControlType {
        #[serde(rename = "control")]
        Control,
    }

    impl ::std::convert::From<&Self> for ControlType {
        fn from(value: &ControlType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ControlType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Control => f.write_str("control"),
            }
        }
    }

    impl ::std::str::FromStr for ControlType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "control" => Ok(Self::Control),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ControlType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ControlType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ControlType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Type of the control.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Type of the control.",
    ///  "examples": [
    ///    "slider"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "aiBlock",
    ///    "button",
    ///    "checkbox",
    ///    "datePicker",
    ///    "dateRangePicker",
    ///    "dateTimePicker",
    ///    "lookup",
    ///    "multiselect",
    ///    "select",
    ///    "scale",
    ///    "slider",
    ///    "reaction",
    ///    "textbox",
    ///    "timePicker"
    ///  ],
    ///  "x-schema-name": "ControlTypeEnum",
    ///  "x-tsEnumNames": [
    ///    "AIBlock",
    ///    "Button",
    ///    "Checkbox",
    ///    "DatePicker",
    ///    "DateRangePicker",
    ///    "DateTimePicker",
    ///    "Lookup",
    ///    "Multiselect",
    ///    "Select",
    ///    "Scale",
    ///    "Slider",
    ///    "Reaction",
    ///    "Textbox",
    ///    "TimePicker"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum ControlTypeEnum {
        #[serde(rename = "aiBlock")]
        AiBlock,
        #[serde(rename = "button")]
        Button,
        #[serde(rename = "checkbox")]
        Checkbox,
        #[serde(rename = "datePicker")]
        DatePicker,
        #[serde(rename = "dateRangePicker")]
        DateRangePicker,
        #[serde(rename = "dateTimePicker")]
        DateTimePicker,
        #[serde(rename = "lookup")]
        Lookup,
        #[serde(rename = "multiselect")]
        Multiselect,
        #[serde(rename = "select")]
        Select,
        #[serde(rename = "scale")]
        Scale,
        #[serde(rename = "slider")]
        Slider,
        #[serde(rename = "reaction")]
        Reaction,
        #[serde(rename = "textbox")]
        Textbox,
        #[serde(rename = "timePicker")]
        TimePicker,
    }

    impl ::std::convert::From<&Self> for ControlTypeEnum {
        fn from(value: &ControlTypeEnum) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ControlTypeEnum {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AiBlock => f.write_str("aiBlock"),
                Self::Button => f.write_str("button"),
                Self::Checkbox => f.write_str("checkbox"),
                Self::DatePicker => f.write_str("datePicker"),
                Self::DateRangePicker => f.write_str("dateRangePicker"),
                Self::DateTimePicker => f.write_str("dateTimePicker"),
                Self::Lookup => f.write_str("lookup"),
                Self::Multiselect => f.write_str("multiselect"),
                Self::Select => f.write_str("select"),
                Self::Scale => f.write_str("scale"),
                Self::Slider => f.write_str("slider"),
                Self::Reaction => f.write_str("reaction"),
                Self::Textbox => f.write_str("textbox"),
                Self::TimePicker => f.write_str("timePicker"),
            }
        }
    }

    impl ::std::str::FromStr for ControlTypeEnum {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "aiBlock" => Ok(Self::AiBlock),
                "button" => Ok(Self::Button),
                "checkbox" => Ok(Self::Checkbox),
                "datePicker" => Ok(Self::DatePicker),
                "dateRangePicker" => Ok(Self::DateRangePicker),
                "dateTimePicker" => Ok(Self::DateTimePicker),
                "lookup" => Ok(Self::Lookup),
                "multiselect" => Ok(Self::Multiselect),
                "select" => Ok(Self::Select),
                "scale" => Ok(Self::Scale),
                "slider" => Ok(Self::Slider),
                "reaction" => Ok(Self::Reaction),
                "textbox" => Ok(Self::Textbox),
                "timePicker" => Ok(Self::TimePicker),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ControlTypeEnum {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ControlTypeEnum {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ControlTypeEnum {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct CreateDocResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&CreateDocResponse> for CreateDocResponse {
        fn from(value: &CreateDocResponse) -> Self {
            value.clone()
        }
    }

    ///Payload for creating a new Pack release.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Payload for creating a new Pack release.",
    ///  "type": "object",
    ///  "required": [
    ///    "packVersion"
    ///  ],
    ///  "properties": {
    ///    "packVersion": {
    ///      "description": "Which semantic pack version that the release will
    /// be created on.",
    ///      "examples": [
    ///        "1.0.0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "releaseNotes": {
    ///      "description": "Developers notes.",
    ///      "examples": [
    ///        "The first release."
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "CreatePackReleaseRequest"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct CreatePackReleaseRequest {
        ///Which semantic pack version that the release will be created on.
        #[serde(rename = "packVersion")]
        pub pack_version: ::std::string::String,
        ///Developers notes.
        #[serde(rename = "releaseNotes", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub release_notes: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&CreatePackReleaseRequest> for CreatePackReleaseRequest {
        fn from(value: &CreatePackReleaseRequest) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "codaDetail": {
    ///      "description": "Detail about why this request was rejected.",
    ///      "type": "object",
    ///      "properties": {
    ///        "validationErrors": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/ValidationError"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    },
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct CreatePackReleaseResponse {
        #[serde(rename = "codaDetail", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub coda_detail: ::std::option::Option<CreatePackReleaseResponseCodaDetail>,
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&CreatePackReleaseResponse> for CreatePackReleaseResponse {
        fn from(value: &CreatePackReleaseResponse) -> Self {
            value.clone()
        }
    }

    ///Detail about why this request was rejected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why this request was rejected.",
    ///  "type": "object",
    ///  "properties": {
    ///    "validationErrors": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct CreatePackReleaseResponseCodaDetail {
        #[serde(rename = "validationErrors", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub validation_errors: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&CreatePackReleaseResponseCodaDetail> for CreatePackReleaseResponseCodaDetail {
        fn from(value: &CreatePackReleaseResponseCodaDetail) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for CreatePackReleaseResponseCodaDetail {
        fn default() -> Self {
            Self {
                validation_errors: Default::default(),
            }
        }
    }

    ///Payload for creating a Pack.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Payload for creating a Pack.",
    ///  "type": "object",
    ///  "properties": {
    ///    "description": {
    ///      "description": "A brief description of the Pack.",
    ///      "examples": [
    ///        "Common trigonometric functions."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "The name for the Pack.",
    ///      "examples": [
    ///        "Trigonometry"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "sourcePackId": {
    ///      "description": "The ID of the new Pack's source, if this new Pack
    /// was forked.",
    ///      "examples": [
    ///        10029
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "workspaceId": {
    ///      "description": "The parent workspace for the Pack. If unspecified,
    /// the user's default workspace will be used.",
    ///      "examples": [
    ///        "ws-asdf"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "CreatePackRequest"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct CreatePackRequest {
        ///A brief description of the Pack.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        ///The name for the Pack.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        ///The ID of the new Pack's source, if this new Pack was forked.
        #[serde(rename = "sourcePackId", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub source_pack_id: ::std::option::Option<f64>,
        ///The parent workspace for the Pack. If unspecified, the user's
        /// default workspace will be used.
        #[serde(rename = "workspaceId", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub workspace_id: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&CreatePackRequest> for CreatePackRequest {
        fn from(value: &CreatePackRequest) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for CreatePackRequest {
        fn default() -> Self {
            Self {
                description: Default::default(),
                name: Default::default(),
                source_pack_id: Default::default(),
                workspace_id: Default::default(),
            }
        }
    }

    ///Info about a Pack that was just created.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Info about a Pack that was just created.",
    ///  "type": "object",
    ///  "required": [
    ///    "packId"
    ///  ],
    ///  "properties": {
    ///    "packId": {
    ///      "description": "The ID assigned to the newly-created Pack.",
    ///      "examples": [
    ///        123
    ///      ],
    ///      "type": "number"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "CreatePackResponse"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct CreatePackResponse {
        #[serde(rename = "packId")]
        pub pack_id: f64,
    }

    impl ::std::convert::From<&CreatePackResponse> for CreatePackResponse {
        fn from(value: &CreatePackResponse) -> Self {
            value.clone()
        }
    }

    ///Payload for Pack version upload complete.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Payload for Pack version upload complete.",
    ///  "type": "object",
    ///  "properties": {
    ///    "allowOlderSdkVersion": {
    ///      "description": "Bypass Coda's protection against SDK version
    /// regression when multiple makers build versions.",
    ///      "type": "boolean"
    ///    },
    ///    "notes": {
    ///      "description": "Developer notes of the new Pack version.",
    ///      "examples": [
    ///        "Adding a new formula HelloWorld."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "source": {
    ///      "$ref": "#/components/schemas/PackSource"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "CreatePackVersionRequest"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct CreatePackVersionRequest {
        ///Bypass Coda's protection against SDK version regression when
        /// multiple makers build versions.
        #[serde(rename = "allowOlderSdkVersion", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub allow_older_sdk_version: ::std::option::Option<bool>,
        ///Developer notes of the new Pack version.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub notes: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub source: ::std::option::Option<PackSource>,
    }

    impl ::std::convert::From<&CreatePackVersionRequest> for CreatePackVersionRequest {
        fn from(value: &CreatePackVersionRequest) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for CreatePackVersionRequest {
        fn default() -> Self {
            Self {
                allow_older_sdk_version: Default::default(),
                notes: Default::default(),
                source: Default::default(),
            }
        }
    }

    ///Confirmation of successful Pack version creation.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Confirmation of successful Pack version creation.",
    ///  "type": "object",
    ///  "properties": {
    ///    "deprecationWarnings": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "CreatePackVersionResponse"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct CreatePackVersionResponse {
        #[serde(rename = "deprecationWarnings", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub deprecation_warnings: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&CreatePackVersionResponse> for CreatePackVersionResponse {
        fn from(value: &CreatePackVersionResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for CreatePackVersionResponse {
        fn default() -> Self {
            Self {
                deprecation_warnings: Default::default(),
            }
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct CreatePageResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&CreatePageResponse> for CreatePageResponse {
        fn from(value: &CreatePageResponse) -> Self {
            value.clone()
        }
    }

    ///A numeric monetary amount as a string or number.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A numeric monetary amount as a string or number.",
    ///  "oneOf": [
    ///    {
    ///      "examples": [
    ///        "12.99"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    {
    ///      "examples": [
    ///        42
    ///      ],
    ///      "type": "number"
    ///    }
    ///  ],
    ///  "x-schema-name": "CurrencyAmount"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum CurrencyAmount {
        Variant0(::std::string::String),
        Variant1(f64),
    }

    impl ::std::convert::From<&Self> for CurrencyAmount {
        fn from(value: &CurrencyAmount) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for CurrencyAmount {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<f64> for CurrencyAmount {
        fn from(value: f64) -> Self {
            Self::Variant1(value)
        }
    }

    ///`CurrencyColumnFormat`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Format of a currency column.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/SimpleColumnFormat"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "currencyCode": {
    ///          "description": "The currency symbol",
    ///          "examples": [
    ///            "$"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "format": {
    ///          "$ref": "#/components/schemas/CurrencyFormatType"
    ///        },
    ///        "precision": {
    ///          "description": "The decimal precision.",
    ///          "examples": [
    ///            2
    ///          ],
    ///          "type": "integer",
    ///          "maximum": 10.0,
    ///          "minimum": 0.0
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  ],
    ///  "x-schema-name": "CurrencyColumnFormat"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(deny_unknown_fields)]
    pub enum CurrencyColumnFormat {}
    impl ::std::convert::From<&Self> for CurrencyColumnFormat {
        fn from(value: &CurrencyColumnFormat) -> Self {
            value.clone()
        }
    }

    ///How the numeric value should be formatted (with or without symbol,
    /// negative numbers in parens).
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "How the numeric value should be formatted (with or
    /// without symbol, negative numbers in parens).",
    ///  "type": "string",
    ///  "enum": [
    ///    "currency",
    ///    "accounting",
    ///    "financial"
    ///  ],
    ///  "x-schema-name": "CurrencyFormatType",
    ///  "x-tsEnumNames": [
    ///    "Currency",
    ///    "Accounting",
    ///    "Financial"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum CurrencyFormatType {
        #[serde(rename = "currency")]
        Currency,
        #[serde(rename = "accounting")]
        Accounting,
        #[serde(rename = "financial")]
        Financial,
    }

    impl ::std::convert::From<&Self> for CurrencyFormatType {
        fn from(value: &CurrencyFormatType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for CurrencyFormatType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Currency => f.write_str("currency"),
                Self::Accounting => f.write_str("accounting"),
                Self::Financial => f.write_str("financial"),
            }
        }
    }

    impl ::std::str::FromStr for CurrencyFormatType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "currency" => Ok(Self::Currency),
                "accounting" => Ok(Self::Accounting),
                "financial" => Ok(Self::Financial),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for CurrencyFormatType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for CurrencyFormatType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CurrencyFormatType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`CurrencyValue`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A monetary value with its associated currency code.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/LinkedDataObject"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "@type",
    ///        "amount",
    ///        "currency"
    ///      ],
    ///      "properties": {
    ///        "@type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "MonetaryAmount"
    ///          ],
    ///          "x-tsType": "LinkedDataType.MonetaryAmount"
    ///        },
    ///        "amount": {
    ///          "$ref": "#/components/schemas/CurrencyAmount"
    ///        },
    ///        "currency": {
    ///          "description": "The 3-letter currency code.",
    ///          "examples": [
    ///            "USD"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  ],
    ///  "x-schema-name": "CurrencyValue"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(deny_unknown_fields)]
    pub enum CurrencyValue {}
    impl ::std::convert::From<&Self> for CurrencyValue {
        fn from(value: &CurrencyValue) -> Self {
            value.clone()
        }
    }

    ///The custom domain added to a published doc.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The custom domain added to a published doc.",
    ///  "type": "object",
    ///  "required": [
    ///    "customDocDomain",
    ///    "domainStatus",
    ///    "hasCertificate",
    ///    "hasDnsDocId",
    ///    "setupStatus"
    ///  ],
    ///  "properties": {
    ///    "customDocDomain": {
    ///      "description": "The custom domain.",
    ///      "examples": [
    ///        "example.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "domainStatus": {
    ///      "$ref": "#/components/schemas/CustomDomainConnectedStatus"
    ///    },
    ///    "hasCertificate": {
    ///      "description": "Whether the domain has a certificate",
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "hasDnsDocId": {
    ///      "description": "Whether the domain DNS points back to this doc.",
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "lastVerifiedTimestamp": {
    ///      "description": "When the domain DNS settings were last checked.",
    ///      "examples": [
    ///        "2018-04-11T00:18:57.946Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "setupStatus": {
    ///      "$ref": "#/components/schemas/CustomDocDomainSetupStatus"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "CustomDocDomain"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct CustomDocDomain {
        ///The custom domain.
        #[serde(rename = "customDocDomain")]
        pub custom_doc_domain: ::std::string::String,
        #[serde(rename = "domainStatus")]
        pub domain_status: CustomDomainConnectedStatus,
        ///Whether the domain has a certificate
        #[serde(rename = "hasCertificate")]
        pub has_certificate: bool,
        ///Whether the domain DNS points back to this doc.
        #[serde(rename = "hasDnsDocId")]
        pub has_dns_doc_id: bool,
        ///When the domain DNS settings were last checked.
        #[serde(rename = "lastVerifiedTimestamp", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_verified_timestamp: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        #[serde(rename = "setupStatus")]
        pub setup_status: CustomDocDomainSetupStatus,
    }

    impl ::std::convert::From<&CustomDocDomain> for CustomDocDomain {
        fn from(value: &CustomDocDomain) -> Self {
            value.clone()
        }
    }

    ///List of all custom domains added to a published doc.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "List of all custom domains added to a published doc.",
    ///  "type": "object",
    ///  "required": [
    ///    "customDocDomains"
    ///  ],
    ///  "properties": {
    ///    "customDocDomains": {
    ///      "description": "Custom domains for the published doc.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/CustomDocDomain"
    ///      }
    ///    },
    ///    "nextPageLink": {
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/nextPageLink"
    ///        },
    ///        {
    ///          "examples": [
    ///            "https://coda.io/apis/v1/docs/AbCDeFGH/domains?pageToken=eyJsaW1pd"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      ]
    ///    },
    ///    "nextPageToken": {
    ///      "$ref": "#/components/schemas/nextPageToken"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "CustomDocDomainList"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct CustomDocDomainList {
        ///Custom domains for the published doc.
        #[serde(rename = "customDocDomains")]
        pub custom_doc_domains: ::std::vec::Vec<CustomDocDomain>,
        #[serde(rename = "nextPageLink", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_link: ::std::option::Option<NextPageLink>,
        #[serde(rename = "nextPageToken", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_token: ::std::option::Option<NextPageToken>,
    }

    impl ::std::convert::From<&CustomDocDomainList> for CustomDocDomainList {
        fn from(value: &CustomDocDomainList) -> Self {
            value.clone()
        }
    }

    ///`CustomDocDomainProvider`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "GoDaddy",
    ///    "Namecheap",
    ///    "Hover (Tucows)",
    ///    "Network Solutions",
    ///    "Google Domains",
    ///    "Other"
    ///  ],
    ///  "x-schema-name": "CustomDocDomainProvider",
    ///  "x-tsEnumNames": [
    ///    "GoDaddy",
    ///    "Namecheap",
    ///    "Hover",
    ///    "NetworkSolutions",
    ///    "GoogleDomains",
    ///    "Other"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum CustomDocDomainProvider {
        GoDaddy,
        Namecheap,
        #[serde(rename = "Hover (Tucows)")]
        HoverTucows,
        #[serde(rename = "Network Solutions")]
        NetworkSolutions,
        #[serde(rename = "Google Domains")]
        GoogleDomains,
        Other,
    }

    impl ::std::convert::From<&Self> for CustomDocDomainProvider {
        fn from(value: &CustomDocDomainProvider) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for CustomDocDomainProvider {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GoDaddy => f.write_str("GoDaddy"),
                Self::Namecheap => f.write_str("Namecheap"),
                Self::HoverTucows => f.write_str("Hover (Tucows)"),
                Self::NetworkSolutions => f.write_str("Network Solutions"),
                Self::GoogleDomains => f.write_str("Google Domains"),
                Self::Other => f.write_str("Other"),
            }
        }
    }

    impl ::std::str::FromStr for CustomDocDomainProvider {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "GoDaddy" => Ok(Self::GoDaddy),
                "Namecheap" => Ok(Self::Namecheap),
                "Hover (Tucows)" => Ok(Self::HoverTucows),
                "Network Solutions" => Ok(Self::NetworkSolutions),
                "Google Domains" => Ok(Self::GoogleDomains),
                "Other" => Ok(Self::Other),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for CustomDocDomainProvider {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for CustomDocDomainProvider {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CustomDocDomainProvider {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The result of determining the domain provider for a custom doc domain.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The result of determining the domain provider for a
    /// custom doc domain.",
    ///  "type": "object",
    ///  "required": [
    ///    "provider"
    ///  ],
    ///  "properties": {
    ///    "provider": {
    ///      "$ref": "#/components/schemas/CustomDocDomainProvider"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "CustomDocDomainProviderResponse"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct CustomDocDomainProviderResponse {
        pub provider: CustomDocDomainProvider,
    }

    impl ::std::convert::From<&CustomDocDomainProviderResponse> for CustomDocDomainProviderResponse {
        fn from(value: &CustomDocDomainProviderResponse) -> Self {
            value.clone()
        }
    }

    ///`CustomDocDomainSetupStatus`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "pending",
    ///    "succeeded",
    ///    "failed"
    ///  ],
    ///  "x-schema-name": "CustomDocDomainSetupStatus",
    ///  "x-tsEnumNames": [
    ///    "Pending",
    ///    "Succeeded",
    ///    "Failed"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum CustomDocDomainSetupStatus {
        #[serde(rename = "pending")]
        Pending,
        #[serde(rename = "succeeded")]
        Succeeded,
        #[serde(rename = "failed")]
        Failed,
    }

    impl ::std::convert::From<&Self> for CustomDocDomainSetupStatus {
        fn from(value: &CustomDocDomainSetupStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for CustomDocDomainSetupStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Pending => f.write_str("pending"),
                Self::Succeeded => f.write_str("succeeded"),
                Self::Failed => f.write_str("failed"),
            }
        }
    }

    impl ::std::str::FromStr for CustomDocDomainSetupStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "pending" => Ok(Self::Pending),
                "succeeded" => Ok(Self::Succeeded),
                "failed" => Ok(Self::Failed),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for CustomDocDomainSetupStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for CustomDocDomainSetupStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CustomDocDomainSetupStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`CustomDomainConnectedStatus`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "connected",
    ///    "notConnected"
    ///  ],
    ///  "x-schema-name": "CustomDomainConnectedStatus",
    ///  "x-tsEnumNames": [
    ///    "Connected",
    ///    "NotConnected"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum CustomDomainConnectedStatus {
        #[serde(rename = "connected")]
        Connected,
        #[serde(rename = "notConnected")]
        NotConnected,
    }

    impl ::std::convert::From<&Self> for CustomDomainConnectedStatus {
        fn from(value: &CustomDomainConnectedStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for CustomDomainConnectedStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Connected => f.write_str("connected"),
                Self::NotConnected => f.write_str("notConnected"),
            }
        }
    }

    impl ::std::str::FromStr for CustomDomainConnectedStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "connected" => Ok(Self::Connected),
                "notConnected" => Ok(Self::NotConnected),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for CustomDomainConnectedStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for CustomDomainConnectedStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CustomDomainConnectedStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`DateColumnFormat`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Format of a date column.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/SimpleColumnFormat"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "format": {
    ///          "description": "A format string using Moment syntax: https://momentjs.com/docs/#/displaying/",
    ///          "examples": [
    ///            "YYYY-MM-DD"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  ],
    ///  "x-schema-name": "DateColumnFormat"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(deny_unknown_fields)]
    pub enum DateColumnFormat {}
    impl ::std::convert::From<&Self> for DateColumnFormat {
        fn from(value: &DateColumnFormat) -> Self {
            value.clone()
        }
    }

    ///`DateTimeColumnFormat`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Format of a date column.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/SimpleColumnFormat"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "dateFormat": {
    ///          "description": "A format string using Moment syntax: https://momentjs.com/docs/#/displaying/",
    ///          "examples": [
    ///            "YYYY-MM-DD"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "timeFormat": {
    ///          "description": "A format string using Moment syntax: https://momentjs.com/docs/#/displaying/",
    ///          "examples": [
    ///            "h:mm:ss A"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  ],
    ///  "x-schema-name": "DateTimeColumnFormat"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(deny_unknown_fields)]
    pub enum DateTimeColumnFormat {}
    impl ::std::convert::From<&Self> for DateTimeColumnFormat {
        fn from(value: &DateTimeColumnFormat) -> Self {
            value.clone()
        }
    }

    ///The result of deleting a custom domain from a published doc.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The result of deleting a custom domain from a published
    /// doc.",
    ///  "type": "object",
    ///  "additionalProperties": false,
    ///  "x-schema-name": "DeleteCustomDocDomainResponse"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct DeleteCustomDocDomainResponse {}
    impl ::std::convert::From<&DeleteCustomDocDomainResponse> for DeleteCustomDocDomainResponse {
        fn from(value: &DeleteCustomDocDomainResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for DeleteCustomDocDomainResponse {
        fn default() -> Self {
            Self {}
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        401
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct DeleteDocResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&DeleteDocResponse> for DeleteDocResponse {
        fn from(value: &DeleteDocResponse) -> Self {
            value.clone()
        }
    }

    ///Confirmation of successfully deleting a Pack category.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Confirmation of successfully deleting a Pack
    /// category.",
    ///  "type": "object",
    ///  "additionalProperties": false,
    ///  "x-schema-name": "DeletePackCategoryResponse"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct DeletePackCategoryResponse {}
    impl ::std::convert::From<&DeletePackCategoryResponse> for DeletePackCategoryResponse {
        fn from(value: &DeletePackCategoryResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for DeletePackCategoryResponse {
        fn default() -> Self {
            Self {}
        }
    }

    ///Detail about why this request was rejected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why this request was rejected.",
    ///  "type": "object",
    ///  "properties": {
    ///    "validationErrors": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct DeletePackCategoryResponseCodaDetail {
        #[serde(rename = "validationErrors", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub validation_errors: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&DeletePackCategoryResponseCodaDetail> for DeletePackCategoryResponseCodaDetail {
        fn from(value: &DeletePackCategoryResponseCodaDetail) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for DeletePackCategoryResponseCodaDetail {
        fn default() -> Self {
            Self {
                validation_errors: Default::default(),
            }
        }
    }

    ///Confirmation of successfully deleting a Pack maker.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Confirmation of successfully deleting a Pack maker.",
    ///  "type": "object",
    ///  "additionalProperties": false,
    ///  "x-schema-name": "AddPackMakerResponse"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct DeletePackMakerResponse {}
    impl ::std::convert::From<&DeletePackMakerResponse> for DeletePackMakerResponse {
        fn from(value: &DeletePackMakerResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for DeletePackMakerResponse {
        fn default() -> Self {
            Self {}
        }
    }

    ///Detail about why this request was rejected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why this request was rejected.",
    ///  "type": "object",
    ///  "properties": {
    ///    "validationErrors": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct DeletePackMakerResponseCodaDetail {
        #[serde(rename = "validationErrors", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub validation_errors: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&DeletePackMakerResponseCodaDetail> for DeletePackMakerResponseCodaDetail {
        fn from(value: &DeletePackMakerResponseCodaDetail) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for DeletePackMakerResponseCodaDetail {
        fn default() -> Self {
            Self {
                validation_errors: Default::default(),
            }
        }
    }

    ///Confirmation of successfully deleting a Pack permission.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Confirmation of successfully deleting a Pack
    /// permission.",
    ///  "type": "object",
    ///  "additionalProperties": false,
    ///  "x-schema-name": "DeletePackPermissionResponse"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct DeletePackPermissionResponse {}
    impl ::std::convert::From<&DeletePackPermissionResponse> for DeletePackPermissionResponse {
        fn from(value: &DeletePackPermissionResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for DeletePackPermissionResponse {
        fn default() -> Self {
            Self {}
        }
    }

    ///Detail about why this request was rejected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why this request was rejected.",
    ///  "type": "object",
    ///  "properties": {
    ///    "validationErrors": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct DeletePackPermissionResponseCodaDetail {
        #[serde(rename = "validationErrors", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub validation_errors: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&DeletePackPermissionResponseCodaDetail> for DeletePackPermissionResponseCodaDetail {
        fn from(value: &DeletePackPermissionResponseCodaDetail) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for DeletePackPermissionResponseCodaDetail {
        fn default() -> Self {
            Self {
                validation_errors: Default::default(),
            }
        }
    }

    ///Confirmation of successful Pack deletion.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Confirmation of successful Pack deletion.",
    ///  "type": "object",
    ///  "additionalProperties": false,
    ///  "x-schema-name": "DeletePackResponse"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct DeletePackResponse {}
    impl ::std::convert::From<&DeletePackResponse> for DeletePackResponse {
        fn from(value: &DeletePackResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for DeletePackResponse {
        fn default() -> Self {
            Self {}
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct DeletePageResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&DeletePageResponse> for DeletePageResponse {
        fn from(value: &DeletePageResponse) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct DeletePermissionResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&DeletePermissionResponse> for DeletePermissionResponse {
        fn from(value: &DeletePermissionResponse) -> Self {
            value.clone()
        }
    }

    ///The result of deleting a permission.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The result of deleting a permission.",
    ///  "type": "object",
    ///  "additionalProperties": false,
    ///  "x-schema-name": "DeletePermissionResult"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct DeletePermissionResult {}
    impl ::std::convert::From<&DeletePermissionResult> for DeletePermissionResult {
        fn from(value: &DeletePermissionResult) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for DeletePermissionResult {
        fn default() -> Self {
            Self {}
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        401
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct DeleteRowResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&DeleteRowResponse> for DeleteRowResponse {
        fn from(value: &DeleteRowResponse) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct DeleteRowsResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&DeleteRowsResponse> for DeleteRowsResponse {
        fn from(value: &DeleteRowsResponse) -> Self {
            value.clone()
        }
    }

    ///Metadata about a Coda doc.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Metadata about a Coda doc.",
    ///  "type": "object",
    ///  "required": [
    ///    "browserLink",
    ///    "createdAt",
    ///    "folder",
    ///    "folderId",
    ///    "href",
    ///    "id",
    ///    "name",
    ///    "owner",
    ///    "ownerName",
    ///    "type",
    ///    "updatedAt",
    ///    "workspace",
    ///    "workspaceId"
    ///  ],
    ///  "properties": {
    ///    "browserLink": {
    ///      "description": "Browser-friendly link to the Coda doc.",
    ///      "examples": [
    ///        "https://coda.io/d/_dAbCDeFGH"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "createdAt": {
    ///      "description": "Timestamp for when the doc was created.",
    ///      "examples": [
    ///        "2018-04-11T00:18:57.946Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "docSize": {
    ///      "$ref": "#/components/schemas/DocSize"
    ///    },
    ///    "folder": {
    ///      "$ref": "#/components/schemas/FolderReference"
    ///    },
    ///    "folderId": {
    ///      "description": "ID of the Coda folder containing this doc.",
    ///      "deprecated": true,
    ///      "examples": [
    ///        "fl-1Ab234"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "href": {
    ///      "description": "API link to the Coda doc.",
    ///      "examples": [
    ///        "https://coda.io/apis/v1/docs/AbCDeFGH"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "icon": {
    ///      "$ref": "#/components/schemas/Icon"
    ///    },
    ///    "id": {
    ///      "description": "ID of the Coda doc.",
    ///      "examples": [
    ///        "AbCDeFGH"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "Name of the doc.",
    ///      "examples": [
    ///        "Product Launch Hub"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "owner": {
    ///      "description": "Email address of the doc owner.",
    ///      "examples": [
    ///        "user@example.com"
    ///      ],
    ///      "type": "string",
    ///      "format": "email"
    ///    },
    ///    "ownerName": {
    ///      "description": "Name of the doc owner.",
    ///      "examples": [
    ///        "Some User"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "published": {
    ///      "$ref": "#/components/schemas/DocPublished"
    ///    },
    ///    "sourceDoc": {
    ///      "allOf": [
    ///        {
    ///          "description": "Reference to a Coda doc from which this doc was
    /// copied, if any.",
    ///          "type": "object",
    ///          "additionalProperties": false
    ///        },
    ///        {
    ///          "$ref": "#/components/schemas/DocReference"
    ///        }
    ///      ]
    ///    },
    ///    "type": {
    ///      "description": "The type of this resource.",
    ///      "type": "string",
    ///      "enum": [
    ///        "doc"
    ///      ],
    ///      "x-tsType": "Type.Doc"
    ///    },
    ///    "updatedAt": {
    ///      "description": "Timestamp for when the doc was last modified.",
    ///      "examples": [
    ///        "2018-04-11T00:18:57.946Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "workspace": {
    ///      "$ref": "#/components/schemas/WorkspaceReference"
    ///    },
    ///    "workspaceId": {
    ///      "description": "ID of the Coda workspace containing this doc.",
    ///      "deprecated": true,
    ///      "examples": [
    ///        "ws-1Ab234"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "Doc"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct Doc {
        ///Browser-friendly link to the Coda doc.
        #[serde(rename = "browserLink")]
        pub browser_link: ::std::string::String,
        ///Timestamp for when the doc was created.
        #[serde(rename = "createdAt")]
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        #[serde(rename = "docSize", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub doc_size: ::std::option::Option<DocSize>,
        pub folder: FolderReference,
        ///ID of the Coda folder containing this doc.
        #[serde(rename = "folderId")]
        pub folder_id: ::std::string::String,
        ///API link to the Coda doc.
        pub href: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub icon: ::std::option::Option<Icon>,
        ///ID of the Coda doc.
        pub id: ::std::string::String,
        ///Name of the doc.
        pub name: ::std::string::String,
        ///Email address of the doc owner.
        pub owner: ::std::string::String,
        ///Name of the doc owner.
        #[serde(rename = "ownerName")]
        pub owner_name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub published: ::std::option::Option<DocPublished>,
        #[serde(rename = "sourceDoc", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub source_doc: ::std::option::Option<DocSourceDoc>,
        ///The type of this resource.
        #[serde(rename = "type")]
        pub type_: DocType,
        ///Timestamp for when the doc was last modified.
        #[serde(rename = "updatedAt")]
        pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub workspace: WorkspaceReference,
        ///ID of the Coda workspace containing this doc.
        #[serde(rename = "workspaceId")]
        pub workspace_id: ::std::string::String,
    }

    impl ::std::convert::From<&Doc> for Doc {
        fn from(value: &Doc) -> Self {
            value.clone()
        }
    }

    ///List of analytics for Coda docs over a date range.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "List of analytics for Coda docs over a date range.",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/DocAnalyticsItem"
    ///      }
    ///    },
    ///    "nextPageLink": {
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/nextPageLink"
    ///        },
    ///        {
    ///          "examples": [
    ///            "https://coda.io/apis/v1/analytics/docs?pageToken=xyz"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      ]
    ///    },
    ///    "nextPageToken": {
    ///      "$ref": "#/components/schemas/nextPageToken"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "DocAnalyticsCollection"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct DocAnalyticsCollection {
        pub items: ::std::vec::Vec<DocAnalyticsItem>,
        #[serde(rename = "nextPageLink", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_link: ::std::option::Option<NextPageLink>,
        #[serde(rename = "nextPageToken", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_token: ::std::option::Option<NextPageToken>,
    }

    impl ::std::convert::From<&DocAnalyticsCollection> for DocAnalyticsCollection {
        fn from(value: &DocAnalyticsCollection) -> Self {
            value.clone()
        }
    }

    ///`DocAnalyticsDetails`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/DocReference"
    ///    },
    ///    {
    ///      "description": "Metadata about a doc relevant to analytics.",
    ///      "type": "object",
    ///      "required": [
    ///        "createdAt",
    ///        "title"
    ///      ],
    ///      "properties": {
    ///        "createdAt": {
    ///          "description": "Creation time of the doc.",
    ///          "examples": [
    ///            "2022-04-11T00:18:57.946Z"
    ///          ],
    ///          "type": "string",
    ///          "format": "date-time"
    ///        },
    ///        "icon": {
    ///          "$ref": "#/components/schemas/Icon"
    ///        },
    ///        "publishedAt": {
    ///          "description": "Published time of the doc.",
    ///          "examples": [
    ///            "2022-04-12T00:18:57.946Z"
    ///          ],
    ///          "type": "string",
    ///          "format": "date-time"
    ///        },
    ///        "title": {
    ///          "description": "The name of the doc.",
    ///          "examples": [
    ///            "Cool Geometry Formulas"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(deny_unknown_fields)]
    pub enum DocAnalyticsDetails {}
    impl ::std::convert::From<&Self> for DocAnalyticsDetails {
        fn from(value: &DocAnalyticsDetails) -> Self {
            value.clone()
        }
    }

    ///Analytics data for a Coda doc.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Analytics data for a Coda doc.",
    ///  "type": "object",
    ///  "required": [
    ///    "doc",
    ///    "metrics"
    ///  ],
    ///  "properties": {
    ///    "doc": {
    ///      "$ref": "#/components/schemas/DocAnalyticsDetails"
    ///    },
    ///    "metrics": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/DocAnalyticsMetrics"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "DocAnalyticsItem"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct DocAnalyticsItem {
        pub doc: DocAnalyticsDetails,
        pub metrics: ::std::vec::Vec<DocAnalyticsMetrics>,
    }

    impl ::std::convert::From<&DocAnalyticsItem> for DocAnalyticsItem {
        fn from(value: &DocAnalyticsItem) -> Self {
            value.clone()
        }
    }

    ///Analytics metrics for a Coda Doc.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Analytics metrics for a Coda Doc.",
    ///  "type": "object",
    ///  "required": [
    ///    "aiCredits",
    ///    "aiCreditsAssistant",
    ///    "aiCreditsBlock",
    ///    "aiCreditsChat",
    ///    "aiCreditsColumn",
    ///    "aiCreditsReviewer",
    ///    "copies",
    ///    "date",
    ///    "likes",
    ///    "sessionsDesktop",
    ///    "sessionsMobile",
    ///    "sessionsOther",
    ///    "totalSessions",
    ///    "views"
    ///  ],
    ///  "properties": {
    ///    "aiCredits": {
    ///      "description": "Total number of AI credits used.",
    ///      "examples": [
    ///        50
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "aiCreditsAssistant": {
    ///      "description": "Number of credits used for AI assistant.",
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "aiCreditsBlock": {
    ///      "description": "Number of credits used for AI block.",
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "aiCreditsChat": {
    ///      "description": "Number of credits used for AI chat.",
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "aiCreditsColumn": {
    ///      "description": "Number of credits used for AI column.",
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "aiCreditsReviewer": {
    ///      "description": "Number of credits used for AI reviewer.",
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "copies": {
    ///      "description": "Number of times the doc was copied.",
    ///      "examples": [
    ///        24
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "date": {
    ///      "description": "Date of the analytics data.",
    ///      "examples": [
    ///        "2020-09-02"
    ///      ],
    ///      "type": "string",
    ///      "format": "date"
    ///    },
    ///    "likes": {
    ///      "description": "Number of times the doc was liked.",
    ///      "examples": [
    ///        342
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "sessionsDesktop": {
    ///      "description": "Number of unique visitors to this doc from a
    /// desktop device.",
    ///      "examples": [
    ///        212
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "sessionsMobile": {
    ///      "description": "Number of unique visitors to this doc from a mobile
    /// device.",
    ///      "examples": [
    ///        530
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "sessionsOther": {
    ///      "description": "Number of unique visitors to this doc from an
    /// unknown device type.",
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "totalSessions": {
    ///      "description": "Sum of the total sessions from any device.",
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "views": {
    ///      "description": "Number of times the doc was viewed.",
    ///      "examples": [
    ///        980
    ///      ],
    ///      "type": "integer"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "DocAnalyticsMetrics"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct DocAnalyticsMetrics {
        ///Total number of AI credits used.
        #[serde(rename = "aiCredits")]
        pub ai_credits: i64,
        ///Number of credits used for AI assistant.
        #[serde(rename = "aiCreditsAssistant")]
        pub ai_credits_assistant: i64,
        ///Number of credits used for AI block.
        #[serde(rename = "aiCreditsBlock")]
        pub ai_credits_block: i64,
        ///Number of credits used for AI chat.
        #[serde(rename = "aiCreditsChat")]
        pub ai_credits_chat: i64,
        ///Number of credits used for AI column.
        #[serde(rename = "aiCreditsColumn")]
        pub ai_credits_column: i64,
        ///Number of credits used for AI reviewer.
        #[serde(rename = "aiCreditsReviewer")]
        pub ai_credits_reviewer: i64,
        ///Number of times the doc was copied.
        pub copies: i64,
        ///Date of the analytics data.
        pub date: ::chrono::naive::NaiveDate,
        ///Number of times the doc was liked.
        pub likes: i64,
        ///Number of unique visitors to this doc from a desktop device.
        #[serde(rename = "sessionsDesktop")]
        pub sessions_desktop: i64,
        ///Number of unique visitors to this doc from a mobile device.
        #[serde(rename = "sessionsMobile")]
        pub sessions_mobile: i64,
        ///Number of unique visitors to this doc from an unknown device type.
        #[serde(rename = "sessionsOther")]
        pub sessions_other: i64,
        ///Sum of the total sessions from any device.
        #[serde(rename = "totalSessions")]
        pub total_sessions: i64,
        ///Number of times the doc was viewed.
        pub views: i64,
    }

    impl ::std::convert::From<&DocAnalyticsMetrics> for DocAnalyticsMetrics {
        fn from(value: &DocAnalyticsMetrics) -> Self {
            value.clone()
        }
    }

    ///Determines how the Doc analytics returned are sorted.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Determines how the Doc analytics returned are sorted.",
    ///  "type": "string",
    ///  "enum": [
    ///    "date",
    ///    "docId",
    ///    "title",
    ///    "createdAt",
    ///    "publishedAt",
    ///    "likes",
    ///    "copies",
    ///    "views",
    ///    "sessionsDesktop",
    ///    "sessionsMobile",
    ///    "sessionsOther",
    ///    "totalSessions",
    ///    "aiCreditsChat",
    ///    "aiCreditsBlock",
    ///    "aiCreditsColumn",
    ///    "aiCreditsAssistant",
    ///    "aiCreditsReviewer",
    ///    "aiCredits"
    ///  ],
    ///  "x-schema-name": "DocAnalyticsOrderBy",
    ///  "x-tsEnumNames": [
    ///    "AnalyticsDate",
    ///    "DocId",
    ///    "Title",
    ///    "CreatedAt",
    ///    "PublishedAt",
    ///    "Likes",
    ///    "Copies",
    ///    "Views",
    ///    "SessionsDesktop",
    ///    "SessionsMobile",
    ///    "SessionsOther",
    ///    "TotalSessions",
    ///    "AiCreditsChat",
    ///    "AiCreditsBlock",
    ///    "AiCreditsColumn",
    ///    "AiCreditsAssistant",
    ///    "AiCreditsReviewer",
    ///    "AiCredits"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum DocAnalyticsOrderBy {
        #[serde(rename = "date")]
        Date,
        #[serde(rename = "docId")]
        DocId,
        #[serde(rename = "title")]
        Title,
        #[serde(rename = "createdAt")]
        CreatedAt,
        #[serde(rename = "publishedAt")]
        PublishedAt,
        #[serde(rename = "likes")]
        Likes,
        #[serde(rename = "copies")]
        Copies,
        #[serde(rename = "views")]
        Views,
        #[serde(rename = "sessionsDesktop")]
        SessionsDesktop,
        #[serde(rename = "sessionsMobile")]
        SessionsMobile,
        #[serde(rename = "sessionsOther")]
        SessionsOther,
        #[serde(rename = "totalSessions")]
        TotalSessions,
        #[serde(rename = "aiCreditsChat")]
        AiCreditsChat,
        #[serde(rename = "aiCreditsBlock")]
        AiCreditsBlock,
        #[serde(rename = "aiCreditsColumn")]
        AiCreditsColumn,
        #[serde(rename = "aiCreditsAssistant")]
        AiCreditsAssistant,
        #[serde(rename = "aiCreditsReviewer")]
        AiCreditsReviewer,
        #[serde(rename = "aiCredits")]
        AiCredits,
    }

    impl ::std::convert::From<&Self> for DocAnalyticsOrderBy {
        fn from(value: &DocAnalyticsOrderBy) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for DocAnalyticsOrderBy {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Date => f.write_str("date"),
                Self::DocId => f.write_str("docId"),
                Self::Title => f.write_str("title"),
                Self::CreatedAt => f.write_str("createdAt"),
                Self::PublishedAt => f.write_str("publishedAt"),
                Self::Likes => f.write_str("likes"),
                Self::Copies => f.write_str("copies"),
                Self::Views => f.write_str("views"),
                Self::SessionsDesktop => f.write_str("sessionsDesktop"),
                Self::SessionsMobile => f.write_str("sessionsMobile"),
                Self::SessionsOther => f.write_str("sessionsOther"),
                Self::TotalSessions => f.write_str("totalSessions"),
                Self::AiCreditsChat => f.write_str("aiCreditsChat"),
                Self::AiCreditsBlock => f.write_str("aiCreditsBlock"),
                Self::AiCreditsColumn => f.write_str("aiCreditsColumn"),
                Self::AiCreditsAssistant => f.write_str("aiCreditsAssistant"),
                Self::AiCreditsReviewer => f.write_str("aiCreditsReviewer"),
                Self::AiCredits => f.write_str("aiCredits"),
            }
        }
    }

    impl ::std::str::FromStr for DocAnalyticsOrderBy {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "date" => Ok(Self::Date),
                "docId" => Ok(Self::DocId),
                "title" => Ok(Self::Title),
                "createdAt" => Ok(Self::CreatedAt),
                "publishedAt" => Ok(Self::PublishedAt),
                "likes" => Ok(Self::Likes),
                "copies" => Ok(Self::Copies),
                "views" => Ok(Self::Views),
                "sessionsDesktop" => Ok(Self::SessionsDesktop),
                "sessionsMobile" => Ok(Self::SessionsMobile),
                "sessionsOther" => Ok(Self::SessionsOther),
                "totalSessions" => Ok(Self::TotalSessions),
                "aiCreditsChat" => Ok(Self::AiCreditsChat),
                "aiCreditsBlock" => Ok(Self::AiCreditsBlock),
                "aiCreditsColumn" => Ok(Self::AiCreditsColumn),
                "aiCreditsAssistant" => Ok(Self::AiCreditsAssistant),
                "aiCreditsReviewer" => Ok(Self::AiCreditsReviewer),
                "aiCredits" => Ok(Self::AiCredits),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for DocAnalyticsOrderBy {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for DocAnalyticsOrderBy {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for DocAnalyticsOrderBy {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Summarized metrics for Coda docs.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Summarized metrics for Coda docs.",
    ///  "type": "object",
    ///  "required": [
    ///    "totalSessions"
    ///  ],
    ///  "properties": {
    ///    "totalSessions": {
    ///      "description": "Total number of sessions across all docs.",
    ///      "examples": [
    ///        1337
    ///      ],
    ///      "type": "integer"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "DocAnalyticsSummary"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct DocAnalyticsSummary {
        ///Total number of sessions across all docs.
        #[serde(rename = "totalSessions")]
        pub total_sessions: i64,
    }

    impl ::std::convert::From<&DocAnalyticsSummary> for DocAnalyticsSummary {
        fn from(value: &DocAnalyticsSummary) -> Self {
            value.clone()
        }
    }

    ///The category applied to a doc.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The category applied to a doc.",
    ///  "type": "object",
    ///  "required": [
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "name": {
    ///      "description": "Name of the category.",
    ///      "examples": [
    ///        "Project Management"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "DocCategory"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct DocCategory {
        ///Name of the category.
        pub name: ::std::string::String,
    }

    impl ::std::convert::From<&DocCategory> for DocCategory {
        fn from(value: &DocCategory) -> Self {
            value.clone()
        }
    }

    ///A list of categories that can be applied to a doc.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A list of categories that can be applied to a doc.",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "Categories for the doc.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/DocCategory"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "DocCategoryList"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct DocCategoryList {
        ///Categories for the doc.
        pub items: ::std::vec::Vec<DocCategory>,
    }

    impl ::std::convert::From<&DocCategoryList> for DocCategoryList {
        fn from(value: &DocCategoryList) -> Self {
            value.clone()
        }
    }

    ///Payload for creating a new doc.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Payload for creating a new doc.",
    ///  "type": "object",
    ///  "properties": {
    ///    "folderId": {
    ///      "description": "The ID of the folder within which to create this
    /// doc. Defaults to your \"My docs\" folder in the oldest workspace you
    /// joined; this is subject to change. You can get this ID by opening the
    /// folder in the docs list on your computer and grabbing the `folderId`
    /// query parameter.\n",
    ///      "examples": [
    ///        "fl-ABcdEFgHJi"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "initialPage": {
    ///      "allOf": [
    ///        {
    ///          "description": "The contents of the initial page of the doc.",
    ///          "type": "object",
    ///          "additionalProperties": false
    ///        },
    ///        {
    ///          "$ref": "#/components/schemas/PageCreate"
    ///        }
    ///      ]
    ///    },
    ///    "sourceDoc": {
    ///      "description": "An optional doc ID from which to create a copy.",
    ///      "examples": [
    ///        "iJKlm_noPq"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "timezone": {
    ///      "description": "The timezone to use for the newly created doc.",
    ///      "examples": [
    ///        "America/Los_Angeles"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "title": {
    ///      "description": "Title of the new doc. Defaults to 'Untitled'.",
    ///      "examples": [
    ///        "Project Tracker"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "DocCreate"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct DocCreate {
        ///The ID of the folder within which to create this doc. Defaults to
        /// your "My docs" folder in the oldest workspace you joined; this is
        /// subject to change. You can get this ID by opening the folder in the
        /// docs list on your computer and grabbing the `folderId` query
        /// parameter.
        #[serde(rename = "folderId", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub folder_id: ::std::option::Option<::std::string::String>,
        #[serde(rename = "initialPage", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub initial_page: ::std::option::Option<DocCreateInitialPage>,
        ///An optional doc ID from which to create a copy.
        #[serde(rename = "sourceDoc", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub source_doc: ::std::option::Option<::std::string::String>,
        ///The timezone to use for the newly created doc.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub timezone: ::std::option::Option<::std::string::String>,
        ///Title of the new doc. Defaults to 'Untitled'.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub title: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&DocCreate> for DocCreate {
        fn from(value: &DocCreate) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for DocCreate {
        fn default() -> Self {
            Self {
                folder_id: Default::default(),
                initial_page: Default::default(),
                source_doc: Default::default(),
                timezone: Default::default(),
                title: Default::default(),
            }
        }
    }

    ///`DocCreateInitialPage`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "description": "The contents of the initial page of the doc.",
    ///      "type": "object",
    ///      "additionalProperties": false
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PageCreate"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct DocCreateInitialPage {}
    impl ::std::convert::From<&DocCreateInitialPage> for DocCreateInitialPage {
        fn from(value: &DocCreateInitialPage) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for DocCreateInitialPage {
        fn default() -> Self {
            Self {}
        }
    }

    ///The result of a doc deletion.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The result of a doc deletion.",
    ///  "type": "object",
    ///  "additionalProperties": false,
    ///  "x-schema-name": "DocDelete"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct DocDelete {}
    impl ::std::convert::From<&DocDelete> for DocDelete {
        fn from(value: &DocDelete) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for DocDelete {
        fn default() -> Self {
            Self {}
        }
    }

    ///List of Coda docs.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "List of Coda docs.",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "href": {
    ///      "description": "API link to these results",
    ///      "examples": [
    ///        "https://coda.io/apis/v1/docs?limit=20"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Doc"
    ///      }
    ///    },
    ///    "nextPageLink": {
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/nextPageLink"
    ///        },
    ///        {
    ///          "examples": [
    ///            "https://coda.io/apis/v1/docs?pageToken=eyJsaW1pd"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      ]
    ///    },
    ///    "nextPageToken": {
    ///      "$ref": "#/components/schemas/nextPageToken"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "DocList"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct DocList {
        ///API link to these results
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub href: ::std::option::Option<::std::string::String>,
        pub items: ::std::vec::Vec<Doc>,
        #[serde(rename = "nextPageLink", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_link: ::std::option::Option<NextPageLink>,
        #[serde(rename = "nextPageToken", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_token: ::std::option::Option<NextPageToken>,
    }

    impl ::std::convert::From<&DocList> for DocList {
        fn from(value: &DocList) -> Self {
            value.clone()
        }
    }

    ///Payload for publishing a doc or or updating its publishing information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Payload for publishing a doc or or updating its
    /// publishing information.",
    ///  "type": "object",
    ///  "properties": {
    ///    "categoryNames": {
    ///      "description": "The names of categories to apply to the document.",
    ///      "examples": [
    ///        [
    ///          "Project management"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "discoverable": {
    ///      "description": "If true, indicates that the doc is discoverable.",
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "earnCredit": {
    ///      "description": "If true, new users may be required to sign in to
    /// view content within this document. You will receive Coda credit for each
    /// user who signs up via your doc.\n",
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "mode": {
    ///      "$ref": "#/components/schemas/DocPublishMode"
    ///    },
    ///    "slug": {
    ///      "description": "Slug for the published doc.",
    ///      "examples": [
    ///        "my-doc"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "DocPublish"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct DocPublish {
        ///The names of categories to apply to the document.
        #[serde(rename = "categoryNames", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub category_names: ::std::vec::Vec<::std::string::String>,
        ///If true, indicates that the doc is discoverable.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub discoverable: ::std::option::Option<bool>,
        ///If true, new users may be required to sign in to view content within
        /// this document. You will receive Coda credit for each user who signs
        /// up via your doc.
        #[serde(rename = "earnCredit", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub earn_credit: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mode: ::std::option::Option<DocPublishMode>,
        ///Slug for the published doc.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub slug: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&DocPublish> for DocPublish {
        fn from(value: &DocPublish) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for DocPublish {
        fn default() -> Self {
            Self {
                category_names: Default::default(),
                discoverable: Default::default(),
                earn_credit: Default::default(),
                mode: Default::default(),
                slug: Default::default(),
            }
        }
    }

    ///Which interaction mode the published doc should use.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Which interaction mode the published doc should use.",
    ///  "type": "string",
    ///  "enum": [
    ///    "view",
    ///    "play",
    ///    "edit"
    ///  ],
    ///  "x-schema-name": "DocPublishMode",
    ///  "x-tsEnumNames": [
    ///    "View",
    ///    "Play",
    ///    "Edit"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum DocPublishMode {
        #[serde(rename = "view")]
        View,
        #[serde(rename = "play")]
        Play,
        #[serde(rename = "edit")]
        Edit,
    }

    impl ::std::convert::From<&Self> for DocPublishMode {
        fn from(value: &DocPublishMode) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for DocPublishMode {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::View => f.write_str("view"),
                Self::Play => f.write_str("play"),
                Self::Edit => f.write_str("edit"),
            }
        }
    }

    impl ::std::str::FromStr for DocPublishMode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "view" => Ok(Self::View),
                "play" => Ok(Self::Play),
                "edit" => Ok(Self::Edit),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for DocPublishMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for DocPublishMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for DocPublishMode {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Information about the publishing state of the document.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Information about the publishing state of the
    /// document.",
    ///  "type": "object",
    ///  "required": [
    ///    "browserLink",
    ///    "categories",
    ///    "discoverable",
    ///    "earnCredit",
    ///    "mode"
    ///  ],
    ///  "properties": {
    ///    "browserLink": {
    ///      "description": "URL to the published doc.",
    ///      "examples": [
    ///        "https://coda.io/@coda/hello-world"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "categories": {
    ///      "description": "Categories applied to the doc.",
    ///      "examples": [
    ///        [
    ///          "Project Management"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/DocCategory"
    ///      }
    ///    },
    ///    "description": {
    ///      "description": "Description of the published doc.",
    ///      "examples": [
    ///        "Hello World!"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "discoverable": {
    ///      "description": "If true, indicates that the doc is discoverable.",
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "earnCredit": {
    ///      "description": "If true, new users may be required to sign in to
    /// view content within this document. You will receive Coda credit for each
    /// user who signs up via your doc.\n",
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "imageLink": {
    ///      "description": "URL to the cover image for the published doc.",
    ///      "type": "string"
    ///    },
    ///    "mode": {
    ///      "$ref": "#/components/schemas/DocPublishMode"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "DocPublished"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct DocPublished {
        ///URL to the published doc.
        #[serde(rename = "browserLink")]
        pub browser_link: ::std::string::String,
        ///Categories applied to the doc.
        pub categories: ::std::vec::Vec<DocCategory>,
        ///Description of the published doc.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        ///If true, indicates that the doc is discoverable.
        pub discoverable: bool,
        ///If true, new users may be required to sign in to view content within
        /// this document. You will receive Coda credit for each user who signs
        /// up via your doc.
        #[serde(rename = "earnCredit")]
        pub earn_credit: bool,
        ///URL to the cover image for the published doc.
        #[serde(rename = "imageLink", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub image_link: ::std::option::Option<::std::string::String>,
        pub mode: DocPublishMode,
    }

    impl ::std::convert::From<&DocPublished> for DocPublished {
        fn from(value: &DocPublished) -> Self {
            value.clone()
        }
    }

    ///Reference to a Coda doc.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Reference to a Coda doc.",
    ///  "type": "object",
    ///  "required": [
    ///    "browserLink",
    ///    "href",
    ///    "id",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "browserLink": {
    ///      "description": "Browser-friendly link to the Coda doc.",
    ///      "examples": [
    ///        "https://coda.io/d/_dAbCDeFGH"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "href": {
    ///      "description": "API link to the Coda doc.",
    ///      "examples": [
    ///        "https://coda.io/apis/v1/docs/AbCDeFGH"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "id": {
    ///      "description": "ID of the Coda doc.",
    ///      "examples": [
    ///        "AbCDeFGH"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "description": "The type of this resource.",
    ///      "type": "string",
    ///      "enum": [
    ///        "doc"
    ///      ],
    ///      "x-tsType": "Type.Doc"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "DocReference"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct DocReference {
        ///Browser-friendly link to the Coda doc.
        #[serde(rename = "browserLink")]
        pub browser_link: ::std::string::String,
        ///API link to the Coda doc.
        pub href: ::std::string::String,
        ///ID of the Coda doc.
        pub id: ::std::string::String,
        ///The type of this resource.
        #[serde(rename = "type")]
        pub type_: DocReferenceType,
    }

    impl ::std::convert::From<&DocReference> for DocReference {
        fn from(value: &DocReference) -> Self {
            value.clone()
        }
    }

    ///The type of this resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of this resource.",
    ///  "type": "string",
    ///  "enum": [
    ///    "doc"
    ///  ],
    ///  "x-tsType": "Type.Doc"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum DocReferenceType {
        #[serde(rename = "doc")]
        Doc,
    }

    impl ::std::convert::From<&Self> for DocReferenceType {
        fn from(value: &DocReferenceType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for DocReferenceType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Doc => f.write_str("doc"),
            }
        }
    }

    impl ::std::str::FromStr for DocReferenceType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "doc" => Ok(Self::Doc),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for DocReferenceType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for DocReferenceType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for DocReferenceType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The number of components within a Coda doc.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The number of components within a Coda doc.",
    ///  "type": "object",
    ///  "required": [
    ///    "overApiSizeLimit",
    ///    "pageCount",
    ///    "tableAndViewCount",
    ///    "totalRowCount"
    ///  ],
    ///  "properties": {
    ///    "overApiSizeLimit": {
    ///      "description": "If true, indicates that the doc is over the API
    /// size limit.",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "pageCount": {
    ///      "description": "The total number of page contained within the
    /// doc.",
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "tableAndViewCount": {
    ///      "description": "The total number of tables and views contained
    /// within the doc.",
    ///      "examples": [
    ///        42
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "totalRowCount": {
    ///      "description": "The number of rows contained within all tables of
    /// the doc.",
    ///      "examples": [
    ///        31337
    ///      ],
    ///      "type": "number"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "DocSize"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct DocSize {
        ///If true, indicates that the doc is over the API size limit.
        #[serde(rename = "overApiSizeLimit")]
        pub over_api_size_limit: bool,
        #[serde(rename = "pageCount")]
        pub page_count: f64,
        #[serde(rename = "tableAndViewCount")]
        pub table_and_view_count: f64,
        #[serde(rename = "totalRowCount")]
        pub total_row_count: f64,
    }

    impl ::std::convert::From<&DocSize> for DocSize {
        fn from(value: &DocSize) -> Self {
            value.clone()
        }
    }

    ///`DocSourceDoc`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "description": "Reference to a Coda doc from which this doc was
    /// copied, if any.",
    ///      "type": "object",
    ///      "additionalProperties": false
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/DocReference"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(deny_unknown_fields)]
    pub enum DocSourceDoc {}
    impl ::std::convert::From<&Self> for DocSourceDoc {
        fn from(value: &DocSourceDoc) -> Self {
            value.clone()
        }
    }

    ///The type of this resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of this resource.",
    ///  "type": "string",
    ///  "enum": [
    ///    "doc"
    ///  ],
    ///  "x-tsType": "Type.Doc"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum DocType {
        #[serde(rename = "doc")]
        Doc,
    }

    impl ::std::convert::From<&Self> for DocType {
        fn from(value: &DocType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for DocType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Doc => f.write_str("doc"),
            }
        }
    }

    impl ::std::str::FromStr for DocType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "doc" => Ok(Self::Doc),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for DocType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for DocType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for DocType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Payload for updating a doc.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Payload for updating a doc.",
    ///  "type": "object",
    ///  "properties": {
    ///    "iconName": {
    ///      "description": "Name of the icon.",
    ///      "examples": [
    ///        "rocket"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "title": {
    ///      "description": "Title of the doc.",
    ///      "examples": [
    ///        "Project Tracker"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "DocUpdate"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct DocUpdate {
        ///Name of the icon.
        #[serde(rename = "iconName", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub icon_name: ::std::option::Option<::std::string::String>,
        ///Title of the doc.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub title: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&DocUpdate> for DocUpdate {
        fn from(value: &DocUpdate) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for DocUpdate {
        fn default() -> Self {
            Self {
                icon_name: Default::default(),
                title: Default::default(),
            }
        }
    }

    ///The result of a doc update
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The result of a doc update",
    ///  "type": "object",
    ///  "additionalProperties": false,
    ///  "x-schema-name": "DocUpdate"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct DocUpdateResult {}
    impl ::std::convert::From<&DocUpdateResult> for DocUpdateResult {
        fn from(value: &DocUpdateResult) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for DocUpdateResult {
        fn default() -> Self {
            Self {}
        }
    }

    ///The result of a doc creation.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The result of a doc creation.",
    ///  "type": "object",
    ///  "required": [
    ///    "browserLink",
    ///    "createdAt",
    ///    "folder",
    ///    "folderId",
    ///    "href",
    ///    "id",
    ///    "name",
    ///    "owner",
    ///    "ownerName",
    ///    "type",
    ///    "updatedAt",
    ///    "workspace",
    ///    "workspaceId"
    ///  ],
    ///  "properties": {
    ///    "browserLink": {
    ///      "description": "Browser-friendly link to the Coda doc.",
    ///      "examples": [
    ///        "https://coda.io/d/_dAbCDeFGH"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "createdAt": {
    ///      "description": "Timestamp for when the doc was created.",
    ///      "examples": [
    ///        "2018-04-11T00:18:57.946Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "docSize": {
    ///      "$ref": "#/components/schemas/DocSize"
    ///    },
    ///    "folder": {
    ///      "$ref": "#/components/schemas/FolderReference"
    ///    },
    ///    "folderId": {
    ///      "description": "ID of the Coda folder containing this doc.",
    ///      "deprecated": true,
    ///      "examples": [
    ///        "fl-1Ab234"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "href": {
    ///      "description": "API link to the Coda doc.",
    ///      "examples": [
    ///        "https://coda.io/apis/v1/docs/AbCDeFGH"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "icon": {
    ///      "$ref": "#/components/schemas/Icon"
    ///    },
    ///    "id": {
    ///      "description": "ID of the Coda doc.",
    ///      "examples": [
    ///        "AbCDeFGH"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "Name of the doc.",
    ///      "examples": [
    ///        "Product Launch Hub"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "owner": {
    ///      "description": "Email address of the doc owner.",
    ///      "examples": [
    ///        "user@example.com"
    ///      ],
    ///      "type": "string",
    ///      "format": "email"
    ///    },
    ///    "ownerName": {
    ///      "description": "Name of the doc owner.",
    ///      "examples": [
    ///        "Some User"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "published": {
    ///      "$ref": "#/components/schemas/DocPublished"
    ///    },
    ///    "requestId": {
    ///      "description": "An arbitrary unique identifier for this request.",
    ///      "examples": [
    ///        "abc-123-def-456"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "sourceDoc": {
    ///      "allOf": [
    ///        {
    ///          "description": "Reference to a Coda doc from which this doc was
    /// copied, if any.",
    ///          "type": "object",
    ///          "additionalProperties": false
    ///        },
    ///        {
    ///          "$ref": "#/components/schemas/DocReference"
    ///        }
    ///      ]
    ///    },
    ///    "type": {
    ///      "description": "The type of this resource.",
    ///      "type": "string",
    ///      "enum": [
    ///        "doc"
    ///      ],
    ///      "x-tsType": "Type.Doc"
    ///    },
    ///    "updatedAt": {
    ///      "description": "Timestamp for when the doc was last modified.",
    ///      "examples": [
    ///        "2018-04-11T00:18:57.946Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "workspace": {
    ///      "$ref": "#/components/schemas/WorkspaceReference"
    ///    },
    ///    "workspaceId": {
    ///      "description": "ID of the Coda workspace containing this doc.",
    ///      "deprecated": true,
    ///      "examples": [
    ///        "ws-1Ab234"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "Doc"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct DocumentCreationResult {
        ///Browser-friendly link to the Coda doc.
        #[serde(rename = "browserLink")]
        pub browser_link: ::std::string::String,
        ///Timestamp for when the doc was created.
        #[serde(rename = "createdAt")]
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        #[serde(rename = "docSize", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub doc_size: ::std::option::Option<DocSize>,
        pub folder: FolderReference,
        ///ID of the Coda folder containing this doc.
        #[serde(rename = "folderId")]
        pub folder_id: ::std::string::String,
        ///API link to the Coda doc.
        pub href: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub icon: ::std::option::Option<Icon>,
        ///ID of the Coda doc.
        pub id: ::std::string::String,
        ///Name of the doc.
        pub name: ::std::string::String,
        ///Email address of the doc owner.
        pub owner: ::std::string::String,
        ///Name of the doc owner.
        #[serde(rename = "ownerName")]
        pub owner_name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub published: ::std::option::Option<DocPublished>,
        ///An arbitrary unique identifier for this request.
        #[serde(rename = "requestId", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub request_id: ::std::option::Option<::std::string::String>,
        #[serde(rename = "sourceDoc", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub source_doc: ::std::option::Option<DocumentCreationResultSourceDoc>,
        ///The type of this resource.
        #[serde(rename = "type")]
        pub type_: DocumentCreationResultType,
        ///Timestamp for when the doc was last modified.
        #[serde(rename = "updatedAt")]
        pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub workspace: WorkspaceReference,
        ///ID of the Coda workspace containing this doc.
        #[serde(rename = "workspaceId")]
        pub workspace_id: ::std::string::String,
    }

    impl ::std::convert::From<&DocumentCreationResult> for DocumentCreationResult {
        fn from(value: &DocumentCreationResult) -> Self {
            value.clone()
        }
    }

    ///`DocumentCreationResultSourceDoc`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "description": "Reference to a Coda doc from which this doc was
    /// copied, if any.",
    ///      "type": "object",
    ///      "additionalProperties": false
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/DocReference"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(deny_unknown_fields)]
    pub enum DocumentCreationResultSourceDoc {}
    impl ::std::convert::From<&Self> for DocumentCreationResultSourceDoc {
        fn from(value: &DocumentCreationResultSourceDoc) -> Self {
            value.clone()
        }
    }

    ///The type of this resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of this resource.",
    ///  "type": "string",
    ///  "enum": [
    ///    "doc"
    ///  ],
    ///  "x-tsType": "Type.Doc"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum DocumentCreationResultType {
        #[serde(rename = "doc")]
        Doc,
    }

    impl ::std::convert::From<&Self> for DocumentCreationResultType {
        fn from(value: &DocumentCreationResultType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for DocumentCreationResultType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Doc => f.write_str("doc"),
            }
        }
    }

    impl ::std::str::FromStr for DocumentCreationResultType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "doc" => Ok(Self::Doc),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for DocumentCreationResultType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for DocumentCreationResultType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for DocumentCreationResultType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Base response type for an operation that mutates a document.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Base response type for an operation that mutates a
    /// document.",
    ///  "type": "object",
    ///  "required": [
    ///    "requestId"
    ///  ],
    ///  "properties": {
    ///    "requestId": {
    ///      "description": "An arbitrary unique identifier for this request.",
    ///      "examples": [
    ///        "abc-123-def-456"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "DocumentMutateResponse"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct DocumentMutateResponse {
        ///An arbitrary unique identifier for this request.
        #[serde(rename = "requestId")]
        pub request_id: ::std::string::String,
    }

    impl ::std::convert::From<&DocumentMutateResponse> for DocumentMutateResponse {
        fn from(value: &DocumentMutateResponse) -> Self {
            value.clone()
        }
    }

    ///`DomainPrincipal`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "domain",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "domain": {
    ///      "description": "Domain for the principal.",
    ///      "examples": [
    ///        "domain.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "description": "The type of this principal.",
    ///      "type": "string",
    ///      "enum": [
    ///        "domain"
    ///      ],
    ///      "x-tsType": "PrincipalType.Domain"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct DomainPrincipal {
        ///Domain for the principal.
        pub domain: ::std::string::String,
        ///The type of this principal.
        #[serde(rename = "type")]
        pub type_: DomainPrincipalType,
    }

    impl ::std::convert::From<&DomainPrincipal> for DomainPrincipal {
        fn from(value: &DomainPrincipal) -> Self {
            value.clone()
        }
    }

    ///The type of this principal.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of this principal.",
    ///  "type": "string",
    ///  "enum": [
    ///    "domain"
    ///  ],
    ///  "x-tsType": "PrincipalType.Domain"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum DomainPrincipalType {
        #[serde(rename = "domain")]
        Domain,
    }

    impl ::std::convert::From<&Self> for DomainPrincipalType {
        fn from(value: &DomainPrincipalType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for DomainPrincipalType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Domain => f.write_str("domain"),
            }
        }
    }

    impl ::std::str::FromStr for DomainPrincipalType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "domain" => Ok(Self::Domain),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for DomainPrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for DomainPrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for DomainPrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`DurationColumnFormat`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Format of a duration column.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/SimpleColumnFormat"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "maxUnit": {
    ///          "allOf": [
    ///            {
    ///              "description": "The maximum unit of precision, e.g.
    /// \"hours\" if this duration need not include minutes.",
    ///              "additionalProperties": false
    ///            },
    ///            {
    ///              "$ref": "#/components/schemas/DurationUnit"
    ///            }
    ///          ]
    ///        },
    ///        "precision": {
    ///          "examples": [
    ///            2
    ///          ],
    ///          "type": "integer"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  ],
    ///  "x-schema-name": "DurationColumnFormat"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(deny_unknown_fields)]
    pub enum DurationColumnFormat {}
    impl ::std::convert::From<&Self> for DurationColumnFormat {
        fn from(value: &DurationColumnFormat) -> Self {
            value.clone()
        }
    }

    ///A time unit used as part of a duration value.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A time unit used as part of a duration value.",
    ///  "type": "string",
    ///  "enum": [
    ///    "days",
    ///    "hours",
    ///    "minutes",
    ///    "seconds"
    ///  ],
    ///  "x-schema-name": "DurationUnit",
    ///  "x-tsEnumNames": [
    ///    "Days",
    ///    "Hours",
    ///    "Minutes",
    ///    "Seconds"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum DurationUnit {
        #[serde(rename = "days")]
        Days,
        #[serde(rename = "hours")]
        Hours,
        #[serde(rename = "minutes")]
        Minutes,
        #[serde(rename = "seconds")]
        Seconds,
    }

    impl ::std::convert::From<&Self> for DurationUnit {
        fn from(value: &DurationUnit) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for DurationUnit {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Days => f.write_str("days"),
                Self::Hours => f.write_str("hours"),
                Self::Minutes => f.write_str("minutes"),
                Self::Seconds => f.write_str("seconds"),
            }
        }
    }

    impl ::std::str::FromStr for DurationUnit {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "days" => Ok(Self::Days),
                "hours" => Ok(Self::Hours),
                "minutes" => Ok(Self::Minutes),
                "seconds" => Ok(Self::Seconds),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for DurationUnit {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for DurationUnit {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for DurationUnit {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`EmailColumnFormat`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Format of an email column.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/SimpleColumnFormat"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "autocomplete": {
    ///          "type": "boolean"
    ///        },
    ///        "display": {
    ///          "$ref": "#/components/schemas/EmailDisplayType"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  ],
    ///  "x-schema-name": "EmailColumnFormat"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(deny_unknown_fields)]
    pub enum EmailColumnFormat {}
    impl ::std::convert::From<&Self> for EmailColumnFormat {
        fn from(value: &EmailColumnFormat) -> Self {
            value.clone()
        }
    }

    ///How an email address should be displayed in the user interface.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "How an email address should be displayed in the user
    /// interface.",
    ///  "type": "string",
    ///  "enum": [
    ///    "iconAndEmail",
    ///    "iconOnly",
    ///    "emailOnly"
    ///  ],
    ///  "x-schema-name": "EmailDisplayType",
    ///  "x-tsEnumNames": [
    ///    "IconAndEmail",
    ///    "IconOnly",
    ///    "EmailOnly"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum EmailDisplayType {
        #[serde(rename = "iconAndEmail")]
        IconAndEmail,
        #[serde(rename = "iconOnly")]
        IconOnly,
        #[serde(rename = "emailOnly")]
        EmailOnly,
    }

    impl ::std::convert::From<&Self> for EmailDisplayType {
        fn from(value: &EmailDisplayType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EmailDisplayType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::IconAndEmail => f.write_str("iconAndEmail"),
                Self::IconOnly => f.write_str("iconOnly"),
                Self::EmailOnly => f.write_str("emailOnly"),
            }
        }
    }

    impl ::std::str::FromStr for EmailDisplayType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "iconAndEmail" => Ok(Self::IconAndEmail),
                "iconOnly" => Ok(Self::IconOnly),
                "emailOnly" => Ok(Self::EmailOnly),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for EmailDisplayType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EmailDisplayType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EmailDisplayType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`EmailPrincipal`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "email",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "email": {
    ///      "description": "Email for the principal.",
    ///      "examples": [
    ///        "example@domain.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "description": "The type of this principal.",
    ///      "type": "string",
    ///      "enum": [
    ///        "email"
    ///      ],
    ///      "x-tsType": "PrincipalType.Email"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct EmailPrincipal {
        ///Email for the principal.
        pub email: ::std::string::String,
        ///The type of this principal.
        #[serde(rename = "type")]
        pub type_: EmailPrincipalType,
    }

    impl ::std::convert::From<&EmailPrincipal> for EmailPrincipal {
        fn from(value: &EmailPrincipal) -> Self {
            value.clone()
        }
    }

    ///The type of this principal.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of this principal.",
    ///  "type": "string",
    ///  "enum": [
    ///    "email"
    ///  ],
    ///  "x-tsType": "PrincipalType.Email"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum EmailPrincipalType {
        #[serde(rename = "email")]
        Email,
    }

    impl ::std::convert::From<&Self> for EmailPrincipalType {
        fn from(value: &EmailPrincipalType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EmailPrincipalType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Email => f.write_str("email"),
            }
        }
    }

    impl ::std::str::FromStr for EmailPrincipalType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "email" => Ok(Self::Email),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for EmailPrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EmailPrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EmailPrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Only relevant for original Coda packs.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Only relevant for original Coda packs.",
    ///  "deprecated": true,
    ///  "type": "string",
    ///  "enum": [
    ///    "Basic",
    ///    "Pro",
    ///    "Team",
    ///    "Enterprise"
    ///  ],
    ///  "x-schema-name": "FeatureSet",
    ///  "x-tsEnumNames": [
    ///    "Basic",
    ///    "Pro",
    ///    "Team",
    ///    "Enterprise"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum FeatureSet {
        Basic,
        Pro,
        Team,
        Enterprise,
    }

    impl ::std::convert::From<&Self> for FeatureSet {
        fn from(value: &FeatureSet) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for FeatureSet {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Basic => f.write_str("Basic"),
                Self::Pro => f.write_str("Pro"),
                Self::Team => f.write_str("Team"),
                Self::Enterprise => f.write_str("Enterprise"),
            }
        }
    }

    impl ::std::str::FromStr for FeatureSet {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "Basic" => Ok(Self::Basic),
                "Pro" => Ok(Self::Pro),
                "Team" => Ok(Self::Team),
                "Enterprise" => Ok(Self::Enterprise),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for FeatureSet {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for FeatureSet {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for FeatureSet {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Status of featured doc in pack listing.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Status of featured doc in pack listing.",
    ///  "type": "string",
    ///  "enum": [
    ///    "docInaccessibleOrDoesNotExist",
    ///    "invalidPublishedDocUrl"
    ///  ],
    ///  "x-schema-name": "FeaturedDocStatus",
    ///  "x-tsEnumNames": [
    ///    "DocInaccessibleOrDoesNotExist",
    ///    "InvalidPublishedDocUrl"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum FeaturedDocStatus {
        #[serde(rename = "docInaccessibleOrDoesNotExist")]
        DocInaccessibleOrDoesNotExist,
        #[serde(rename = "invalidPublishedDocUrl")]
        InvalidPublishedDocUrl,
    }

    impl ::std::convert::From<&Self> for FeaturedDocStatus {
        fn from(value: &FeaturedDocStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for FeaturedDocStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::DocInaccessibleOrDoesNotExist => f.write_str("docInaccessibleOrDoesNotExist"),
                Self::InvalidPublishedDocUrl => f.write_str("invalidPublishedDocUrl"),
            }
        }
    }

    impl ::std::str::FromStr for FeaturedDocStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "docInaccessibleOrDoesNotExist" => Ok(Self::DocInaccessibleOrDoesNotExist),
                "invalidPublishedDocUrl" => Ok(Self::InvalidPublishedDocUrl),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for FeaturedDocStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for FeaturedDocStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for FeaturedDocStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///A Coda folder.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A Coda folder.",
    ///  "type": "object",
    ///  "required": [
    ///    "createdAt",
    ///    "id",
    ///    "name",
    ///    "type",
    ///    "workspaceId"
    ///  ],
    ///  "properties": {
    ///    "createdAt": {
    ///      "description": "Timestamp for when the folder was created.",
    ///      "examples": [
    ///        "2018-04-11T00:18:57.946Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "description": {
    ///      "description": "The description of the folder.",
    ///      "examples": [
    ///        "A collection of project docs."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "icon": {
    ///      "$ref": "#/components/schemas/Icon"
    ///    },
    ///    "id": {
    ///      "description": "ID of the Coda folder.",
    ///      "examples": [
    ///        "fl-1Ab234"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "The name of the folder.",
    ///      "examples": [
    ///        "Projects"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "description": "The type of this resource.",
    ///      "type": "string",
    ///      "enum": [
    ///        "folder"
    ///      ],
    ///      "x-tsType": "Type.Folder"
    ///    },
    ///    "workspaceId": {
    ///      "description": "ID of the Coda workspace.",
    ///      "examples": [
    ///        "ws-1Ab234"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "Folder"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct Folder {
        ///Timestamp for when the folder was created.
        #[serde(rename = "createdAt")]
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        ///The description of the folder.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub icon: ::std::option::Option<Icon>,
        ///ID of the Coda folder.
        pub id: ::std::string::String,
        ///The name of the folder.
        pub name: ::std::string::String,
        ///The type of this resource.
        #[serde(rename = "type")]
        pub type_: FolderType,
        ///ID of the Coda workspace.
        #[serde(rename = "workspaceId")]
        pub workspace_id: ::std::string::String,
    }

    impl ::std::convert::From<&Folder> for Folder {
        fn from(value: &Folder) -> Self {
            value.clone()
        }
    }

    ///Reference to a Coda folder.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Reference to a Coda folder.",
    ///  "type": "object",
    ///  "required": [
    ///    "browserLink",
    ///    "id",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "browserLink": {
    ///      "description": "Browser-friendly link to the folder.",
    ///      "examples": [
    ///        "https://coda.io/docs?folderId=fl-1Ab234"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "id": {
    ///      "description": "ID of the Coda folder.",
    ///      "examples": [
    ///        "fl-1Ab234"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "Name of the folder; included if the user has access
    /// to the folder.",
    ///      "examples": [
    ///        "My docs"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "description": "The type of this resource.",
    ///      "type": "string",
    ///      "enum": [
    ///        "folder"
    ///      ],
    ///      "x-tsType": "Type.Folder"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "FolderReference"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct FolderReference {
        ///Browser-friendly link to the folder.
        #[serde(rename = "browserLink")]
        pub browser_link: ::std::string::String,
        ///ID of the Coda folder.
        pub id: ::std::string::String,
        ///Name of the folder; included if the user has access to the folder.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        ///The type of this resource.
        #[serde(rename = "type")]
        pub type_: FolderReferenceType,
    }

    impl ::std::convert::From<&FolderReference> for FolderReference {
        fn from(value: &FolderReference) -> Self {
            value.clone()
        }
    }

    ///The type of this resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of this resource.",
    ///  "type": "string",
    ///  "enum": [
    ///    "folder"
    ///  ],
    ///  "x-tsType": "Type.Folder"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum FolderReferenceType {
        #[serde(rename = "folder")]
        Folder,
    }

    impl ::std::convert::From<&Self> for FolderReferenceType {
        fn from(value: &FolderReferenceType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for FolderReferenceType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Folder => f.write_str("folder"),
            }
        }
    }

    impl ::std::str::FromStr for FolderReferenceType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "folder" => Ok(Self::Folder),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for FolderReferenceType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for FolderReferenceType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for FolderReferenceType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The type of this resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of this resource.",
    ///  "type": "string",
    ///  "enum": [
    ///    "folder"
    ///  ],
    ///  "x-tsType": "Type.Folder"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum FolderType {
        #[serde(rename = "folder")]
        Folder,
    }

    impl ::std::convert::From<&Self> for FolderType {
        fn from(value: &FolderType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for FolderType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Folder => f.write_str("folder"),
            }
        }
    }

    impl ::std::str::FromStr for FolderType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "folder" => Ok(Self::Folder),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for FolderType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for FolderType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for FolderType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Details about a formula.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Details about a formula.",
    ///  "type": "object",
    ///  "required": [
    ///    "href",
    ///    "id",
    ///    "name",
    ///    "type",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "href": {
    ///      "description": "API link to the formula.",
    ///      "examples": [
    ///        "https://coda.io/apis/v1/docs/AbCDeFGH/formulas/f-fgHijkLm"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "id": {
    ///      "description": "ID of the formula.",
    ///      "examples": [
    ///        "f-fgHijkLm"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "Name of the formula.",
    ///      "examples": [
    ///        "Sum of expenses"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "parent": {
    ///      "$ref": "#/components/schemas/PageReference"
    ///    },
    ///    "type": {
    ///      "description": "The type of this resource.",
    ///      "type": "string",
    ///      "enum": [
    ///        "formula"
    ///      ],
    ///      "x-tsType": "Type.Formula"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/Value"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "Formula"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct Formula {
        ///API link to the formula.
        pub href: ::std::string::String,
        ///ID of the formula.
        pub id: ::std::string::String,
        ///Name of the formula.
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub parent: ::std::option::Option<PageReference>,
        ///The type of this resource.
        #[serde(rename = "type")]
        pub type_: FormulaType,
        pub value: Value,
    }

    impl ::std::convert::From<&Formula> for Formula {
        fn from(value: &Formula) -> Self {
            value.clone()
        }
    }

    ///Detailed information about a formula.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detailed information about a formula.",
    ///  "type": "object",
    ///  "required": [
    ///    "valid"
    ///  ],
    ///  "properties": {
    ///    "hasNowFormula": {
    ///      "description": "Returns whether or not the given formula has a
    /// Now() formula within it.",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "hasTodayFormula": {
    ///      "description": "Returns whether or not the given formula has a
    /// Today() formula within it.",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "hasUserFormula": {
    ///      "description": "Returns whether or not the given formula has a
    /// User() formula within it.",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "isVolatile": {
    ///      "description": "Returns whether or not the given formula can return
    /// different results in different contexts (for example, for different
    /// users).\n",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "valid": {
    ///      "description": "Returns whether or not the given formula is
    /// valid.",
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "FormulaDetail"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct FormulaDetail {
        ///Returns whether or not the given formula has a Now() formula within
        /// it.
        #[serde(rename = "hasNowFormula", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub has_now_formula: ::std::option::Option<bool>,
        ///Returns whether or not the given formula has a Today() formula
        /// within it.
        #[serde(rename = "hasTodayFormula", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub has_today_formula: ::std::option::Option<bool>,
        ///Returns whether or not the given formula has a User() formula within
        /// it.
        #[serde(rename = "hasUserFormula", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub has_user_formula: ::std::option::Option<bool>,
        ///Returns whether or not the given formula can return different
        /// results in different contexts (for example, for different users).
        #[serde(rename = "isVolatile", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_volatile: ::std::option::Option<bool>,
        ///Returns whether or not the given formula is valid.
        pub valid: bool,
    }

    impl ::std::convert::From<&FormulaDetail> for FormulaDetail {
        fn from(value: &FormulaDetail) -> Self {
            value.clone()
        }
    }

    ///List of formulas.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "List of formulas.",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "href": {
    ///      "description": "API link to these results",
    ///      "examples": [
    ///        "https://coda.io/apis/v1/docs/AbCDeFGH/formulas?limit=20"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/FormulaReference"
    ///      }
    ///    },
    ///    "nextPageLink": {
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/nextPageLink"
    ///        },
    ///        {
    ///          "examples": [
    ///            "https://coda.io/apis/v1/docs/AbCDeFGH/formulas?pageToken=eyJsaW1pd"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      ]
    ///    },
    ///    "nextPageToken": {
    ///      "$ref": "#/components/schemas/nextPageToken"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "FormulaList"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct FormulaList {
        ///API link to these results
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub href: ::std::option::Option<::std::string::String>,
        pub items: ::std::vec::Vec<FormulaReference>,
        #[serde(rename = "nextPageLink", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_link: ::std::option::Option<NextPageLink>,
        #[serde(rename = "nextPageToken", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_token: ::std::option::Option<NextPageToken>,
    }

    impl ::std::convert::From<&FormulaList> for FormulaList {
        fn from(value: &FormulaList) -> Self {
            value.clone()
        }
    }

    ///Reference to a formula.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Reference to a formula.",
    ///  "type": "object",
    ///  "required": [
    ///    "href",
    ///    "id",
    ///    "name",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "href": {
    ///      "description": "API link to the formula.",
    ///      "examples": [
    ///        "https://coda.io/apis/v1/docs/AbCDeFGH/formulas/f-fgHijkLm"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "id": {
    ///      "description": "ID of the formula.",
    ///      "examples": [
    ///        "f-fgHijkLm"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "Name of the formula.",
    ///      "examples": [
    ///        "Sum of expenses"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "parent": {
    ///      "$ref": "#/components/schemas/PageReference"
    ///    },
    ///    "type": {
    ///      "description": "The type of this resource.",
    ///      "type": "string",
    ///      "enum": [
    ///        "formula"
    ///      ],
    ///      "x-tsType": "Type.Formula"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "FormulaReference"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct FormulaReference {
        ///API link to the formula.
        pub href: ::std::string::String,
        ///ID of the formula.
        pub id: ::std::string::String,
        ///Name of the formula.
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub parent: ::std::option::Option<PageReference>,
        ///The type of this resource.
        #[serde(rename = "type")]
        pub type_: FormulaReferenceType,
    }

    impl ::std::convert::From<&FormulaReference> for FormulaReference {
        fn from(value: &FormulaReference) -> Self {
            value.clone()
        }
    }

    ///The type of this resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of this resource.",
    ///  "type": "string",
    ///  "enum": [
    ///    "formula"
    ///  ],
    ///  "x-tsType": "Type.Formula"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum FormulaReferenceType {
        #[serde(rename = "formula")]
        Formula,
    }

    impl ::std::convert::From<&Self> for FormulaReferenceType {
        fn from(value: &FormulaReferenceType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for FormulaReferenceType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Formula => f.write_str("formula"),
            }
        }
    }

    impl ::std::str::FromStr for FormulaReferenceType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "formula" => Ok(Self::Formula),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for FormulaReferenceType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for FormulaReferenceType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for FormulaReferenceType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The type of this resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of this resource.",
    ///  "type": "string",
    ///  "enum": [
    ///    "formula"
    ///  ],
    ///  "x-tsType": "Type.Formula"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum FormulaType {
        #[serde(rename = "formula")]
        Formula,
    }

    impl ::std::convert::From<&Self> for FormulaType {
        fn from(value: &FormulaType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for FormulaType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Formula => f.write_str("formula"),
            }
        }
    }

    impl ::std::str::FromStr for FormulaType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "formula" => Ok(Self::Formula),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for FormulaType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for FormulaType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for FormulaType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Pricing used when workspaces can subscribe to the Pack for free.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Pricing used when workspaces can subscribe to the Pack
    /// for free.",
    ///  "type": "object",
    ///  "required": [
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "Free"
    ///      ],
    ///      "x-tsType": "PackPlanPricingType.Free"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "FreePackPlanPricing"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct FreePackPlanPricing {
        #[serde(rename = "type")]
        pub type_: FreePackPlanPricingType,
    }

    impl ::std::convert::From<&FreePackPlanPricing> for FreePackPlanPricing {
        fn from(value: &FreePackPlanPricing) -> Self {
            value.clone()
        }
    }

    ///`FreePackPlanPricingType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "Free"
    ///  ],
    ///  "x-tsType": "PackPlanPricingType.Free"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum FreePackPlanPricingType {
        Free,
    }

    impl ::std::convert::From<&Self> for FreePackPlanPricingType {
        fn from(value: &FreePackPlanPricingType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for FreePackPlanPricingType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Free => f.write_str("Free"),
            }
        }
    }

    impl ::std::str::FromStr for FreePackPlanPricingType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "Free" => Ok(Self::Free),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for FreePackPlanPricingType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for FreePackPlanPricingType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for FreePackPlanPricingType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        401
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetAclSettingsResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&GetAclSettingsResponse> for GetAclSettingsResponse {
        fn from(value: &GetAclSettingsResponse) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Too Many Requests"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        429
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Too Many Requests"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetAnalyticsLastUpdatedResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&GetAnalyticsLastUpdatedResponse> for GetAnalyticsLastUpdatedResponse {
        fn from(value: &GetAnalyticsLastUpdatedResponse) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        401
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetColumnResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&GetColumnResponse> for GetColumnResponse {
        fn from(value: &GetColumnResponse) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        401
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetControlResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&GetControlResponse> for GetControlResponse {
        fn from(value: &GetControlResponse) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        401
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetCustomDocDomainProviderResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&GetCustomDocDomainProviderResponse> for GetCustomDocDomainProviderResponse {
        fn from(value: &GetCustomDocDomainProviderResponse) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        401
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetDocResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&GetDocResponse> for GetDocResponse {
        fn from(value: &GetDocResponse) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetFolderResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&GetFolderResponse> for GetFolderResponse {
        fn from(value: &GetFolderResponse) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        401
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetFormulaResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&GetFormulaResponse> for GetFormulaResponse {
        fn from(value: &GetFormulaResponse) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        401
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetMutationStatusResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&GetMutationStatusResponse> for GetMutationStatusResponse {
        fn from(value: &GetMutationStatusResponse) -> Self {
            value.clone()
        }
    }

    ///Payload for getting the next version of a Pack.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Payload for getting the next version of a Pack.",
    ///  "type": "object",
    ///  "required": [
    ///    "proposedMetadata"
    ///  ],
    ///  "properties": {
    ///    "proposedMetadata": {
    ///      "description": "The metadata for the next version of the Pack.",
    ///      "examples": [
    ///        "{\"formulas\": [{\"description\": \"my formula\", \"name\":
    /// \"foo\", \"parameters\": [], \"resultType\": 0}]}"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "sdkVersion": {
    ///      "description": "The SDK version the metadata was built on.",
    ///      "examples": [
    ///        "1.0.0"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "GetNextPackVersionRequest"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetNextPackVersionRequest {
        ///The metadata for the next version of the Pack.
        #[serde(rename = "proposedMetadata")]
        pub proposed_metadata: ::std::string::String,
        ///The SDK version the metadata was built on.
        #[serde(rename = "sdkVersion", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sdk_version: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&GetNextPackVersionRequest> for GetNextPackVersionRequest {
        fn from(value: &GetNextPackVersionRequest) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "codaDetail": {
    ///      "description": "Detail about why this request was rejected.",
    ///      "type": "object",
    ///      "properties": {
    ///        "validationErrors": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/ValidationError"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    },
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetNextPackVersionResponse {
        #[serde(rename = "codaDetail", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub coda_detail: ::std::option::Option<GetNextPackVersionResponseCodaDetail>,
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&GetNextPackVersionResponse> for GetNextPackVersionResponse {
        fn from(value: &GetNextPackVersionResponse) -> Self {
            value.clone()
        }
    }

    ///Detail about why this request was rejected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why this request was rejected.",
    ///  "type": "object",
    ///  "properties": {
    ///    "validationErrors": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetNextPackVersionResponseCodaDetail {
        #[serde(rename = "validationErrors", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub validation_errors: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&GetNextPackVersionResponseCodaDetail> for GetNextPackVersionResponseCodaDetail {
        fn from(value: &GetNextPackVersionResponseCodaDetail) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for GetNextPackVersionResponseCodaDetail {
        fn default() -> Self {
            Self {
                validation_errors: Default::default(),
            }
        }
    }

    ///JSON schema response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "JSON schema response.",
    ///  "type": "object",
    ///  "additionalProperties": true,
    ///  "x-schema-name": "GetPackConfigurationJsonSchemaResponse"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct GetPackConfigurationJsonSchemaResponse(pub ::serde_json::Map<::std::string::String, ::serde_json::Value>);
    impl ::std::ops::Deref for GetPackConfigurationJsonSchemaResponse {
        type Target = ::serde_json::Map<::std::string::String, ::serde_json::Value>;
        fn deref(&self) -> &::serde_json::Map<::std::string::String, ::serde_json::Value> {
            &self.0
        }
    }

    impl ::std::convert::From<GetPackConfigurationJsonSchemaResponse> for ::serde_json::Map<::std::string::String, ::serde_json::Value> {
        fn from(value: GetPackConfigurationJsonSchemaResponse) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&GetPackConfigurationJsonSchemaResponse> for GetPackConfigurationJsonSchemaResponse {
        fn from(value: &GetPackConfigurationJsonSchemaResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::serde_json::Map<::std::string::String, ::serde_json::Value>> for GetPackConfigurationJsonSchemaResponse {
        fn from(value: ::serde_json::Map<::std::string::String, ::serde_json::Value>) -> Self {
            Self(value)
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "codaDetail": {
    ///      "description": "Detail about why this request was rejected.",
    ///      "type": "object",
    ///      "properties": {
    ///        "validationErrors": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/ValidationError"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    },
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetPackConfigurationSchemaResponse {
        #[serde(rename = "codaDetail", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub coda_detail: ::std::option::Option<GetPackConfigurationSchemaResponseCodaDetail>,
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&GetPackConfigurationSchemaResponse> for GetPackConfigurationSchemaResponse {
        fn from(value: &GetPackConfigurationSchemaResponse) -> Self {
            value.clone()
        }
    }

    ///Detail about why this request was rejected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why this request was rejected.",
    ///  "type": "object",
    ///  "properties": {
    ///    "validationErrors": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetPackConfigurationSchemaResponseCodaDetail {
        #[serde(rename = "validationErrors", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub validation_errors: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&GetPackConfigurationSchemaResponseCodaDetail> for GetPackConfigurationSchemaResponseCodaDetail {
        fn from(value: &GetPackConfigurationSchemaResponseCodaDetail) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for GetPackConfigurationSchemaResponseCodaDetail {
        fn default() -> Self {
            Self {
                validation_errors: Default::default(),
            }
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "codaDetail": {
    ///      "description": "Detail about why this request was rejected.",
    ///      "type": "object",
    ///      "properties": {
    ///        "validationErrors": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/ValidationError"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    },
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetPackListingResponse {
        #[serde(rename = "codaDetail", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub coda_detail: ::std::option::Option<GetPackListingResponseCodaDetail>,
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&GetPackListingResponse> for GetPackListingResponse {
        fn from(value: &GetPackListingResponse) -> Self {
            value.clone()
        }
    }

    ///Detail about why this request was rejected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why this request was rejected.",
    ///  "type": "object",
    ///  "properties": {
    ///    "validationErrors": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetPackListingResponseCodaDetail {
        #[serde(rename = "validationErrors", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub validation_errors: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&GetPackListingResponseCodaDetail> for GetPackListingResponseCodaDetail {
        fn from(value: &GetPackListingResponseCodaDetail) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for GetPackListingResponseCodaDetail {
        fn default() -> Self {
            Self {
                validation_errors: Default::default(),
            }
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "codaDetail": {
    ///      "description": "Detail about why this request was rejected.",
    ///      "type": "object",
    ///      "properties": {
    ///        "validationErrors": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/ValidationError"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    },
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetPackLogDetailsResponse {
        #[serde(rename = "codaDetail", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub coda_detail: ::std::option::Option<GetPackLogDetailsResponseCodaDetail>,
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&GetPackLogDetailsResponse> for GetPackLogDetailsResponse {
        fn from(value: &GetPackLogDetailsResponse) -> Self {
            value.clone()
        }
    }

    ///Detail about why this request was rejected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why this request was rejected.",
    ///  "type": "object",
    ///  "properties": {
    ///    "validationErrors": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetPackLogDetailsResponseCodaDetail {
        #[serde(rename = "validationErrors", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub validation_errors: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&GetPackLogDetailsResponseCodaDetail> for GetPackLogDetailsResponseCodaDetail {
        fn from(value: &GetPackLogDetailsResponseCodaDetail) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for GetPackLogDetailsResponseCodaDetail {
        fn default() -> Self {
            Self {
                validation_errors: Default::default(),
            }
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "codaDetail": {
    ///      "description": "Detail about why this request was rejected.",
    ///      "type": "object",
    ///      "properties": {
    ///        "validationErrors": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/ValidationError"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    },
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetPackOauthConfigResponse {
        #[serde(rename = "codaDetail", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub coda_detail: ::std::option::Option<GetPackOauthConfigResponseCodaDetail>,
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&GetPackOauthConfigResponse> for GetPackOauthConfigResponse {
        fn from(value: &GetPackOauthConfigResponse) -> Self {
            value.clone()
        }
    }

    ///Detail about why this request was rejected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why this request was rejected.",
    ///  "type": "object",
    ///  "properties": {
    ///    "validationErrors": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetPackOauthConfigResponseCodaDetail {
        #[serde(rename = "validationErrors", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub validation_errors: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&GetPackOauthConfigResponseCodaDetail> for GetPackOauthConfigResponseCodaDetail {
        fn from(value: &GetPackOauthConfigResponseCodaDetail) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for GetPackOauthConfigResponseCodaDetail {
        fn default() -> Self {
            Self {
                validation_errors: Default::default(),
            }
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "codaDetail": {
    ///      "description": "Detail about why this request was rejected.",
    ///      "type": "object",
    ///      "properties": {
    ///        "validationErrors": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/ValidationError"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    },
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetPackPermissionsResponse {
        #[serde(rename = "codaDetail", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub coda_detail: ::std::option::Option<GetPackPermissionsResponseCodaDetail>,
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&GetPackPermissionsResponse> for GetPackPermissionsResponse {
        fn from(value: &GetPackPermissionsResponse) -> Self {
            value.clone()
        }
    }

    ///Detail about why this request was rejected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why this request was rejected.",
    ///  "type": "object",
    ///  "properties": {
    ///    "validationErrors": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetPackPermissionsResponseCodaDetail {
        #[serde(rename = "validationErrors", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub validation_errors: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&GetPackPermissionsResponseCodaDetail> for GetPackPermissionsResponseCodaDetail {
        fn from(value: &GetPackPermissionsResponseCodaDetail) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for GetPackPermissionsResponseCodaDetail {
        fn default() -> Self {
            Self {
                validation_errors: Default::default(),
            }
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetPackResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&GetPackResponse> for GetPackResponse {
        fn from(value: &GetPackResponse) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "codaDetail": {
    ///      "description": "Detail about why this request was rejected.",
    ///      "type": "object",
    ///      "properties": {
    ///        "validationErrors": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/ValidationError"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    },
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetPackSourceCodeResponse {
        #[serde(rename = "codaDetail", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub coda_detail: ::std::option::Option<GetPackSourceCodeResponseCodaDetail>,
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&GetPackSourceCodeResponse> for GetPackSourceCodeResponse {
        fn from(value: &GetPackSourceCodeResponse) -> Self {
            value.clone()
        }
    }

    ///Detail about why this request was rejected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why this request was rejected.",
    ///  "type": "object",
    ///  "properties": {
    ///    "validationErrors": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetPackSourceCodeResponseCodaDetail {
        #[serde(rename = "validationErrors", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub validation_errors: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&GetPackSourceCodeResponseCodaDetail> for GetPackSourceCodeResponseCodaDetail {
        fn from(value: &GetPackSourceCodeResponseCodaDetail) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for GetPackSourceCodeResponseCodaDetail {
        fn default() -> Self {
            Self {
                validation_errors: Default::default(),
            }
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "codaDetail": {
    ///      "description": "Detail about why this request was rejected.",
    ///      "type": "object",
    ///      "properties": {
    ///        "validationErrors": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/ValidationError"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    },
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetPackSystemConnectionResponse {
        #[serde(rename = "codaDetail", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub coda_detail: ::std::option::Option<GetPackSystemConnectionResponseCodaDetail>,
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&GetPackSystemConnectionResponse> for GetPackSystemConnectionResponse {
        fn from(value: &GetPackSystemConnectionResponse) -> Self {
            value.clone()
        }
    }

    ///Detail about why this request was rejected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why this request was rejected.",
    ///  "type": "object",
    ///  "properties": {
    ///    "validationErrors": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetPackSystemConnectionResponseCodaDetail {
        #[serde(rename = "validationErrors", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub validation_errors: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&GetPackSystemConnectionResponseCodaDetail> for GetPackSystemConnectionResponseCodaDetail {
        fn from(value: &GetPackSystemConnectionResponseCodaDetail) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for GetPackSystemConnectionResponseCodaDetail {
        fn default() -> Self {
            Self {
                validation_errors: Default::default(),
            }
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "codaDetail": {
    ///      "description": "Detail about why this request was rejected.",
    ///      "type": "object",
    ///      "properties": {
    ///        "validationErrors": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/ValidationError"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    },
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetPackVersionDiffsResponse {
        #[serde(rename = "codaDetail", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub coda_detail: ::std::option::Option<GetPackVersionDiffsResponseCodaDetail>,
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&GetPackVersionDiffsResponse> for GetPackVersionDiffsResponse {
        fn from(value: &GetPackVersionDiffsResponse) -> Self {
            value.clone()
        }
    }

    ///Detail about why this request was rejected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why this request was rejected.",
    ///  "type": "object",
    ///  "properties": {
    ///    "validationErrors": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetPackVersionDiffsResponseCodaDetail {
        #[serde(rename = "validationErrors", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub validation_errors: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&GetPackVersionDiffsResponseCodaDetail> for GetPackVersionDiffsResponseCodaDetail {
        fn from(value: &GetPackVersionDiffsResponseCodaDetail) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for GetPackVersionDiffsResponseCodaDetail {
        fn default() -> Self {
            Self {
                validation_errors: Default::default(),
            }
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        401
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetPageContentExportStatusResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&GetPageContentExportStatusResponse> for GetPageContentExportStatusResponse {
        fn from(value: &GetPageContentExportStatusResponse) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        401
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetPageResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&GetPageResponse> for GetPageResponse {
        fn from(value: &GetPageResponse) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        401
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetPermissionsResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&GetPermissionsResponse> for GetPermissionsResponse {
        fn from(value: &GetPermissionsResponse) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        401
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetRowResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&GetRowResponse> for GetRowResponse {
        fn from(value: &GetRowResponse) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        401
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetSharingMetadataResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&GetSharingMetadataResponse> for GetSharingMetadataResponse {
        fn from(value: &GetSharingMetadataResponse) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        401
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetTableResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&GetTableResponse> for GetTableResponse {
        fn from(value: &GetTableResponse) -> Self {
            value.clone()
        }
    }

    ///Response for getting workspace role activity.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Response for getting workspace role activity.",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/WorkspaceRoleActivity"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "GetWorkspaceRoleActivity"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetWorkspaceRoleActivity {
        pub items: ::std::vec::Vec<WorkspaceRoleActivity>,
    }

    impl ::std::convert::From<&GetWorkspaceRoleActivity> for GetWorkspaceRoleActivity {
        fn from(value: &GetWorkspaceRoleActivity) -> Self {
            value.clone()
        }
    }

    ///`GroupPrincipal`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "groupId",
    ///    "groupName",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "groupId": {
    ///      "description": "Group ID for the principal.",
    ///      "examples": [
    ///        "grp-6SM9xrKcqW"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "groupName": {
    ///      "description": "Name of the group.",
    ///      "examples": [
    ///        "Marketing team"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "description": "The type of this principal.",
    ///      "type": "string",
    ///      "enum": [
    ///        "group"
    ///      ],
    ///      "x-tsType": "PrincipalType.Group"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GroupPrincipal {
        ///Group ID for the principal.
        #[serde(rename = "groupId")]
        pub group_id: ::std::string::String,
        ///Name of the group.
        #[serde(rename = "groupName")]
        pub group_name: ::std::string::String,
        ///The type of this principal.
        #[serde(rename = "type")]
        pub type_: GroupPrincipalType,
    }

    impl ::std::convert::From<&GroupPrincipal> for GroupPrincipal {
        fn from(value: &GroupPrincipal) -> Self {
            value.clone()
        }
    }

    ///The type of this principal.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of this principal.",
    ///  "type": "string",
    ///  "enum": [
    ///    "group"
    ///  ],
    ///  "x-tsType": "PrincipalType.Group"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum GroupPrincipalType {
        #[serde(rename = "group")]
        Group,
    }

    impl ::std::convert::From<&Self> for GroupPrincipalType {
        fn from(value: &GroupPrincipalType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for GroupPrincipalType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Group => f.write_str("group"),
            }
        }
    }

    impl ::std::str::FromStr for GroupPrincipalType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "group" => Ok(Self::Group),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for GroupPrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for GroupPrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for GroupPrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Grouped logs of the Pack's auth requests.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Grouped logs of the Pack's auth requests.",
    ///  "type": "object",
    ///  "required": [
    ///    "authLog",
    ///    "relatedLogs",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "authLog": {
    ///      "$ref": "#/components/schemas/PackAuthLog"
    ///    },
    ///    "relatedLogs": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PackLog"
    ///      }
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "auth"
    ///      ],
    ///      "x-tsType": "PackLogType.Auth"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "GroupedPackAuthLog"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GroupedPackAuthLog {
        #[serde(rename = "authLog")]
        pub auth_log: PackAuthLog,
        #[serde(rename = "relatedLogs")]
        pub related_logs: ::std::vec::Vec<PackLog>,
        #[serde(rename = "type")]
        pub type_: GroupedPackAuthLogType,
    }

    impl ::std::convert::From<&GroupedPackAuthLog> for GroupedPackAuthLog {
        fn from(value: &GroupedPackAuthLog) -> Self {
            value.clone()
        }
    }

    ///`GroupedPackAuthLogType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "auth"
    ///  ],
    ///  "x-tsType": "PackLogType.Auth"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum GroupedPackAuthLogType {
        #[serde(rename = "auth")]
        Auth,
    }

    impl ::std::convert::From<&Self> for GroupedPackAuthLogType {
        fn from(value: &GroupedPackAuthLogType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for GroupedPackAuthLogType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Auth => f.write_str("auth"),
            }
        }
    }

    impl ::std::str::FromStr for GroupedPackAuthLogType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "auth" => Ok(Self::Auth),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for GroupedPackAuthLogType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for GroupedPackAuthLogType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for GroupedPackAuthLogType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Grouped logs of the invocations of the Pack.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Grouped logs of the invocations of the Pack.",
    ///  "type": "object",
    ///  "required": [
    ///    "invocationLog",
    ///    "relatedLogs",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "invocationLog": {
    ///      "$ref": "#/components/schemas/PackInvocationLog"
    ///    },
    ///    "relatedLogs": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PackLog"
    ///      }
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "invocation"
    ///      ],
    ///      "x-tsType": "PackLogType.Invocation"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "GroupedPackInvocationLog"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GroupedPackInvocationLog {
        #[serde(rename = "invocationLog")]
        pub invocation_log: PackInvocationLog,
        #[serde(rename = "relatedLogs")]
        pub related_logs: ::std::vec::Vec<PackLog>,
        #[serde(rename = "type")]
        pub type_: GroupedPackInvocationLogType,
    }

    impl ::std::convert::From<&GroupedPackInvocationLog> for GroupedPackInvocationLog {
        fn from(value: &GroupedPackInvocationLog) -> Self {
            value.clone()
        }
    }

    ///`GroupedPackInvocationLogType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "invocation"
    ///  ],
    ///  "x-tsType": "PackLogType.Invocation"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum GroupedPackInvocationLogType {
        #[serde(rename = "invocation")]
        Invocation,
    }

    impl ::std::convert::From<&Self> for GroupedPackInvocationLogType {
        fn from(value: &GroupedPackInvocationLogType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for GroupedPackInvocationLogType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Invocation => f.write_str("invocation"),
            }
        }
    }

    impl ::std::str::FromStr for GroupedPackInvocationLogType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "invocation" => Ok(Self::Invocation),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for GroupedPackInvocationLogType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for GroupedPackInvocationLogType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for GroupedPackInvocationLogType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///A record of grouped Pack log.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A record of grouped Pack log.",
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/GroupedPackInvocationLog"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/GroupedPackAuthLog"
    ///    }
    ///  ],
    ///  "x-schema-name": "GroupedPackLog"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum GroupedPackLog {
        InvocationLog(GroupedPackInvocationLog),
        AuthLog(GroupedPackAuthLog),
    }

    impl ::std::convert::From<&Self> for GroupedPackLog {
        fn from(value: &GroupedPackLog) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<GroupedPackInvocationLog> for GroupedPackLog {
        fn from(value: GroupedPackInvocationLog) -> Self {
            Self::InvocationLog(value)
        }
    }

    impl ::std::convert::From<GroupedPackAuthLog> for GroupedPackLog {
        fn from(value: GroupedPackAuthLog) -> Self {
            Self::AuthLog(value)
        }
    }

    ///List of grouped Pack logs.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "List of grouped Pack logs.",
    ///  "type": "object",
    ///  "required": [
    ///    "incompleteRelatedLogs",
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "incompleteRelatedLogs": {
    ///      "description": "This flag will be set to true if the result doens't
    /// include all the related logs.",
    ///      "type": "boolean"
    ///    },
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/GroupedPackLog"
    ///      }
    ///    },
    ///    "nextPageLink": {
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/nextPageLink"
    ///        },
    ///        {
    ///          "examples": [
    ///            "https://coda.io/apis/v1/packs/1/groupedLogs?pageToken=xyz"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      ]
    ///    },
    ///    "nextPageToken": {
    ///      "$ref": "#/components/schemas/nextPageToken"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "GroupedPackLogsList"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GroupedPackLogsList {
        ///This flag will be set to true if the result doens't include all the
        /// related logs.
        #[serde(rename = "incompleteRelatedLogs")]
        pub incomplete_related_logs: bool,
        pub items: ::std::vec::Vec<GroupedPackLog>,
        #[serde(rename = "nextPageLink", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_link: ::std::option::Option<NextPageLink>,
        #[serde(rename = "nextPageToken", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_token: ::std::option::Option<NextPageToken>,
    }

    impl ::std::convert::From<&GroupedPackLogsList> for GroupedPackLogsList {
        fn from(value: &GroupedPackLogsList) -> Self {
            value.clone()
        }
    }

    ///Info about the icon.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Info about the icon.",
    ///  "type": "object",
    ///  "required": [
    ///    "browserLink",
    ///    "name",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "browserLink": {
    ///      "description": "Browser-friendly link to an icon.",
    ///      "examples": [
    ///        "https://cdn.coda.io/icons/png/color/icon-32.png"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "name": {
    ///      "description": "Name of the icon.",
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "description": "MIME type of the icon",
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "icon"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct Icon {
        ///Browser-friendly link to an icon.
        #[serde(rename = "browserLink")]
        pub browser_link: ::std::string::String,
        ///Name of the icon.
        pub name: ::std::string::String,
        ///MIME type of the icon
        #[serde(rename = "type")]
        pub type_: ::std::string::String,
    }

    impl ::std::convert::From<&Icon> for Icon {
        fn from(value: &Icon) -> Self {
            value.clone()
        }
    }

    ///List of available icon sets.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "List of available icon sets.",
    ///  "type": "string",
    ///  "enum": [
    ///    "star",
    ///    "circle",
    ///    "fire",
    ///    "bug",
    ///    "diamond",
    ///    "bell",
    ///    "thumbsup",
    ///    "heart",
    ///    "chili",
    ///    "smiley",
    ///    "lightning",
    ///    "currency",
    ///    "coffee",
    ///    "person",
    ///    "battery",
    ///    "cocktail",
    ///    "cloud",
    ///    "sun",
    ///    "checkmark",
    ///    "lightbulb"
    ///  ],
    ///  "x-schema-name": "IconSet",
    ///  "x-tsEnumNames": [
    ///    "Star",
    ///    "Circle",
    ///    "Fire",
    ///    "Bug",
    ///    "Diamond",
    ///    "Bell",
    ///    "ThumbsUp",
    ///    "Heart",
    ///    "Chili",
    ///    "Smiley",
    ///    "Lightning",
    ///    "Currency",
    ///    "Coffee",
    ///    "Person",
    ///    "Battery",
    ///    "Cocktail",
    ///    "Cloud",
    ///    "Sun",
    ///    "Checkmark",
    ///    "LightBulb"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum IconSet {
        #[serde(rename = "star")]
        Star,
        #[serde(rename = "circle")]
        Circle,
        #[serde(rename = "fire")]
        Fire,
        #[serde(rename = "bug")]
        Bug,
        #[serde(rename = "diamond")]
        Diamond,
        #[serde(rename = "bell")]
        Bell,
        #[serde(rename = "thumbsup")]
        Thumbsup,
        #[serde(rename = "heart")]
        Heart,
        #[serde(rename = "chili")]
        Chili,
        #[serde(rename = "smiley")]
        Smiley,
        #[serde(rename = "lightning")]
        Lightning,
        #[serde(rename = "currency")]
        Currency,
        #[serde(rename = "coffee")]
        Coffee,
        #[serde(rename = "person")]
        Person,
        #[serde(rename = "battery")]
        Battery,
        #[serde(rename = "cocktail")]
        Cocktail,
        #[serde(rename = "cloud")]
        Cloud,
        #[serde(rename = "sun")]
        Sun,
        #[serde(rename = "checkmark")]
        Checkmark,
        #[serde(rename = "lightbulb")]
        Lightbulb,
    }

    impl ::std::convert::From<&Self> for IconSet {
        fn from(value: &IconSet) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for IconSet {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Star => f.write_str("star"),
                Self::Circle => f.write_str("circle"),
                Self::Fire => f.write_str("fire"),
                Self::Bug => f.write_str("bug"),
                Self::Diamond => f.write_str("diamond"),
                Self::Bell => f.write_str("bell"),
                Self::Thumbsup => f.write_str("thumbsup"),
                Self::Heart => f.write_str("heart"),
                Self::Chili => f.write_str("chili"),
                Self::Smiley => f.write_str("smiley"),
                Self::Lightning => f.write_str("lightning"),
                Self::Currency => f.write_str("currency"),
                Self::Coffee => f.write_str("coffee"),
                Self::Person => f.write_str("person"),
                Self::Battery => f.write_str("battery"),
                Self::Cocktail => f.write_str("cocktail"),
                Self::Cloud => f.write_str("cloud"),
                Self::Sun => f.write_str("sun"),
                Self::Checkmark => f.write_str("checkmark"),
                Self::Lightbulb => f.write_str("lightbulb"),
            }
        }
    }

    impl ::std::str::FromStr for IconSet {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "star" => Ok(Self::Star),
                "circle" => Ok(Self::Circle),
                "fire" => Ok(Self::Fire),
                "bug" => Ok(Self::Bug),
                "diamond" => Ok(Self::Diamond),
                "bell" => Ok(Self::Bell),
                "thumbsup" => Ok(Self::Thumbsup),
                "heart" => Ok(Self::Heart),
                "chili" => Ok(Self::Chili),
                "smiley" => Ok(Self::Smiley),
                "lightning" => Ok(Self::Lightning),
                "currency" => Ok(Self::Currency),
                "coffee" => Ok(Self::Coffee),
                "person" => Ok(Self::Person),
                "battery" => Ok(Self::Battery),
                "cocktail" => Ok(Self::Cocktail),
                "cloud" => Ok(Self::Cloud),
                "sun" => Ok(Self::Sun),
                "checkmark" => Ok(Self::Checkmark),
                "lightbulb" => Ok(Self::Lightbulb),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for IconSet {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for IconSet {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for IconSet {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Info about the image.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Info about the image.",
    ///  "type": "object",
    ///  "required": [
    ///    "browserLink"
    ///  ],
    ///  "properties": {
    ///    "browserLink": {
    ///      "description": "Browser-friendly link to an image.",
    ///      "examples": [
    ///        "https://codahosted.io/docs/nUYhlXysYO/blobs/bl-lYkYKNzkuT/3f879b9ecfa27448"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "height": {
    ///      "description": "The height in pixels of the image.",
    ///      "examples": [
    ///        600
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "type": {
    ///      "description": "MIME type of the image.",
    ///      "type": "string"
    ///    },
    ///    "width": {
    ///      "description": "The width in pixels of the image.",
    ///      "examples": [
    ///        800
    ///      ],
    ///      "type": "number"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "Image"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct Image {
        ///Browser-friendly link to an image.
        #[serde(rename = "browserLink")]
        pub browser_link: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub height: ::std::option::Option<f64>,
        ///MIME type of the image.
        #[serde(rename = "type", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub type_: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub width: ::std::option::Option<f64>,
    }

    impl ::std::convert::From<&Image> for Image {
        fn from(value: &Image) -> Self {
            value.clone()
        }
    }

    ///`ImageReferenceColumnFormat`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Format of an image reference column.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/SimpleColumnFormat"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "height",
    ///        "style",
    ///        "width"
    ///      ],
    ///      "properties": {
    ///        "height": {
    ///          "allOf": [
    ///            {
    ///              "description": "The image height.",
    ///              "additionalProperties": false
    ///            },
    ///            {
    ///              "$ref": "#/components/schemas/NumberOrNumberFormula"
    ///            }
    ///          ]
    ///        },
    ///        "style": {
    ///          "$ref": "#/components/schemas/ImageShapeStyle"
    ///        },
    ///        "width": {
    ///          "allOf": [
    ///            {
    ///              "description": "The image width.",
    ///              "additionalProperties": false
    ///            },
    ///            {
    ///              "$ref": "#/components/schemas/NumberOrNumberFormula"
    ///            }
    ///          ]
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  ],
    ///  "x-schema-name": "ImageReferenceColumnFormat"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(deny_unknown_fields)]
    pub enum ImageReferenceColumnFormat {}
    impl ::std::convert::From<&Self> for ImageReferenceColumnFormat {
        fn from(value: &ImageReferenceColumnFormat) -> Self {
            value.clone()
        }
    }

    ///How an image should be displayed.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "How an image should be displayed.",
    ///  "type": "string",
    ///  "enum": [
    ///    "auto",
    ///    "circle"
    ///  ],
    ///  "x-schema-name": "ImageShapeStyle",
    ///  "x-tsEnumNames": [
    ///    "Auto",
    ///    "Circle"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum ImageShapeStyle {
        #[serde(rename = "auto")]
        Auto,
        #[serde(rename = "circle")]
        Circle,
    }

    impl ::std::convert::From<&Self> for ImageShapeStyle {
        fn from(value: &ImageShapeStyle) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ImageShapeStyle {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Auto => f.write_str("auto"),
                Self::Circle => f.write_str("circle"),
            }
        }
    }

    impl ::std::str::FromStr for ImageShapeStyle {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "auto" => Ok(Self::Auto),
                "circle" => Ok(Self::Circle),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ImageShapeStyle {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ImageShapeStyle {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ImageShapeStyle {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The status values that an image object can have.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The status values that an image object can have.",
    ///  "type": "string",
    ///  "enum": [
    ///    "live",
    ///    "deleted",
    ///    "failed"
    ///  ],
    ///  "x-schema-name": "ImageStatus",
    ///  "x-tsEnumNames": [
    ///    "Live",
    ///    "Deleted",
    ///    "Failed"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum ImageStatus {
        #[serde(rename = "live")]
        Live,
        #[serde(rename = "deleted")]
        Deleted,
        #[serde(rename = "failed")]
        Failed,
    }

    impl ::std::convert::From<&Self> for ImageStatus {
        fn from(value: &ImageStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ImageStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Live => f.write_str("live"),
                Self::Deleted => f.write_str("deleted"),
                Self::Failed => f.write_str("failed"),
            }
        }
    }

    impl ::std::str::FromStr for ImageStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "live" => Ok(Self::Live),
                "deleted" => Ok(Self::Deleted),
                "failed" => Ok(Self::Failed),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ImageStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ImageStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ImageStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`ImageUrlValue`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A named url of an image along with metadata.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/LinkedDataObject"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "@type"
    ///      ],
    ///      "properties": {
    ///        "@type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ImageObject"
    ///          ],
    ///          "x-tsType": "LinkedDataType.ImageObject"
    ///        },
    ///        "height": {
    ///          "description": "The height of the image in pixels.",
    ///          "examples": [
    ///            480
    ///          ],
    ///          "type": "number"
    ///        },
    ///        "name": {
    ///          "description": "The name of the image.",
    ///          "examples": [
    ///            "Dogs Playing Poker"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "status": {
    ///          "$ref": "#/components/schemas/ImageStatus"
    ///        },
    ///        "url": {
    ///          "description": "The url of the image.",
    ///          "examples": [
    ///            "https://example.com/dogs-playing-poker.jpg"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "width": {
    ///          "description": "The width of the image in pixels.",
    ///          "examples": [
    ///            640
    ///          ],
    ///          "type": "number"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  ],
    ///  "x-schema-name": "ImageUrlValue"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(deny_unknown_fields)]
    pub enum ImageUrlValue {}
    impl ::std::convert::From<&Self> for ImageUrlValue {
        fn from(value: &ImageUrlValue) -> Self {
            value.clone()
        }
    }

    ///An ingestion batch execution.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ingestion batch execution.",
    ///  "type": "object",
    ///  "required": [
    ///    "completionTimestamp",
    ///    "creationTimestamp",
    ///    "errorMessage",
    ///    "executionType",
    ///    "fullExecutionId",
    ///    "ingestionExecutionId",
    ///    "ingestionId",
    ///    "ingestionName",
    ///    "ingestionStatuses",
    ///    "startTimestamp"
    ///  ],
    ///  "properties": {
    ///    "completionTimestamp": {
    ///      "description": "Completion time of the ingestion batch execution in
    /// seconds since epoch.",
    ///      "type": "number"
    ///    },
    ///    "creationTimestamp": {
    ///      "description": "Creation time of the ingestion batch execution in
    /// seconds since epoch.",
    ///      "type": "number"
    ///    },
    ///    "dynamicLabel": {
    ///      "description": "The label of the dynamic URL of the ingestion, if
    /// any.",
    ///      "type": "string"
    ///    },
    ///    "dynamicUrl": {
    ///      "description": "The dynamic URL of the ingestion.",
    ///      "type": "string"
    ///    },
    ///    "executionType": {
    ///      "$ref": "#/components/schemas/IngestionExecutionType"
    ///    },
    ///    "fullExecutionId": {
    ///      "description": "The ID of the full ingestion execution.",
    ///      "type": "string"
    ///    },
    ///    "ingestionExecutionId": {
    ///      "description": "The ID of the ingestion batch execution.",
    ///      "type": "string"
    ///    },
    ///    "ingestionId": {
    ///      "description": "The ID of the ingestion.",
    ///      "type": "string"
    ///    },
    ///    "ingestionName": {
    ///      "description": "The name of the ingestion.",
    ///      "type": "string"
    ///    },
    ///    "ingestionStatusCounts": {
    ///      "description": "Histogram of IngestionStatus of child executions
    /// (even if there's only 1, non-crawled execution) as enum values.",
    ///      "examples": [
    ///        {
    ///          "COMPLETED": 12,
    ///          "FAILED": 5,
    ///          "STARTED": 4
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "additionalProperties": {
    ///        "type": "integer"
    ///      }
    ///    },
    ///    "lastFinishedFullWorkflowExecutionId": {
    ///      "description": "The ID of the last full workflow execution that
    /// finished.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "lastFinishedIncrementalWorkflowExecutionId": {
    ///      "description": "The ID of the last incremental workflow execution
    /// that finished.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "latestFullWorkflowExecutionId": {
    ///      "description": "The ID of the latest full workflow execution.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "latestIncrementalWorkflowExecutionId": {
    ///      "description": "The ID of the latest incremental workflow
    /// execution.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "latestIngestionSequenceId": {
    ///      "description": "The ID of the latest full execution.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "liveIngestionSequenceId": {
    ///      "description": "The ID of the full execution that generated the
    /// currently live data.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "parentSyncTableIngestionId": {
    ///      "description": "The ID of the parent sync tableingestion, if any.",
    ///      "type": "string"
    ///    },
    ///    "startTimestamp": {
    ///      "description": "Start time of the ingestion batch execution in
    /// seconds since epoch.",
    ///      "type": "number"
    ///    },
    ///    "totalRowCount": {
    ///      "description": "The total number of rows processed in the ingestion
    /// batch execution.",
    ///      "type": "number"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "IngestionBatchExecution"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct IngestionBatchExecution {
        #[serde(rename = "completionTimestamp")]
        pub completion_timestamp: f64,
        #[serde(rename = "creationTimestamp")]
        pub creation_timestamp: f64,
        ///The label of the dynamic URL of the ingestion, if any.
        #[serde(rename = "dynamicLabel", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub dynamic_label: ::std::option::Option<::std::string::String>,
        ///The dynamic URL of the ingestion.
        #[serde(rename = "dynamicUrl", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub dynamic_url: ::std::option::Option<::std::string::String>,
        #[serde(rename = "errorMessage")]
        pub error_message: ::serde_json::Value,
        #[serde(rename = "executionType")]
        pub execution_type: IngestionExecutionType,
        ///The ID of the full ingestion execution.
        #[serde(rename = "fullExecutionId")]
        pub full_execution_id: ::std::string::String,
        ///The ID of the ingestion batch execution.
        #[serde(rename = "ingestionExecutionId")]
        pub ingestion_execution_id: ::std::string::String,
        ///The ID of the ingestion.
        #[serde(rename = "ingestionId")]
        pub ingestion_id: ::std::string::String,
        ///The name of the ingestion.
        #[serde(rename = "ingestionName")]
        pub ingestion_name: ::std::string::String,
        ///Histogram of IngestionStatus of child executions (even if there's
        /// only 1, non-crawled execution) as enum values.
        #[serde(rename = "ingestionStatusCounts", default, skip_serializing_if = ":: std :: collections :: HashMap::is_empty")]
        pub ingestion_status_counts: ::std::collections::HashMap<::std::string::String, i64>,
        #[serde(rename = "ingestionStatuses")]
        pub ingestion_statuses: ::serde_json::Value,
        ///The ID of the last full workflow execution that finished.
        #[serde(rename = "lastFinishedFullWorkflowExecutionId", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_finished_full_workflow_execution_id: ::std::option::Option<::uuid::Uuid>,
        ///The ID of the last incremental workflow execution that finished.
        #[serde(rename = "lastFinishedIncrementalWorkflowExecutionId", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_finished_incremental_workflow_execution_id: ::std::option::Option<::uuid::Uuid>,
        ///The ID of the latest full workflow execution.
        #[serde(rename = "latestFullWorkflowExecutionId", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub latest_full_workflow_execution_id: ::std::option::Option<::uuid::Uuid>,
        ///The ID of the latest incremental workflow execution.
        #[serde(rename = "latestIncrementalWorkflowExecutionId", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub latest_incremental_workflow_execution_id: ::std::option::Option<::uuid::Uuid>,
        ///The ID of the latest full execution.
        #[serde(rename = "latestIngestionSequenceId", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub latest_ingestion_sequence_id: ::std::option::Option<::uuid::Uuid>,
        ///The ID of the full execution that generated the currently live data.
        #[serde(rename = "liveIngestionSequenceId", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub live_ingestion_sequence_id: ::std::option::Option<::uuid::Uuid>,
        ///The ID of the parent sync tableingestion, if any.
        #[serde(rename = "parentSyncTableIngestionId", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub parent_sync_table_ingestion_id: ::std::option::Option<::std::string::String>,
        #[serde(rename = "startTimestamp")]
        pub start_timestamp: f64,
        #[serde(rename = "totalRowCount", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub total_row_count: ::std::option::Option<f64>,
    }

    impl ::std::convert::From<&IngestionBatchExecution> for IngestionBatchExecution {
        fn from(value: &IngestionBatchExecution) -> Self {
            value.clone()
        }
    }

    ///List of Ingestion Batch Executions.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "List of Ingestion Batch Executions.",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/IngestionBatchExecution"
    ///      }
    ///    },
    ///    "nextPageToken": {
    ///      "$ref": "#/components/schemas/nextPageToken"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "IngestionBatchExecutionsList"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct IngestionBatchExecutionsList {
        pub items: ::std::vec::Vec<IngestionBatchExecution>,
        #[serde(rename = "nextPageToken", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_token: ::std::option::Option<NextPageToken>,
    }

    impl ::std::convert::From<&IngestionBatchExecutionsList> for IngestionBatchExecutionsList {
        fn from(value: &IngestionBatchExecutionsList) -> Self {
            value.clone()
        }
    }

    ///Type of an ingestion childexecution.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Type of an ingestion childexecution.",
    ///  "type": "string",
    ///  "enum": [
    ///    "FULL",
    ///    "INCREMENTAL",
    ///    "PATCH"
    ///  ],
    ///  "x-schema-name": "IngestionChildExecutionType",
    ///  "x-tsEnumNames": [
    ///    "Full",
    ///    "Incremental",
    ///    "Patch"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum IngestionChildExecutionType {
        #[serde(rename = "FULL")]
        Full,
        #[serde(rename = "INCREMENTAL")]
        Incremental,
        #[serde(rename = "PATCH")]
        Patch,
    }

    impl ::std::convert::From<&Self> for IngestionChildExecutionType {
        fn from(value: &IngestionChildExecutionType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for IngestionChildExecutionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Full => f.write_str("FULL"),
                Self::Incremental => f.write_str("INCREMENTAL"),
                Self::Patch => f.write_str("PATCH"),
            }
        }
    }

    impl ::std::str::FromStr for IngestionChildExecutionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "FULL" => Ok(Self::Full),
                "INCREMENTAL" => Ok(Self::Incremental),
                "PATCH" => Ok(Self::Patch),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for IngestionChildExecutionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for IngestionChildExecutionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for IngestionChildExecutionType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///An attempt of an ingestion execution.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An attempt of an ingestion execution.",
    ///  "type": "object",
    ///  "required": [
    ///    "attemptNumber",
    ///    "completionTimestamp",
    ///    "csbIngestionExecutionId",
    ///    "errorMessage",
    ///    "message",
    ///    "startTimestamp"
    ///  ],
    ///  "properties": {
    ///    "attemptNumber": {
    ///      "description": "The attempt number of the ingestion execution
    /// attempt.",
    ///      "type": "number"
    ///    },
    ///    "completionTimestamp": {
    ///      "description": "The completion time of the ingestion execution
    /// attempt in seconds since epoch.",
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "csbIngestionExecutionId": {
    ///      "description": "The ID of the ingestion execution.",
    ///      "type": "string"
    ///    },
    ///    "errorMessage": {
    ///      "description": "The error message of the ingestion execution
    /// attempt.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "ingestionStatus": {
    ///      "$ref": "#/components/schemas/IngestionStatus"
    ///    },
    ///    "latestCheckpointTimestamp": {
    ///      "description": "The timestamp of the latest checkpoint of the
    /// ingestion execution attempt.",
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "rowCountInAttempt": {
    ///      "description": "The total number of rows processed in the ingestion
    /// execution attempt.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "startTimestamp": {
    ///      "description": "The start time of the ingestion execution attempt
    /// in seconds since epoch.",
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "IngestionExecutionAttempt"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct IngestionExecutionAttempt {
        #[serde(rename = "attemptNumber")]
        pub attempt_number: f64,
        ///The completion time of the ingestion execution attempt in seconds
        /// since epoch.
        #[serde(rename = "completionTimestamp")]
        pub completion_timestamp: ::std::option::Option<f64>,
        ///The ID of the ingestion execution.
        #[serde(rename = "csbIngestionExecutionId")]
        pub csb_ingestion_execution_id: ::std::string::String,
        ///The error message of the ingestion execution attempt.
        #[serde(rename = "errorMessage")]
        pub error_message: ::std::option::Option<::std::string::String>,
        #[serde(rename = "ingestionStatus", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub ingestion_status: ::std::option::Option<IngestionStatus>,
        ///The timestamp of the latest checkpoint of the ingestion execution
        /// attempt.
        #[serde(rename = "latestCheckpointTimestamp", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub latest_checkpoint_timestamp: ::std::option::Option<f64>,
        pub message: ::serde_json::Value,
        ///The total number of rows processed in the ingestion execution
        /// attempt.
        #[serde(rename = "rowCountInAttempt", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub row_count_in_attempt: ::std::option::Option<::std::string::String>,
        ///The start time of the ingestion execution attempt in seconds since
        /// epoch.
        #[serde(rename = "startTimestamp")]
        pub start_timestamp: ::std::option::Option<f64>,
    }

    impl ::std::convert::From<&IngestionExecutionAttempt> for IngestionExecutionAttempt {
        fn from(value: &IngestionExecutionAttempt) -> Self {
            value.clone()
        }
    }

    ///List of Ingestion Execution Attempts.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "List of Ingestion Execution Attempts.",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/IngestionExecutionAttempt"
    ///      }
    ///    },
    ///    "nextPageToken": {
    ///      "$ref": "#/components/schemas/nextPageToken"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "IngestionExecutionAttemptsList"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct IngestionExecutionAttemptsList {
        pub items: ::std::vec::Vec<IngestionExecutionAttempt>,
        #[serde(rename = "nextPageToken", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_token: ::std::option::Option<NextPageToken>,
    }

    impl ::std::convert::From<&IngestionExecutionAttemptsList> for IngestionExecutionAttemptsList {
        fn from(value: &IngestionExecutionAttemptsList) -> Self {
            value.clone()
        }
    }

    ///Context that comes with a ingestion execution.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Context that comes with a ingestion execution.",
    ///  "type": "object",
    ///  "required": [
    ///    "attemptNumber",
    ///    "completionTimestamp",
    ///    "creationTimestamp",
    ///    "csbIngestionExecutionId",
    ///    "csbIngestionId",
    ///    "dynamicDisplayName",
    ///    "errorMessage",
    ///    "executionType",
    ///    "ingestionName",
    ///    "ingestionStatus",
    ///    "nextEligibleIncrementalTimestamp",
    ///    "nextEligibleTimestamp",
    ///    "parentItemId",
    ///    "startTimestamp"
    ///  ],
    ///  "properties": {
    ///    "attemptNumber": {
    ///      "description": "The attempt number of the ingestion execution.",
    ///      "type": "number"
    ///    },
    ///    "completionTimestamp": {
    ///      "description": "Completion time of the ingestion execution in
    /// seconds since epoch.",
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "creationTimestamp": {
    ///      "description": "Creation time of the ingestion execution in seconds
    /// since epoch.",
    ///      "type": "number"
    ///    },
    ///    "csbIngestionExecutionId": {
    ///      "type": "string"
    ///    },
    ///    "csbIngestionId": {
    ///      "type": "string"
    ///    },
    ///    "dynamicDisplayName": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "errorMessage": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "executionType": {
    ///      "$ref": "#/components/schemas/IngestionExecutionType"
    ///    },
    ///    "ingestionName": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "ingestionStatus": {
    ///      "$ref": "#/components/schemas/IngestionStatus"
    ///    },
    ///    "latestCheckpointTimestamp": {
    ///      "description": "The timestamp of the latest checkpoint of the
    /// ingestion execution.",
    ///      "type": "number"
    ///    },
    ///    "nextEligibleIncrementalTimestamp": {
    ///      "description": "Next eligible time for the ingestion to run
    /// incrementally in seconds since epoch.",
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "nextEligibleTimestamp": {
    ///      "description": "Next eligible time for the ingestion to run in
    /// seconds since epoch.",
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "parentItemId": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "startTimestamp": {
    ///      "description": "Start time of the ingestion execution in seconds
    /// since epoch.",
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "totalRowCount": {
    ///      "description": "The total number of rows processed in the ingestion
    /// execution.",
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "IngestionExecutionContext"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct IngestionExecutionContext {
        #[serde(rename = "attemptNumber")]
        pub attempt_number: f64,
        ///Completion time of the ingestion execution in seconds since epoch.
        #[serde(rename = "completionTimestamp")]
        pub completion_timestamp: ::std::option::Option<f64>,
        #[serde(rename = "creationTimestamp")]
        pub creation_timestamp: f64,
        #[serde(rename = "csbIngestionExecutionId")]
        pub csb_ingestion_execution_id: ::std::string::String,
        #[serde(rename = "csbIngestionId")]
        pub csb_ingestion_id: ::std::string::String,
        #[serde(rename = "dynamicDisplayName")]
        pub dynamic_display_name: ::std::option::Option<::std::string::String>,
        #[serde(rename = "errorMessage")]
        pub error_message: ::std::option::Option<::std::string::String>,
        #[serde(rename = "executionType")]
        pub execution_type: IngestionExecutionType,
        #[serde(rename = "ingestionName")]
        pub ingestion_name: ::std::option::Option<::std::string::String>,
        #[serde(rename = "ingestionStatus")]
        pub ingestion_status: IngestionStatus,
        #[serde(rename = "latestCheckpointTimestamp", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub latest_checkpoint_timestamp: ::std::option::Option<f64>,
        ///Next eligible time for the ingestion to run incrementally in seconds
        /// since epoch.
        #[serde(rename = "nextEligibleIncrementalTimestamp")]
        pub next_eligible_incremental_timestamp: ::std::option::Option<f64>,
        ///Next eligible time for the ingestion to run in seconds since epoch.
        #[serde(rename = "nextEligibleTimestamp")]
        pub next_eligible_timestamp: ::std::option::Option<f64>,
        #[serde(rename = "parentItemId")]
        pub parent_item_id: ::std::option::Option<::std::string::String>,
        ///Start time of the ingestion execution in seconds since epoch.
        #[serde(rename = "startTimestamp")]
        pub start_timestamp: ::std::option::Option<f64>,
        ///The total number of rows processed in the ingestion execution.
        #[serde(rename = "totalRowCount", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub total_row_count: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&IngestionExecutionContext> for IngestionExecutionContext {
        fn from(value: &IngestionExecutionContext) -> Self {
            value.clone()
        }
    }

    ///Type of an ingestion batch execution.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Type of an ingestion batch execution.",
    ///  "type": "string",
    ///  "enum": [
    ///    "FULL",
    ///    "INCREMENTAL"
    ///  ],
    ///  "x-schema-name": "IngestionExecutionType",
    ///  "x-tsEnumNames": [
    ///    "Full",
    ///    "Incremental"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum IngestionExecutionType {
        #[serde(rename = "FULL")]
        Full,
        #[serde(rename = "INCREMENTAL")]
        Incremental,
    }

    impl ::std::convert::From<&Self> for IngestionExecutionType {
        fn from(value: &IngestionExecutionType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for IngestionExecutionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Full => f.write_str("FULL"),
                Self::Incremental => f.write_str("INCREMENTAL"),
            }
        }
    }

    impl ::std::str::FromStr for IngestionExecutionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "FULL" => Ok(Self::Full),
                "INCREMENTAL" => Ok(Self::Incremental),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for IngestionExecutionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for IngestionExecutionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for IngestionExecutionType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///List of Ingestion Executions.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "List of Ingestion Executions.",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/IngestionExecutionContext"
    ///      }
    ///    },
    ///    "nextPageToken": {
    ///      "$ref": "#/components/schemas/nextPageToken"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "IngestionExecutionsList"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct IngestionExecutionsList {
        pub items: ::std::vec::Vec<IngestionExecutionContext>,
        #[serde(rename = "nextPageToken", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_token: ::std::option::Option<NextPageToken>,
    }

    impl ::std::convert::From<&IngestionExecutionsList> for IngestionExecutionsList {
        fn from(value: &IngestionExecutionsList) -> Self {
            value.clone()
        }
    }

    ///Limits for a pack-driven ingestion
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Limits for a pack-driven ingestion",
    ///  "type": "object",
    ///  "required": [
    ///    "allowedTablesCount",
    ///    "maxBytesPerSyncTableDefault"
    ///  ],
    ///  "properties": {
    ///    "allowedTablesCount": {
    ///      "description": "The maximum number of tables that can be included.
    /// -1 means no limit.",
    ///      "type": "number"
    ///    },
    ///    "maxBytesPerSyncTableDefault": {
    ///      "description": "The default bytes limit when ingesting data for a
    /// table in the pack. null means no limit.",
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "tableSettings": {
    ///      "description": "Map from table name to per table settings. This may
    /// not include every table in the pack. Each setting per table will include
    /// an optional maxBytesPerSyncTableOverride that will override the default,
    /// an optional excludeIngestionByDefault flag, and an optional
    /// parameterLimits dictionary of allowed parameter values.\n",
    ///      "type": "object",
    ///      "additionalProperties": {
    ///        "$ref": "#/components/schemas/IngestionTableSetting"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "IngestionLimitSettings"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct IngestionLimitSettings {
        #[serde(rename = "allowedTablesCount")]
        pub allowed_tables_count: f64,
        ///The default bytes limit when ingesting data for a table in the pack.
        /// null means no limit.
        #[serde(rename = "maxBytesPerSyncTableDefault")]
        pub max_bytes_per_sync_table_default: ::std::option::Option<f64>,
        ///Map from table name to per table settings. This may not include
        /// every table in the pack. Each setting per table will include an
        /// optional maxBytesPerSyncTableOverride that will override the
        /// default, an optional excludeIngestionByDefault flag, and an optional
        /// parameterLimits dictionary of allowed parameter values.
        #[serde(rename = "tableSettings", default, skip_serializing_if = ":: std :: collections :: HashMap::is_empty")]
        pub table_settings: ::std::collections::HashMap<::std::string::String, IngestionTableSetting>,
    }

    impl ::std::convert::From<&IngestionLimitSettings> for IngestionLimitSettings {
        fn from(value: &IngestionLimitSettings) -> Self {
            value.clone()
        }
    }

    ///Live or Latest version of pack
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Live or Latest version of pack",
    ///  "type": "string",
    ///  "enum": [
    ///    "LIVE",
    ///    "LATEST"
    ///  ],
    ///  "x-schema-name": "IngestionPackReleaseChannel",
    ///  "x-tsEnumNames": [
    ///    "Live",
    ///    "Latest"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum IngestionPackReleaseChannel {
        #[serde(rename = "LIVE")]
        Live,
        #[serde(rename = "LATEST")]
        Latest,
    }

    impl ::std::convert::From<&Self> for IngestionPackReleaseChannel {
        fn from(value: &IngestionPackReleaseChannel) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for IngestionPackReleaseChannel {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Live => f.write_str("LIVE"),
                Self::Latest => f.write_str("LATEST"),
            }
        }
    }

    impl ::std::str::FromStr for IngestionPackReleaseChannel {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "LIVE" => Ok(Self::Live),
                "LATEST" => Ok(Self::Latest),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for IngestionPackReleaseChannel {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for IngestionPackReleaseChannel {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for IngestionPackReleaseChannel {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///An ingestion parent item and its execution state (either full or
    /// incremental).
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ingestion parent item and its execution state
    /// (either full or incremental).",
    ///  "type": "object",
    ///  "required": [
    ///    "completionTimestamp",
    ///    "creationTimestamp",
    ///    "errorMessage",
    ///    "executionType",
    ///    "ingestionExecutionId",
    ///    "ingestionName",
    ///    "parentItemId",
    ///    "startTimestamp"
    ///  ],
    ///  "properties": {
    ///    "attemptNumber": {
    ///      "description": "The attempt number of the ingestion child
    /// execution.",
    ///      "type": "number"
    ///    },
    ///    "completionTimestamp": {
    ///      "description": "Completion time of the ingestion child execution in
    /// seconds since epoch.",
    ///      "type": "number"
    ///    },
    ///    "errorMessage": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "executionType": {
    ///      "$ref": "#/components/schemas/IngestionChildExecutionType"
    ///    },
    ///    "ingestionChildExecutionIndex": {
    ///      "description": "Current execution index for this parent item's
    /// child execution.",
    ///      "type": "number"
    ///    },
    ///    "ingestionExecutionId": {
    ///      "description": "The ID of the ingestion child execution.",
    ///      "type": "string"
    ///    },
    ///    "ingestionName": {
    ///      "description": "The name of the ingestion child execution.",
    ///      "type": "string"
    ///    },
    ///    "ingestionStatus": {
    ///      "$ref": "#/components/schemas/IngestionStatus"
    ///    },
    ///    "latestCheckpointTimestamp": {
    ///      "description": "The timestamp of the latest checkpoint of the
    /// ingestion child execution.",
    ///      "type": "number"
    ///    },
    ///    "parentItemId": {
    ///      "description": "The ID of the parent item.",
    ///      "type": "string"
    ///    },
    ///    "rowCount": {
    ///      "description": "The number of rows processed so far in the current
    /// ingestion child execution.",
    ///      "type": "number"
    ///    },
    ///    "startTimestamp": {
    ///      "description": "Start time of the ingestion child execution in
    /// seconds since epoch.",
    ///      "type": "number"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "IngestionParentItem"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct IngestionParentItem {
        #[serde(rename = "attemptNumber", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub attempt_number: ::std::option::Option<f64>,
        #[serde(rename = "completionTimestamp")]
        pub completion_timestamp: f64,
        #[serde(rename = "creationTimestamp")]
        pub creation_timestamp: ::serde_json::Value,
        #[serde(rename = "errorMessage")]
        pub error_message: ::std::option::Option<::std::string::String>,
        #[serde(rename = "executionType")]
        pub execution_type: IngestionChildExecutionType,
        #[serde(rename = "ingestionChildExecutionIndex", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub ingestion_child_execution_index: ::std::option::Option<f64>,
        ///The ID of the ingestion child execution.
        #[serde(rename = "ingestionExecutionId")]
        pub ingestion_execution_id: ::std::string::String,
        ///The name of the ingestion child execution.
        #[serde(rename = "ingestionName")]
        pub ingestion_name: ::std::string::String,
        #[serde(rename = "ingestionStatus", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub ingestion_status: ::std::option::Option<IngestionStatus>,
        #[serde(rename = "latestCheckpointTimestamp", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub latest_checkpoint_timestamp: ::std::option::Option<f64>,
        ///The ID of the parent item.
        #[serde(rename = "parentItemId")]
        pub parent_item_id: ::std::string::String,
        #[serde(rename = "rowCount", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub row_count: ::std::option::Option<f64>,
        #[serde(rename = "startTimestamp")]
        pub start_timestamp: f64,
    }

    impl ::std::convert::From<&IngestionParentItem> for IngestionParentItem {
        fn from(value: &IngestionParentItem) -> Self {
            value.clone()
        }
    }

    ///List of Ingestion Parent Items.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "List of Ingestion Parent Items.",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/IngestionParentItem"
    ///      }
    ///    },
    ///    "nextPageToken": {
    ///      "$ref": "#/components/schemas/nextPageToken"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "IngestionParentItemsList"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct IngestionParentItemsList {
        pub items: ::std::vec::Vec<IngestionParentItem>,
        #[serde(rename = "nextPageToken", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_token: ::std::option::Option<NextPageToken>,
    }

    impl ::std::convert::From<&IngestionParentItemsList> for IngestionParentItemsList {
        fn from(value: &IngestionParentItemsList) -> Self {
            value.clone()
        }
    }

    ///Status of the ingestion execution.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Status of the ingestion execution.",
    ///  "type": "string",
    ///  "enum": [
    ///    "QUEUED",
    ///    "STARTED",
    ///    "CANCELLED",
    ///    "UP_FOR_RETRY",
    ///    "COMPLETED",
    ///    "FAILED"
    ///  ],
    ///  "x-schema-name": "IngestionStatus",
    ///  "x-tsEnumNames": [
    ///    "Queued",
    ///    "Started",
    ///    "Cancelled",
    ///    "UpForRetry",
    ///    "Completed",
    ///    "Failed"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum IngestionStatus {
        #[serde(rename = "QUEUED")]
        Queued,
        #[serde(rename = "STARTED")]
        Started,
        #[serde(rename = "CANCELLED")]
        Cancelled,
        #[serde(rename = "UP_FOR_RETRY")]
        UpForRetry,
        #[serde(rename = "COMPLETED")]
        Completed,
        #[serde(rename = "FAILED")]
        Failed,
    }

    impl ::std::convert::From<&Self> for IngestionStatus {
        fn from(value: &IngestionStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for IngestionStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Queued => f.write_str("QUEUED"),
                Self::Started => f.write_str("STARTED"),
                Self::Cancelled => f.write_str("CANCELLED"),
                Self::UpForRetry => f.write_str("UP_FOR_RETRY"),
                Self::Completed => f.write_str("COMPLETED"),
                Self::Failed => f.write_str("FAILED"),
            }
        }
    }

    impl ::std::str::FromStr for IngestionStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "QUEUED" => Ok(Self::Queued),
                "STARTED" => Ok(Self::Started),
                "CANCELLED" => Ok(Self::Cancelled),
                "UP_FOR_RETRY" => Ok(Self::UpForRetry),
                "COMPLETED" => Ok(Self::Completed),
                "FAILED" => Ok(Self::Failed),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for IngestionStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for IngestionStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for IngestionStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Ingestion settings for a specific table
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Ingestion settings for a specific table",
    ///  "type": "object",
    ///  "properties": {
    ///    "excludeIngestionByDefault": {
    ///      "description": "Whether to exclude this table from ingestions by
    /// default.",
    ///      "type": "boolean"
    ///    },
    ///    "maxBytesPerSyncTableOverride": {
    ///      "description": "The bytes limit when ingesting data for this table.
    /// null means no limit.",
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "parameterLimits": {
    ///      "description": "Limits for allowed parameter values.",
    ///      "type": "object",
    ///      "additionalProperties": {
    ///        "$ref": "#/components/schemas/ParameterSetting"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "IngestionTableSetting"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct IngestionTableSetting {
        ///Whether to exclude this table from ingestions by default.
        #[serde(rename = "excludeIngestionByDefault", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub exclude_ingestion_by_default: ::std::option::Option<bool>,
        ///The bytes limit when ingesting data for this table. null means no
        /// limit.
        #[serde(rename = "maxBytesPerSyncTableOverride", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub max_bytes_per_sync_table_override: ::std::option::Option<f64>,
        ///Limits for allowed parameter values.
        #[serde(rename = "parameterLimits", default, skip_serializing_if = ":: std :: collections :: HashMap::is_empty")]
        pub parameter_limits: ::std::collections::HashMap<::std::string::String, ParameterSetting>,
    }

    impl ::std::convert::From<&IngestionTableSetting> for IngestionTableSetting {
        fn from(value: &IngestionTableSetting) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for IngestionTableSetting {
        fn default() -> Self {
            Self {
                exclude_ingestion_by_default: Default::default(),
                max_bytes_per_sync_table_override: Default::default(),
                parameter_limits: Default::default(),
            }
        }
    }

    ///Layout type of the table or view.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Layout type of the table or view.",
    ///  "type": "string",
    ///  "enum": [
    ///    "default",
    ///    "areaChart",
    ///    "barChart",
    ///    "bubbleChart",
    ///    "calendar",
    ///    "card",
    ///    "detail",
    ///    "form",
    ///    "ganttChart",
    ///    "lineChart",
    ///    "masterDetail",
    ///    "pieChart",
    ///    "scatterChart",
    ///    "slide",
    ///    "wordCloud"
    ///  ],
    ///  "x-schema-name": "Layout",
    ///  "x-tsEnumNames": [
    ///    "Default",
    ///    "AreaChart",
    ///    "BarChart",
    ///    "BubbleChart",
    ///    "Calendar",
    ///    "Card",
    ///    "Detail",
    ///    "Form",
    ///    "GanttChart",
    ///    "LineChart",
    ///    "MasterDetail",
    ///    "PieChart",
    ///    "ScatterChart",
    ///    "Slide",
    ///    "WordCloud"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum Layout {
        #[serde(rename = "default")]
        Default,
        #[serde(rename = "areaChart")]
        AreaChart,
        #[serde(rename = "barChart")]
        BarChart,
        #[serde(rename = "bubbleChart")]
        BubbleChart,
        #[serde(rename = "calendar")]
        Calendar,
        #[serde(rename = "card")]
        Card,
        #[serde(rename = "detail")]
        Detail,
        #[serde(rename = "form")]
        Form,
        #[serde(rename = "ganttChart")]
        GanttChart,
        #[serde(rename = "lineChart")]
        LineChart,
        #[serde(rename = "masterDetail")]
        MasterDetail,
        #[serde(rename = "pieChart")]
        PieChart,
        #[serde(rename = "scatterChart")]
        ScatterChart,
        #[serde(rename = "slide")]
        Slide,
        #[serde(rename = "wordCloud")]
        WordCloud,
    }

    impl ::std::convert::From<&Self> for Layout {
        fn from(value: &Layout) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for Layout {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Default => f.write_str("default"),
                Self::AreaChart => f.write_str("areaChart"),
                Self::BarChart => f.write_str("barChart"),
                Self::BubbleChart => f.write_str("bubbleChart"),
                Self::Calendar => f.write_str("calendar"),
                Self::Card => f.write_str("card"),
                Self::Detail => f.write_str("detail"),
                Self::Form => f.write_str("form"),
                Self::GanttChart => f.write_str("ganttChart"),
                Self::LineChart => f.write_str("lineChart"),
                Self::MasterDetail => f.write_str("masterDetail"),
                Self::PieChart => f.write_str("pieChart"),
                Self::ScatterChart => f.write_str("scatterChart"),
                Self::Slide => f.write_str("slide"),
                Self::WordCloud => f.write_str("wordCloud"),
            }
        }
    }

    impl ::std::str::FromStr for Layout {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "default" => Ok(Self::Default),
                "areaChart" => Ok(Self::AreaChart),
                "barChart" => Ok(Self::BarChart),
                "bubbleChart" => Ok(Self::BubbleChart),
                "calendar" => Ok(Self::Calendar),
                "card" => Ok(Self::Card),
                "detail" => Ok(Self::Detail),
                "form" => Ok(Self::Form),
                "ganttChart" => Ok(Self::GanttChart),
                "lineChart" => Ok(Self::LineChart),
                "masterDetail" => Ok(Self::MasterDetail),
                "pieChart" => Ok(Self::PieChart),
                "scatterChart" => Ok(Self::ScatterChart),
                "slide" => Ok(Self::Slide),
                "wordCloud" => Ok(Self::WordCloud),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for Layout {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for Layout {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for Layout {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkColumnFormat`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Format of a link column.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/SimpleColumnFormat"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "display": {
    ///          "$ref": "#/components/schemas/LinkDisplayType"
    ///        },
    ///        "force": {
    ///          "description": "Force embeds to render on the client instead of
    /// the server (for sites that require user login).",
    ///          "examples": [
    ///            true
    ///          ],
    ///          "type": "boolean"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  ],
    ///  "x-schema-name": "LinkColumnFormat"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(deny_unknown_fields)]
    pub enum LinkColumnFormat {}
    impl ::std::convert::From<&Self> for LinkColumnFormat {
        fn from(value: &LinkColumnFormat) -> Self {
            value.clone()
        }
    }

    ///How a link should be displayed in the user interface.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "How a link should be displayed in the user interface.",
    ///  "type": "string",
    ///  "enum": [
    ///    "iconOnly",
    ///    "url",
    ///    "title",
    ///    "card",
    ///    "embed"
    ///  ],
    ///  "x-schema-name": "LinkDisplayType",
    ///  "x-tsEnumNames": [
    ///    "IconOnly",
    ///    "Url",
    ///    "Title",
    ///    "Card",
    ///    "Embed"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum LinkDisplayType {
        #[serde(rename = "iconOnly")]
        IconOnly,
        #[serde(rename = "url")]
        Url,
        #[serde(rename = "title")]
        Title,
        #[serde(rename = "card")]
        Card,
        #[serde(rename = "embed")]
        Embed,
    }

    impl ::std::convert::From<&Self> for LinkDisplayType {
        fn from(value: &LinkDisplayType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkDisplayType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::IconOnly => f.write_str("iconOnly"),
                Self::Url => f.write_str("url"),
                Self::Title => f.write_str("title"),
                Self::Card => f.write_str("card"),
                Self::Embed => f.write_str("embed"),
            }
        }
    }

    impl ::std::str::FromStr for LinkDisplayType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "iconOnly" => Ok(Self::IconOnly),
                "url" => Ok(Self::Url),
                "title" => Ok(Self::Title),
                "card" => Ok(Self::Card),
                "embed" => Ok(Self::Embed),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkDisplayType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkDisplayType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkDisplayType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Base type for a JSON-LD (Linked Data) object.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Base type for a JSON-LD (Linked Data) object.",
    ///  "type": "object",
    ///  "required": [
    ///    "@context",
    ///    "@type"
    ///  ],
    ///  "properties": {
    ///    "@context": {
    ///      "description": "A url describing the schema context for this object, typically \"http://schema.org/\".",
    ///      "examples": [
    ///        "http://schema.org/"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "@type": {
    ///      "$ref": "#/components/schemas/LinkedDataType"
    ///    },
    ///    "additionalType": {
    ///      "description": "An identifier of additional type info specific to
    /// Coda that may not be present in a schema.org taxonomy,\n",
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "LinkedDataObject"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct LinkedDataObject {
        ///An identifier of additional type info specific to Coda that may not
        /// be present in a schema.org taxonomy,
        #[serde(rename = "additionalType", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub additional_type: ::std::option::Option<::std::string::String>,
        ///A url describing the schema context for this object, typically "http://schema.org/".
        #[serde(rename = "@context")]
        pub context: ::std::string::String,
        #[serde(rename = "@type")]
        pub type_: LinkedDataType,
    }

    impl ::std::convert::From<&LinkedDataObject> for LinkedDataObject {
        fn from(value: &LinkedDataObject) -> Self {
            value.clone()
        }
    }

    ///A schema.org identifier for the object.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A schema.org identifier for the object.",
    ///  "type": "string",
    ///  "enum": [
    ///    "ImageObject",
    ///    "MonetaryAmount",
    ///    "Person",
    ///    "WebPage",
    ///    "StructuredValue"
    ///  ],
    ///  "x-schema-name": "LinkedDataType",
    ///  "x-tsEnumNames": [
    ///    "ImageObject",
    ///    "MonetaryAmount",
    ///    "Person",
    ///    "WebPage",
    ///    "StructuredValue"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum LinkedDataType {
        ImageObject,
        MonetaryAmount,
        Person,
        WebPage,
        StructuredValue,
    }

    impl ::std::convert::From<&Self> for LinkedDataType {
        fn from(value: &LinkedDataType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedDataType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::ImageObject => f.write_str("ImageObject"),
                Self::MonetaryAmount => f.write_str("MonetaryAmount"),
                Self::Person => f.write_str("Person"),
                Self::WebPage => f.write_str("WebPage"),
                Self::StructuredValue => f.write_str("StructuredValue"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedDataType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ImageObject" => Ok(Self::ImageObject),
                "MonetaryAmount" => Ok(Self::MonetaryAmount),
                "Person" => Ok(Self::Person),
                "WebPage" => Ok(Self::WebPage),
                "StructuredValue" => Ok(Self::StructuredValue),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedDataType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedDataType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedDataType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        401
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListCategoriesResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&ListCategoriesResponse> for ListCategoriesResponse {
        fn from(value: &ListCategoriesResponse) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        401
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListColumnsResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&ListColumnsResponse> for ListColumnsResponse {
        fn from(value: &ListColumnsResponse) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        401
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListControlsResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&ListControlsResponse> for ListControlsResponse {
        fn from(value: &ListControlsResponse) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        401
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListCustomDocDomainsResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&ListCustomDocDomainsResponse> for ListCustomDocDomainsResponse {
        fn from(value: &ListCustomDocDomainsResponse) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        401
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListDocAnalyticsResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&ListDocAnalyticsResponse> for ListDocAnalyticsResponse {
        fn from(value: &ListDocAnalyticsResponse) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        401
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListDocAnalyticsSummaryResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&ListDocAnalyticsSummaryResponse> for ListDocAnalyticsSummaryResponse {
        fn from(value: &ListDocAnalyticsSummaryResponse) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        401
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListDocsResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&ListDocsResponse> for ListDocsResponse {
        fn from(value: &ListDocsResponse) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        401
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListFormulasResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&ListFormulasResponse> for ListFormulasResponse {
        fn from(value: &ListFormulasResponse) -> Self {
            value.clone()
        }
    }

    ///`ListGroupedIngestionLogsOrder`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "asc",
    ///    "desc"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum ListGroupedIngestionLogsOrder {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }

    impl ::std::convert::From<&Self> for ListGroupedIngestionLogsOrder {
        fn from(value: &ListGroupedIngestionLogsOrder) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ListGroupedIngestionLogsOrder {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Asc => f.write_str("asc"),
                Self::Desc => f.write_str("desc"),
            }
        }
    }

    impl ::std::str::FromStr for ListGroupedIngestionLogsOrder {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "asc" => Ok(Self::Asc),
                "desc" => Ok(Self::Desc),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ListGroupedIngestionLogsOrder {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ListGroupedIngestionLogsOrder {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ListGroupedIngestionLogsOrder {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "codaDetail": {
    ///      "description": "Detail about why this request was rejected.",
    ///      "type": "object",
    ///      "properties": {
    ///        "validationErrors": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/ValidationError"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    },
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListGroupedIngestionLogsResponse {
        #[serde(rename = "codaDetail", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub coda_detail: ::std::option::Option<ListGroupedIngestionLogsResponseCodaDetail>,
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&ListGroupedIngestionLogsResponse> for ListGroupedIngestionLogsResponse {
        fn from(value: &ListGroupedIngestionLogsResponse) -> Self {
            value.clone()
        }
    }

    ///Detail about why this request was rejected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why this request was rejected.",
    ///  "type": "object",
    ///  "properties": {
    ///    "validationErrors": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListGroupedIngestionLogsResponseCodaDetail {
        #[serde(rename = "validationErrors", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub validation_errors: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&ListGroupedIngestionLogsResponseCodaDetail> for ListGroupedIngestionLogsResponseCodaDetail {
        fn from(value: &ListGroupedIngestionLogsResponseCodaDetail) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListGroupedIngestionLogsResponseCodaDetail {
        fn default() -> Self {
            Self {
                validation_errors: Default::default(),
            }
        }
    }

    ///`ListGroupedPackLogsOrder`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "asc",
    ///    "desc"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum ListGroupedPackLogsOrder {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }

    impl ::std::convert::From<&Self> for ListGroupedPackLogsOrder {
        fn from(value: &ListGroupedPackLogsOrder) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ListGroupedPackLogsOrder {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Asc => f.write_str("asc"),
                Self::Desc => f.write_str("desc"),
            }
        }
    }

    impl ::std::str::FromStr for ListGroupedPackLogsOrder {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "asc" => Ok(Self::Asc),
                "desc" => Ok(Self::Desc),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ListGroupedPackLogsOrder {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ListGroupedPackLogsOrder {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ListGroupedPackLogsOrder {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "codaDetail": {
    ///      "description": "Detail about why this request was rejected.",
    ///      "type": "object",
    ///      "properties": {
    ///        "validationErrors": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/ValidationError"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    },
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListGroupedPackLogsResponse {
        #[serde(rename = "codaDetail", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub coda_detail: ::std::option::Option<ListGroupedPackLogsResponseCodaDetail>,
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&ListGroupedPackLogsResponse> for ListGroupedPackLogsResponse {
        fn from(value: &ListGroupedPackLogsResponse) -> Self {
            value.clone()
        }
    }

    ///Detail about why this request was rejected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why this request was rejected.",
    ///  "type": "object",
    ///  "properties": {
    ///    "validationErrors": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListGroupedPackLogsResponseCodaDetail {
        #[serde(rename = "validationErrors", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub validation_errors: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&ListGroupedPackLogsResponseCodaDetail> for ListGroupedPackLogsResponseCodaDetail {
        fn from(value: &ListGroupedPackLogsResponseCodaDetail) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListGroupedPackLogsResponseCodaDetail {
        fn default() -> Self {
            Self {
                validation_errors: Default::default(),
            }
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "codaDetail": {
    ///      "description": "Detail about why this request was rejected.",
    ///      "type": "object",
    ///      "properties": {
    ///        "validationErrors": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/ValidationError"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    },
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListIngestionBatchExecutionsResponse {
        #[serde(rename = "codaDetail", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub coda_detail: ::std::option::Option<ListIngestionBatchExecutionsResponseCodaDetail>,
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&ListIngestionBatchExecutionsResponse> for ListIngestionBatchExecutionsResponse {
        fn from(value: &ListIngestionBatchExecutionsResponse) -> Self {
            value.clone()
        }
    }

    ///Detail about why this request was rejected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why this request was rejected.",
    ///  "type": "object",
    ///  "properties": {
    ///    "validationErrors": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListIngestionBatchExecutionsResponseCodaDetail {
        #[serde(rename = "validationErrors", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub validation_errors: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&ListIngestionBatchExecutionsResponseCodaDetail> for ListIngestionBatchExecutionsResponseCodaDetail {
        fn from(value: &ListIngestionBatchExecutionsResponseCodaDetail) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListIngestionBatchExecutionsResponseCodaDetail {
        fn default() -> Self {
            Self {
                validation_errors: Default::default(),
            }
        }
    }

    ///`ListIngestionLogsOrder`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "asc",
    ///    "desc"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum ListIngestionLogsOrder {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }

    impl ::std::convert::From<&Self> for ListIngestionLogsOrder {
        fn from(value: &ListIngestionLogsOrder) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ListIngestionLogsOrder {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Asc => f.write_str("asc"),
                Self::Desc => f.write_str("desc"),
            }
        }
    }

    impl ::std::str::FromStr for ListIngestionLogsOrder {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "asc" => Ok(Self::Asc),
                "desc" => Ok(Self::Desc),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ListIngestionLogsOrder {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ListIngestionLogsOrder {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ListIngestionLogsOrder {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "codaDetail": {
    ///      "description": "Detail about why this request was rejected.",
    ///      "type": "object",
    ///      "properties": {
    ///        "validationErrors": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/ValidationError"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    },
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListIngestionLogsResponse {
        #[serde(rename = "codaDetail", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub coda_detail: ::std::option::Option<ListIngestionLogsResponseCodaDetail>,
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&ListIngestionLogsResponse> for ListIngestionLogsResponse {
        fn from(value: &ListIngestionLogsResponse) -> Self {
            value.clone()
        }
    }

    ///Detail about why this request was rejected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why this request was rejected.",
    ///  "type": "object",
    ///  "properties": {
    ///    "validationErrors": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListIngestionLogsResponseCodaDetail {
        #[serde(rename = "validationErrors", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub validation_errors: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&ListIngestionLogsResponseCodaDetail> for ListIngestionLogsResponseCodaDetail {
        fn from(value: &ListIngestionLogsResponseCodaDetail) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListIngestionLogsResponseCodaDetail {
        fn default() -> Self {
            Self {
                validation_errors: Default::default(),
            }
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "codaDetail": {
    ///      "description": "Detail about why this request was rejected.",
    ///      "type": "object",
    ///      "properties": {
    ///        "validationErrors": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/ValidationError"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    },
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListIngestionParentItemsResponse {
        #[serde(rename = "codaDetail", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub coda_detail: ::std::option::Option<ListIngestionParentItemsResponseCodaDetail>,
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&ListIngestionParentItemsResponse> for ListIngestionParentItemsResponse {
        fn from(value: &ListIngestionParentItemsResponse) -> Self {
            value.clone()
        }
    }

    ///Detail about why this request was rejected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why this request was rejected.",
    ///  "type": "object",
    ///  "properties": {
    ///    "validationErrors": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListIngestionParentItemsResponseCodaDetail {
        #[serde(rename = "validationErrors", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub validation_errors: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&ListIngestionParentItemsResponseCodaDetail> for ListIngestionParentItemsResponseCodaDetail {
        fn from(value: &ListIngestionParentItemsResponseCodaDetail) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListIngestionParentItemsResponseCodaDetail {
        fn default() -> Self {
            Self {
                validation_errors: Default::default(),
            }
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        401
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListPackAnalyticsResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&ListPackAnalyticsResponse> for ListPackAnalyticsResponse {
        fn from(value: &ListPackAnalyticsResponse) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        401
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListPackAnalyticsSummaryResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&ListPackAnalyticsSummaryResponse> for ListPackAnalyticsSummaryResponse {
        fn from(value: &ListPackAnalyticsSummaryResponse) -> Self {
            value.clone()
        }
    }

    ///Confirmation of successfully retrieving Pack categories.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Confirmation of successfully retrieving Pack
    /// categories.",
    ///  "type": "object",
    ///  "required": [
    ///    "categories"
    ///  ],
    ///  "properties": {
    ///    "categories": {
    ///      "description": "The names of categories associated with a Pack.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PublishingCategory"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "ListPackCategoriesResponse"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListPackCategoriesResponse {
        ///The names of categories associated with a Pack.
        pub categories: ::std::vec::Vec<PublishingCategory>,
    }

    impl ::std::convert::From<&ListPackCategoriesResponse> for ListPackCategoriesResponse {
        fn from(value: &ListPackCategoriesResponse) -> Self {
            value.clone()
        }
    }

    ///Detail about why this request was rejected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why this request was rejected.",
    ///  "type": "object",
    ///  "properties": {
    ///    "validationErrors": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListPackCategoriesResponseCodaDetail {
        #[serde(rename = "validationErrors", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub validation_errors: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&ListPackCategoriesResponseCodaDetail> for ListPackCategoriesResponseCodaDetail {
        fn from(value: &ListPackCategoriesResponseCodaDetail) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListPackCategoriesResponseCodaDetail {
        fn default() -> Self {
            Self {
                validation_errors: Default::default(),
            }
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListPackFeaturedDocsResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&ListPackFeaturedDocsResponse> for ListPackFeaturedDocsResponse {
        fn from(value: &ListPackFeaturedDocsResponse) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        401
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListPackFormulaAnalyticsResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&ListPackFormulaAnalyticsResponse> for ListPackFormulaAnalyticsResponse {
        fn from(value: &ListPackFormulaAnalyticsResponse) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "codaDetail": {
    ///      "description": "Detail about why this request was rejected.",
    ///      "type": "object",
    ///      "properties": {
    ///        "validationErrors": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/ValidationError"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    },
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListPackListingsResponse {
        #[serde(rename = "codaDetail", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub coda_detail: ::std::option::Option<ListPackListingsResponseCodaDetail>,
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&ListPackListingsResponse> for ListPackListingsResponse {
        fn from(value: &ListPackListingsResponse) -> Self {
            value.clone()
        }
    }

    ///Detail about why this request was rejected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why this request was rejected.",
    ///  "type": "object",
    ///  "properties": {
    ///    "validationErrors": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListPackListingsResponseCodaDetail {
        #[serde(rename = "validationErrors", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub validation_errors: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&ListPackListingsResponseCodaDetail> for ListPackListingsResponseCodaDetail {
        fn from(value: &ListPackListingsResponseCodaDetail) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListPackListingsResponseCodaDetail {
        fn default() -> Self {
            Self {
                validation_errors: Default::default(),
            }
        }
    }

    ///`ListPackLogsOrder`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "asc",
    ///    "desc"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum ListPackLogsOrder {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }

    impl ::std::convert::From<&Self> for ListPackLogsOrder {
        fn from(value: &ListPackLogsOrder) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ListPackLogsOrder {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Asc => f.write_str("asc"),
                Self::Desc => f.write_str("desc"),
            }
        }
    }

    impl ::std::str::FromStr for ListPackLogsOrder {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "asc" => Ok(Self::Asc),
                "desc" => Ok(Self::Desc),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ListPackLogsOrder {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ListPackLogsOrder {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ListPackLogsOrder {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "codaDetail": {
    ///      "description": "Detail about why this request was rejected.",
    ///      "type": "object",
    ///      "properties": {
    ///        "validationErrors": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/ValidationError"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    },
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListPackLogsResponse {
        #[serde(rename = "codaDetail", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub coda_detail: ::std::option::Option<ListPackLogsResponseCodaDetail>,
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&ListPackLogsResponse> for ListPackLogsResponse {
        fn from(value: &ListPackLogsResponse) -> Self {
            value.clone()
        }
    }

    ///Detail about why this request was rejected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why this request was rejected.",
    ///  "type": "object",
    ///  "properties": {
    ///    "validationErrors": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListPackLogsResponseCodaDetail {
        #[serde(rename = "validationErrors", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub validation_errors: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&ListPackLogsResponseCodaDetail> for ListPackLogsResponseCodaDetail {
        fn from(value: &ListPackLogsResponseCodaDetail) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListPackLogsResponseCodaDetail {
        fn default() -> Self {
            Self {
                validation_errors: Default::default(),
            }
        }
    }

    ///Confirmation of successfully retrieving Pack makers.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Confirmation of successfully retrieving Pack makers.",
    ///  "type": "object",
    ///  "required": [
    ///    "makers"
    ///  ],
    ///  "properties": {
    ///    "makers": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Maker"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "ListPackMakersResponse"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListPackMakersResponse {
        pub makers: ::std::vec::Vec<Maker>,
    }

    impl ::std::convert::From<&ListPackMakersResponse> for ListPackMakersResponse {
        fn from(value: &ListPackMakersResponse) -> Self {
            value.clone()
        }
    }

    ///Detail about why this request was rejected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why this request was rejected.",
    ///  "type": "object",
    ///  "properties": {
    ///    "validationErrors": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListPackMakersResponseCodaDetail {
        #[serde(rename = "validationErrors", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub validation_errors: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&ListPackMakersResponseCodaDetail> for ListPackMakersResponseCodaDetail {
        fn from(value: &ListPackMakersResponseCodaDetail) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListPackMakersResponseCodaDetail {
        fn default() -> Self {
            Self {
                validation_errors: Default::default(),
            }
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "codaDetail": {
    ///      "description": "Detail about why this request was rejected.",
    ///      "type": "object",
    ///      "properties": {
    ///        "validationErrors": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/ValidationError"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    },
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListPackReleasesResponse {
        #[serde(rename = "codaDetail", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub coda_detail: ::std::option::Option<ListPackReleasesResponseCodaDetail>,
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&ListPackReleasesResponse> for ListPackReleasesResponse {
        fn from(value: &ListPackReleasesResponse) -> Self {
            value.clone()
        }
    }

    ///Detail about why this request was rejected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why this request was rejected.",
    ///  "type": "object",
    ///  "properties": {
    ///    "validationErrors": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListPackReleasesResponseCodaDetail {
        #[serde(rename = "validationErrors", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub validation_errors: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&ListPackReleasesResponseCodaDetail> for ListPackReleasesResponseCodaDetail {
        fn from(value: &ListPackReleasesResponseCodaDetail) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListPackReleasesResponseCodaDetail {
        fn default() -> Self {
            Self {
                validation_errors: Default::default(),
            }
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "codaDetail": {
    ///      "description": "Detail about why this request was rejected.",
    ///      "type": "object",
    ///      "properties": {
    ///        "validationErrors": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/ValidationError"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    },
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListPackVersionsResponse {
        #[serde(rename = "codaDetail", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub coda_detail: ::std::option::Option<ListPackVersionsResponseCodaDetail>,
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&ListPackVersionsResponse> for ListPackVersionsResponse {
        fn from(value: &ListPackVersionsResponse) -> Self {
            value.clone()
        }
    }

    ///Detail about why this request was rejected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why this request was rejected.",
    ///  "type": "object",
    ///  "properties": {
    ///    "validationErrors": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListPackVersionsResponseCodaDetail {
        #[serde(rename = "validationErrors", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub validation_errors: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&ListPackVersionsResponseCodaDetail> for ListPackVersionsResponseCodaDetail {
        fn from(value: &ListPackVersionsResponseCodaDetail) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ListPackVersionsResponseCodaDetail {
        fn default() -> Self {
            Self {
                validation_errors: Default::default(),
            }
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListPacksResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&ListPacksResponse> for ListPacksResponse {
        fn from(value: &ListPacksResponse) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        401
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListPageAnalyticsResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&ListPageAnalyticsResponse> for ListPageAnalyticsResponse {
        fn from(value: &ListPageAnalyticsResponse) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        401
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListPagesResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&ListPagesResponse> for ListPagesResponse {
        fn from(value: &ListPagesResponse) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListRowsResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&ListRowsResponse> for ListRowsResponse {
        fn from(value: &ListRowsResponse) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        401
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListTablesResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&ListTablesResponse> for ListTablesResponse {
        fn from(value: &ListTablesResponse) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        401
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListWorkspaceMembersResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&ListWorkspaceMembersResponse> for ListWorkspaceMembersResponse {
        fn from(value: &ListWorkspaceMembersResponse) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        401
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ListWorkspaceRoleActivityResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&ListWorkspaceRoleActivityResponse> for ListWorkspaceRoleActivityResponse {
        fn from(value: &ListWorkspaceRoleActivityResponse) -> Self {
            value.clone()
        }
    }

    ///`LogLevel`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "error",
    ///    "warn",
    ///    "info",
    ///    "debug",
    ///    "trace",
    ///    "unknown"
    ///  ],
    ///  "x-schema-name": "LogLevel",
    ///  "x-tsEnumNames": [
    ///    "Error",
    ///    "Warn",
    ///    "Info",
    ///    "Debug",
    ///    "Trace",
    ///    "Unknown"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum LogLevel {
        #[serde(rename = "error")]
        Error,
        #[serde(rename = "warn")]
        Warn,
        #[serde(rename = "info")]
        Info,
        #[serde(rename = "debug")]
        Debug,
        #[serde(rename = "trace")]
        Trace,
        #[serde(rename = "unknown")]
        Unknown,
    }

    impl ::std::convert::From<&Self> for LogLevel {
        fn from(value: &LogLevel) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LogLevel {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Error => f.write_str("error"),
                Self::Warn => f.write_str("warn"),
                Self::Info => f.write_str("info"),
                Self::Debug => f.write_str("debug"),
                Self::Trace => f.write_str("trace"),
                Self::Unknown => f.write_str("unknown"),
            }
        }
    }

    impl ::std::str::FromStr for LogLevel {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "error" => Ok(Self::Error),
                "warn" => Ok(Self::Warn),
                "info" => Ok(Self::Info),
                "debug" => Ok(Self::Debug),
                "trace" => Ok(Self::Trace),
                "unknown" => Ok(Self::Unknown),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LogLevel {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LogLevel {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LogLevel {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Info about the maker
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Info about the maker",
    ///  "type": "object",
    ///  "required": [
    ///    "loginId",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "Description for the maker.",
    ///      "type": "string"
    ///    },
    ///    "employer": {
    ///      "description": "Employer for maker.",
    ///      "type": "string"
    ///    },
    ///    "jobTitle": {
    ///      "description": "Job title for maker.",
    ///      "type": "string"
    ///    },
    ///    "loginId": {
    ///      "description": "Email address of the user.",
    ///      "examples": [
    ///        "user@example.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "Name of the maker.",
    ///      "examples": [
    ///        "John Doe"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "pictureLink": {
    ///      "description": "Browser-friendly link to the maker's avatar
    /// image.",
    ///      "examples": [
    ///        "https://cdn.coda.io/avatars/default_avatar.png"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "slug": {
    ///      "description": "Maker profile identifier for the maker.",
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "Maker"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct Maker {
        ///Description for the maker.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        ///Employer for maker.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub employer: ::std::option::Option<::std::string::String>,
        ///Job title for maker.
        #[serde(rename = "jobTitle", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub job_title: ::std::option::Option<::std::string::String>,
        ///Email address of the user.
        #[serde(rename = "loginId")]
        pub login_id: ::std::string::String,
        ///Name of the maker.
        pub name: ::std::string::String,
        ///Browser-friendly link to the maker's avatar image.
        #[serde(rename = "pictureLink", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub picture_link: ::std::option::Option<::std::string::String>,
        ///Maker profile identifier for the maker.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub slug: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&Maker> for Maker {
        fn from(value: &Maker) -> Self {
            value.clone()
        }
    }

    ///Summary about a maker
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Summary about a maker",
    ///  "type": "object",
    ///  "required": [
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "Description for the maker.",
    ///      "type": "string"
    ///    },
    ///    "employer": {
    ///      "description": "Employer for maker.",
    ///      "type": "string"
    ///    },
    ///    "jobTitle": {
    ///      "description": "Job title for maker.",
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "Name of the maker.",
    ///      "examples": [
    ///        "John Doe"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "pictureLink": {
    ///      "description": "Browser-friendly link to the maker's avatar
    /// image.",
    ///      "examples": [
    ///        "https://cdn.coda.io/avatars/default_avatar.png"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "slug": {
    ///      "description": "Maker profile identifier for the maker.",
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "MakerSummary"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct MakerSummary {
        ///Description for the maker.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        ///Employer for maker.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub employer: ::std::option::Option<::std::string::String>,
        ///Job title for maker.
        #[serde(rename = "jobTitle", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub job_title: ::std::option::Option<::std::string::String>,
        ///Name of the maker.
        pub name: ::std::string::String,
        ///Browser-friendly link to the maker's avatar image.
        #[serde(rename = "pictureLink", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub picture_link: ::std::option::Option<::std::string::String>,
        ///Maker profile identifier for the maker.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub slug: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&MakerSummary> for MakerSummary {
        fn from(value: &MakerSummary) -> Self {
            value.clone()
        }
    }

    ///Pricing used when workspaces can subscribe to the Pack for a monthly
    /// cost per Doc Maker.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Pricing used when workspaces can subscribe to the Pack
    /// for a monthly cost per Doc Maker.",
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "currency",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "description": "The monthly cost of the Pack per Doc Maker.",
    ///      "type": "number"
    ///    },
    ///    "currency": {
    ///      "$ref": "#/components/schemas/PackPlanCurrency"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "MonthlyDocMaker"
    ///      ],
    ///      "x-tsType": "PackPlanPricingType.MonthlyDocMaker"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "MonthlyDocMakerPackPlanPricing"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct MonthlyDocMakerPackPlanPricing {
        pub amount: f64,
        pub currency: PackPlanCurrency,
        #[serde(rename = "type")]
        pub type_: MonthlyDocMakerPackPlanPricingType,
    }

    impl ::std::convert::From<&MonthlyDocMakerPackPlanPricing> for MonthlyDocMakerPackPlanPricing {
        fn from(value: &MonthlyDocMakerPackPlanPricing) -> Self {
            value.clone()
        }
    }

    ///`MonthlyDocMakerPackPlanPricingType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "MonthlyDocMaker"
    ///  ],
    ///  "x-tsType": "PackPlanPricingType.MonthlyDocMaker"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum MonthlyDocMakerPackPlanPricingType {
        MonthlyDocMaker,
    }

    impl ::std::convert::From<&Self> for MonthlyDocMakerPackPlanPricingType {
        fn from(value: &MonthlyDocMakerPackPlanPricingType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for MonthlyDocMakerPackPlanPricingType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::MonthlyDocMaker => f.write_str("MonthlyDocMaker"),
            }
        }
    }

    impl ::std::str::FromStr for MonthlyDocMakerPackPlanPricingType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "MonthlyDocMaker" => Ok(Self::MonthlyDocMaker),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for MonthlyDocMakerPackPlanPricingType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for MonthlyDocMakerPackPlanPricingType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for MonthlyDocMakerPackPlanPricingType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The status of an asynchronous mutation.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The status of an asynchronous mutation.",
    ///  "type": "object",
    ///  "required": [
    ///    "completed"
    ///  ],
    ///  "properties": {
    ///    "completed": {
    ///      "description": "Returns whether the mutation has completed.",
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "warning": {
    ///      "description": "A warning if the mutation completed but with
    /// caveats.",
    ///      "examples": [
    ///        "Initial page HTML was invalid."
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "MutationStatus"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct MutationStatus {
        ///Returns whether the mutation has completed.
        pub completed: bool,
        ///A warning if the mutation completed but with caveats.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub warning: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&MutationStatus> for MutationStatus {
        fn from(value: &MutationStatus) -> Self {
            value.clone()
        }
    }

    ///Information indicating the next Pack version definition.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Information indicating the next Pack version
    /// definition.",
    ///  "type": "object",
    ///  "required": [
    ///    "findingDetails",
    ///    "findings",
    ///    "nextVersion"
    ///  ],
    ///  "properties": {
    ///    "findingDetails": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "finding",
    ///          "path"
    ///        ],
    ///        "properties": {
    ///          "finding": {
    ///            "type": "string"
    ///          },
    ///          "path": {
    ///            "type": "string"
    ///          }
    ///        },
    ///        "additionalProperties": false
    ///      }
    ///    },
    ///    "findings": {
    ///      "description": "List of changes from the previous version.",
    ///      "deprecated": true,
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "nextVersion": {
    ///      "description": "The next valid version for the Pack.",
    ///      "examples": [
    ///        "2.1.0"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "NextPackVersionInfo"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct NextPackVersionInfo {
        #[serde(rename = "findingDetails")]
        pub finding_details: ::std::vec::Vec<NextPackVersionInfoFindingDetailsItem>,
        ///List of changes from the previous version.
        pub findings: ::std::vec::Vec<::std::string::String>,
        ///The next valid version for the Pack.
        #[serde(rename = "nextVersion")]
        pub next_version: ::std::string::String,
    }

    impl ::std::convert::From<&NextPackVersionInfo> for NextPackVersionInfo {
        fn from(value: &NextPackVersionInfo) -> Self {
            value.clone()
        }
    }

    ///`NextPackVersionInfoFindingDetailsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "finding",
    ///    "path"
    ///  ],
    ///  "properties": {
    ///    "finding": {
    ///      "type": "string"
    ///    },
    ///    "path": {
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct NextPackVersionInfoFindingDetailsItem {
        pub finding: ::std::string::String,
        pub path: ::std::string::String,
    }

    impl ::std::convert::From<&NextPackVersionInfoFindingDetailsItem> for NextPackVersionInfoFindingDetailsItem {
        fn from(value: &NextPackVersionInfoFindingDetailsItem) -> Self {
            value.clone()
        }
    }

    ///If specified, a link that can be used to fetch the next page of results.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "If specified, a link that can be used to fetch the next
    /// page of results.",
    ///  "type": "string",
    ///  "format": "url"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct NextPageLink(pub ::std::string::String);
    impl ::std::ops::Deref for NextPageLink {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<NextPageLink> for ::std::string::String {
        fn from(value: NextPageLink) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&NextPageLink> for NextPageLink {
        fn from(value: &NextPageLink) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::string::String> for NextPageLink {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for NextPageLink {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::fmt::Display for NextPageLink {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    ///If specified, an opaque token used to fetch the next page of results.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "If specified, an opaque token used to fetch the next
    /// page of results.",
    ///  "examples": [
    ///    "eyJsaW1pd"
    ///  ],
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct NextPageToken(pub ::std::string::String);
    impl ::std::ops::Deref for NextPageToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<NextPageToken> for ::std::string::String {
        fn from(value: NextPageToken) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&NextPageToken> for NextPageToken {
        fn from(value: &NextPageToken) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::string::String> for NextPageToken {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for NextPageToken {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::fmt::Display for NextPageToken {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    ///If specified, an opaque token that can be passed back later to retrieve
    /// new results that match the parameters specified when the sync token was
    /// created.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "If specified, an opaque token that can be passed back
    /// later to retrieve new results that match the parameters specified when
    /// the sync token was created.\n",
    ///  "examples": [
    ///    "eyJsaW1pd"
    ///  ],
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct NextSyncToken(pub ::std::string::String);
    impl ::std::ops::Deref for NextSyncToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<NextSyncToken> for ::std::string::String {
        fn from(value: NextSyncToken) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&NextSyncToken> for NextSyncToken {
        fn from(value: &NextSyncToken) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::string::String> for NextSyncToken {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for NextSyncToken {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::fmt::Display for NextSyncToken {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    ///A number or a string representing a formula that evaluates to a number.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A number or a string representing a formula that
    /// evaluates to a number.",
    ///  "oneOf": [
    ///    {
    ///      "description": "A numeric value.",
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "number"
    ///    },
    ///    {
    ///      "description": "A formula that evaluates to a numeric value.",
    ///      "examples": [
    ///        "5 * 10"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  ],
    ///  "x-schema-name": "NumberOrNumberFormula"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum NumberOrNumberFormula {
        Variant0(f64),
        Variant1(::std::string::String),
    }

    impl ::std::convert::From<&Self> for NumberOrNumberFormula {
        fn from(value: &NumberOrNumberFormula) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for NumberOrNumberFormula {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<f64> for NumberOrNumberFormula {
        fn from(value: f64) -> Self {
            Self::Variant0(value)
        }
    }

    ///`NumericColumnFormat`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Format of a numeric column.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/SimpleColumnFormat"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "precision": {
    ///          "description": "The decimal precision.",
    ///          "examples": [
    ///            2
    ///          ],
    ///          "type": "integer",
    ///          "maximum": 10.0,
    ///          "minimum": 0.0
    ///        },
    ///        "useThousandsSeparator": {
    ///          "description": "Whether to use a thousands separator (like
    /// \",\") to format the numeric value.",
    ///          "examples": [
    ///            true
    ///          ],
    ///          "type": "boolean"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  ],
    ///  "x-schema-name": "NumericColumnFormat"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(deny_unknown_fields)]
    pub enum NumericColumnFormat {}
    impl ::std::convert::From<&Self> for NumericColumnFormat {
        fn from(value: &NumericColumnFormat) -> Self {
            value.clone()
        }
    }

    ///Details about a Pack.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Details about a Pack.",
    ///  "type": "object",
    ///  "required": [
    ///    "categories",
    ///    "description",
    ///    "id",
    ///    "name",
    ///    "shortDescription",
    ///    "workspaceId"
    ///  ],
    ///  "properties": {
    ///    "agentDescription": {
    ///      "description": "A full description for the pack as an agent.",
    ///      "examples": [
    ///        "Chat with a comprehensive tool that can calculate cool geometric
    /// formulas like surface area, volume, and other mathematical operations.
    /// This agent can help with complex calculations and provide detailed
    /// explanations."
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 8192
    ///    },
    ///    "agentImages": {
    ///      "description": "The agent images for the Pack.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PackImageFile"
    ///      }
    ///    },
    ///    "agentShortDescription": {
    ///      "description": "A short description for the pack as an agent.",
    ///      "examples": [
    ///        "Chat with a tool that can calculate cool geometric formulas like
    /// surface area."
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 256
    ///    },
    ///    "categories": {
    ///      "description": "Publishing categories associated with this Pack.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PublishingCategory"
    ///      }
    ///    },
    ///    "certified": {
    ///      "description": "Denotes if the pack is certified by Coda.",
    ///      "type": "boolean"
    ///    },
    ///    "certifiedAgent": {
    ///      "description": "Denotes if the pack is certified by Grammarly to be
    /// optimized for agent usage.",
    ///      "type": "boolean"
    ///    },
    ///    "coverUrl": {
    ///      "description": "The link to the cover photo of the Pack.",
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "description": {
    ///      "description": "The full description of the Pack.",
    ///      "examples": [
    ///        "This Pack allows users to calculate the surface area and volume
    /// of a few common 3D shapes, like cubes and pyramids."
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 8192
    ///    },
    ///    "exampleImages": {
    ///      "description": "The example images for the Pack.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PackImageFile"
    ///      }
    ///    },
    ///    "featuredDocStatus": {
    ///      "$ref": "#/components/schemas/FeaturedDocStatus"
    ///    },
    ///    "id": {
    ///      "description": "ID of the Pack.",
    ///      "examples": [
    ///        1003
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "logoUrl": {
    ///      "description": "The link to the logo of the Pack.",
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "name": {
    ///      "description": "The name of the Pack.",
    ///      "examples": [
    ///        "Cool Geometry Formulas"
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 128
    ///    },
    ///    "overallRateLimit": {
    ///      "$ref": "#/components/schemas/PackRateLimit"
    ///    },
    ///    "perConnectionRateLimit": {
    ///      "$ref": "#/components/schemas/PackRateLimit"
    ///    },
    ///    "privacyPolicyUrl": {
    ///      "description": "A Privacy Policy URL for the Pack.",
    ///      "type": "string",
    ///      "format": "url",
    ///      "maxLength": 512
    ///    },
    ///    "shortDescription": {
    ///      "description": "A short version of the description of the Pack.",
    ///      "examples": [
    ///        "Calculate cool geometric formulas like surface area."
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 256
    ///    },
    ///    "sourceCodeVisibility": {
    ///      "$ref": "#/components/schemas/PackSourceCodeVisibility"
    ///    },
    ///    "supportEmail": {
    ///      "description": "A contact email for the Pack.",
    ///      "examples": [
    ///        "user@email.com"
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 512
    ///    },
    ///    "termsOfServiceUrl": {
    ///      "description": "A Terms of Service URL for the Pack.",
    ///      "type": "string",
    ///      "format": "url",
    ///      "maxLength": 512
    ///    },
    ///    "workspaceId": {
    ///      "description": "The parent workspace for the Pack.",
    ///      "examples": [
    ///        "ws-asdf"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "Pack"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct Pack {
        ///A full description for the pack as an agent.
        #[serde(rename = "agentDescription", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub agent_description: ::std::option::Option<PackAgentDescription>,
        ///The agent images for the Pack.
        #[serde(rename = "agentImages", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub agent_images: ::std::vec::Vec<PackImageFile>,
        ///A short description for the pack as an agent.
        #[serde(rename = "agentShortDescription", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub agent_short_description: ::std::option::Option<PackAgentShortDescription>,
        ///Publishing categories associated with this Pack.
        pub categories: ::std::vec::Vec<PublishingCategory>,
        ///Denotes if the pack is certified by Coda.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub certified: ::std::option::Option<bool>,
        ///Denotes if the pack is certified by Grammarly to be optimized for
        /// agent usage.
        #[serde(rename = "certifiedAgent", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub certified_agent: ::std::option::Option<bool>,
        ///The link to the cover photo of the Pack.
        #[serde(rename = "coverUrl", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cover_url: ::std::option::Option<::std::string::String>,
        ///The full description of the Pack.
        pub description: PackDescription,
        ///The example images for the Pack.
        #[serde(rename = "exampleImages", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub example_images: ::std::vec::Vec<PackImageFile>,
        #[serde(rename = "featuredDocStatus", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub featured_doc_status: ::std::option::Option<FeaturedDocStatus>,
        pub id: f64,
        ///The link to the logo of the Pack.
        #[serde(rename = "logoUrl", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub logo_url: ::std::option::Option<::std::string::String>,
        ///The name of the Pack.
        pub name: PackName,
        #[serde(rename = "overallRateLimit", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub overall_rate_limit: ::std::option::Option<PackRateLimit>,
        #[serde(rename = "perConnectionRateLimit", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub per_connection_rate_limit: ::std::option::Option<PackRateLimit>,
        ///A Privacy Policy URL for the Pack.
        #[serde(rename = "privacyPolicyUrl", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub privacy_policy_url: ::std::option::Option<::std::string::String>,
        ///A short version of the description of the Pack.
        #[serde(rename = "shortDescription")]
        pub short_description: PackShortDescription,
        #[serde(rename = "sourceCodeVisibility", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub source_code_visibility: ::std::option::Option<PackSourceCodeVisibility>,
        ///A contact email for the Pack.
        #[serde(rename = "supportEmail", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub support_email: ::std::option::Option<PackSupportEmail>,
        ///A Terms of Service URL for the Pack.
        #[serde(rename = "termsOfServiceUrl", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub terms_of_service_url: ::std::option::Option<::std::string::String>,
        ///The parent workspace for the Pack.
        #[serde(rename = "workspaceId")]
        pub workspace_id: ::std::string::String,
    }

    impl ::std::convert::From<&Pack> for Pack {
        fn from(value: &Pack) -> Self {
            value.clone()
        }
    }

    ///`PackAccessType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "none",
    ///    "view",
    ///    "test",
    ///    "edit",
    ///    "admin"
    ///  ],
    ///  "x-schema-name": "PackAccessType",
    ///  "x-tsEnumNames": [
    ///    "None",
    ///    "View",
    ///    "Test",
    ///    "Edit",
    ///    "Admin"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackAccessType {
        #[serde(rename = "none")]
        None,
        #[serde(rename = "view")]
        View,
        #[serde(rename = "test")]
        Test,
        #[serde(rename = "edit")]
        Edit,
        #[serde(rename = "admin")]
        Admin,
    }

    impl ::std::convert::From<&Self> for PackAccessType {
        fn from(value: &PackAccessType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackAccessType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::None => f.write_str("none"),
                Self::View => f.write_str("view"),
                Self::Test => f.write_str("test"),
                Self::Edit => f.write_str("edit"),
                Self::Admin => f.write_str("admin"),
            }
        }
    }

    impl ::std::str::FromStr for PackAccessType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "none" => Ok(Self::None),
                "view" => Ok(Self::View),
                "test" => Ok(Self::Test),
                "edit" => Ok(Self::Edit),
                "admin" => Ok(Self::Admin),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackAccessType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackAccessType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackAccessType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Access types for a Pack.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Access types for a Pack.",
    ///  "type": "array",
    ///  "items": {
    ///    "$ref": "#/components/schemas/PackAccessType"
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackAccessTypes"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct PackAccessTypes(pub ::std::vec::Vec<PackAccessType>);
    impl ::std::ops::Deref for PackAccessTypes {
        type Target = ::std::vec::Vec<PackAccessType>;
        fn deref(&self) -> &::std::vec::Vec<PackAccessType> {
            &self.0
        }
    }

    impl ::std::convert::From<PackAccessTypes> for ::std::vec::Vec<PackAccessType> {
        fn from(value: PackAccessTypes) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PackAccessTypes> for PackAccessTypes {
        fn from(value: &PackAccessTypes) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::vec::Vec<PackAccessType>> for PackAccessTypes {
        fn from(value: ::std::vec::Vec<PackAccessType>) -> Self {
            Self(value)
        }
    }

    ///A full description for the pack as an agent.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A full description for the pack as an agent.",
    ///  "examples": [
    ///    "Chat with a comprehensive tool that can calculate cool geometric
    /// formulas like surface area, volume, and other mathematical operations.
    /// This agent can help with complex calculations and provide detailed
    /// explanations."
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 8192
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PackAgentDescription(::std::string::String);
    impl ::std::ops::Deref for PackAgentDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PackAgentDescription> for ::std::string::String {
        fn from(value: PackAgentDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PackAgentDescription> for PackAgentDescription {
        fn from(value: &PackAgentDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PackAgentDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 8192usize {
                return Err("longer than 8192 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PackAgentDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackAgentDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackAgentDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PackAgentDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///A short description for the pack as an agent.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A short description for the pack as an agent.",
    ///  "examples": [
    ///    "Chat with a tool that can calculate cool geometric formulas like
    /// surface area."
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 256
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PackAgentShortDescription(::std::string::String);
    impl ::std::ops::Deref for PackAgentShortDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PackAgentShortDescription> for ::std::string::String {
        fn from(value: PackAgentShortDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PackAgentShortDescription> for PackAgentShortDescription {
        fn from(value: &PackAgentShortDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PackAgentShortDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 256usize {
                return Err("longer than 256 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PackAgentShortDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackAgentShortDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackAgentShortDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PackAgentShortDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///List of analytics for Coda Packs over a date range.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "List of analytics for Coda Packs over a date range.",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PackAnalyticsItem"
    ///      }
    ///    },
    ///    "nextPageLink": {
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/nextPageLink"
    ///        },
    ///        {
    ///          "examples": [
    ///            "https://coda.io/apis/v1/analytics/packs?pageToken=xyz"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      ]
    ///    },
    ///    "nextPageToken": {
    ///      "$ref": "#/components/schemas/nextPageToken"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackAnalyticsCollection"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackAnalyticsCollection {
        pub items: ::std::vec::Vec<PackAnalyticsItem>,
        #[serde(rename = "nextPageLink", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_link: ::std::option::Option<NextPageLink>,
        #[serde(rename = "nextPageToken", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_token: ::std::option::Option<NextPageToken>,
    }

    impl ::std::convert::From<&PackAnalyticsCollection> for PackAnalyticsCollection {
        fn from(value: &PackAnalyticsCollection) -> Self {
            value.clone()
        }
    }

    ///Metadata about a Pack relevant to analytics.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Metadata about a Pack relevant to analytics.",
    ///  "type": "object",
    ///  "required": [
    ///    "createdAt",
    ///    "id",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "createdAt": {
    ///      "description": "Creation time of the Pack.",
    ///      "examples": [
    ///        "2022-04-11T00:18:57.946Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "id": {
    ///      "description": "ID of the Pack.",
    ///      "examples": [
    ///        1003
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "logoUrl": {
    ///      "description": "The link to the logo of the Pack.",
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "name": {
    ///      "description": "The name of the Pack.",
    ///      "examples": [
    ///        "Cool Geometry Formulas"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackAnalyticsDetails"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackAnalyticsDetails {
        ///Creation time of the Pack.
        #[serde(rename = "createdAt")]
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub id: f64,
        ///The link to the logo of the Pack.
        #[serde(rename = "logoUrl", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub logo_url: ::std::option::Option<::std::string::String>,
        ///The name of the Pack.
        pub name: ::std::string::String,
    }

    impl ::std::convert::From<&PackAnalyticsDetails> for PackAnalyticsDetails {
        fn from(value: &PackAnalyticsDetails) -> Self {
            value.clone()
        }
    }

    ///Analytics data for a Coda Pack.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Analytics data for a Coda Pack.",
    ///  "type": "object",
    ///  "required": [
    ///    "metrics",
    ///    "pack"
    ///  ],
    ///  "properties": {
    ///    "metrics": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PackAnalyticsMetrics"
    ///      }
    ///    },
    ///    "pack": {
    ///      "$ref": "#/components/schemas/PackAnalyticsDetails"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackAnalyticsItem"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackAnalyticsItem {
        pub metrics: ::std::vec::Vec<PackAnalyticsMetrics>,
        pub pack: PackAnalyticsDetails,
    }

    impl ::std::convert::From<&PackAnalyticsItem> for PackAnalyticsItem {
        fn from(value: &PackAnalyticsItem) -> Self {
            value.clone()
        }
    }

    ///Analytics metrics for a Coda Pack.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Analytics metrics for a Coda Pack.",
    ///  "type": "object",
    ///  "required": [
    ///    "date",
    ///    "docInstalls",
    ///    "docsActivelyUsing",
    ///    "docsActivelyUsing30Day",
    ///    "docsActivelyUsing7Day",
    ///    "docsActivelyUsing90Day",
    ///    "docsActivelyUsingAllTime",
    ///    "numActionInvocations",
    ///    "numFormulaInvocations",
    ///    "numMetadataInvocations",
    ///    "numSyncInvocations",
    ///    "revenueUsd",
    ///    "workspaceInstalls",
    ///    "workspacesActivelyTrialing",
    ///    "workspacesActivelyTrialing30Day",
    ///    "workspacesActivelyTrialing7Day",
    ///    "workspacesActivelyTrialing90Day",
    ///    "workspacesActivelyTrialingAllTime",
    ///    "workspacesActivelyUsing",
    ///    "workspacesActivelyUsing30Day",
    ///    "workspacesActivelyUsing7Day",
    ///    "workspacesActivelyUsing90Day",
    ///    "workspacesActivelyUsingAllTime",
    ///    "workspacesNewlySubscribed",
    ///    "workspacesWithActiveSubscriptions",
    ///    "workspacesWithSuccessfulTrials"
    ///  ],
    ///  "properties": {
    ///    "date": {
    ///      "description": "Date of the analytics data.",
    ///      "examples": [
    ///        "2020-09-02"
    ///      ],
    ///      "type": "string",
    ///      "format": "date"
    ///    },
    ///    "docInstalls": {
    ///      "description": "Number of unique documents that have installed this
    /// Pack.",
    ///      "examples": [
    ///        100
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "docsActivelyUsing": {
    ///      "description": "Number of unique docs that have invoked a formula
    /// from this Pack in the past day.",
    ///      "examples": [
    ///        50
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "docsActivelyUsing30Day": {
    ///      "description": "Number of unique docs that have invoked a formula
    /// from this Pack in the past 30 days.",
    ///      "examples": [
    ///        200
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "docsActivelyUsing7Day": {
    ///      "description": "Number of unique docs that have invoked a formula
    /// from this Pack in the past 7 days.",
    ///      "examples": [
    ///        100
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "docsActivelyUsing90Day": {
    ///      "description": "Number of unique docs that have invoked a formula
    /// from this Pack in the past 90 days.",
    ///      "examples": [
    ///        300
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "docsActivelyUsingAllTime": {
    ///      "description": "Number of unique docs that have invoked a formula
    /// from this Pack ever.",
    ///      "examples": [
    ///        500
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "numActionInvocations": {
    ///      "description": "Number of times action formulas have been called.",
    ///      "examples": [
    ///        100
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "numFormulaInvocations": {
    ///      "description": "Number of times regular formulas have been
    /// called.",
    ///      "examples": [
    ///        100
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "numMetadataInvocations": {
    ///      "description": "Number of times metadata formulas have been
    /// called.",
    ///      "examples": [
    ///        100
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "numSyncInvocations": {
    ///      "description": "Number of times sync table formulas have been
    /// called.",
    ///      "examples": [
    ///        100
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "revenueUsd": {
    ///      "description": "Amount of revenue (in USD) that the Pack has
    /// produced.",
    ///      "type": "string"
    ///    },
    ///    "workspaceInstalls": {
    ///      "description": "Number of unique workspaces that have installed
    /// this Pack.",
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "workspacesActivelyTrialing": {
    ///      "description": "Number of unique workspaces that are currently
    /// involved in a trial.",
    ///      "type": "integer"
    ///    },
    ///    "workspacesActivelyTrialing30Day": {
    ///      "description": "Number of unique workspaces that have been involved
    /// in a trial in the last 30 days.",
    ///      "type": "integer"
    ///    },
    ///    "workspacesActivelyTrialing7Day": {
    ///      "description": "Number of unique workspaces that have been involved
    /// in a trial in the last 7 days.",
    ///      "type": "integer"
    ///    },
    ///    "workspacesActivelyTrialing90Day": {
    ///      "description": "Number of unique workspaces that have been involved
    /// in a trial in the last 90 days.",
    ///      "type": "integer"
    ///    },
    ///    "workspacesActivelyTrialingAllTime": {
    ///      "description": "Number of unique workspaces that have been involved
    /// in a trial ever.",
    ///      "type": "integer"
    ///    },
    ///    "workspacesActivelyUsing": {
    ///      "description": "Number of unique workspaces that have invoked a
    /// formula from this Pack in the past day.",
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "workspacesActivelyUsing30Day": {
    ///      "description": "Number of unique workspaces that have invoked a
    /// formula from this Pack in the past 30 days.",
    ///      "examples": [
    ///        20
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "workspacesActivelyUsing7Day": {
    ///      "description": "Number of unique workspaces that have invoked a
    /// formula from this Pack in the past 7 days.",
    ///      "examples": [
    ///        15
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "workspacesActivelyUsing90Day": {
    ///      "description": "Number of unique workspaces that have invoked a
    /// formula from this Pack in the past 90 days.",
    ///      "examples": [
    ///        30
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "workspacesActivelyUsingAllTime": {
    ///      "description": "Number of unique workspaces that have invoked a
    /// formula from this Pack ever.",
    ///      "examples": [
    ///        50
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "workspacesNewlySubscribed": {
    ///      "description": "Number of unique workspaces that have recently
    /// subscribed to the Pack.",
    ///      "type": "integer"
    ///    },
    ///    "workspacesWithActiveSubscriptions": {
    ///      "description": "Number of unique workspaces that are currently
    /// subscribed to the Pack.",
    ///      "type": "integer"
    ///    },
    ///    "workspacesWithSuccessfulTrials": {
    ///      "description": "Number of unique workspaces that subscribed after
    /// undertaking a Pack trial.",
    ///      "type": "integer"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackAnalyticsMetrics"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackAnalyticsMetrics {
        ///Date of the analytics data.
        pub date: ::chrono::naive::NaiveDate,
        ///Number of unique documents that have installed this Pack.
        #[serde(rename = "docInstalls")]
        pub doc_installs: i64,
        ///Number of unique docs that have invoked a formula from this Pack in
        /// the past day.
        #[serde(rename = "docsActivelyUsing")]
        pub docs_actively_using: i64,
        ///Number of unique docs that have invoked a formula from this Pack in
        /// the past 30 days.
        #[serde(rename = "docsActivelyUsing30Day")]
        pub docs_actively_using30_day: i64,
        ///Number of unique docs that have invoked a formula from this Pack in
        /// the past 7 days.
        #[serde(rename = "docsActivelyUsing7Day")]
        pub docs_actively_using7_day: i64,
        ///Number of unique docs that have invoked a formula from this Pack in
        /// the past 90 days.
        #[serde(rename = "docsActivelyUsing90Day")]
        pub docs_actively_using90_day: i64,
        ///Number of unique docs that have invoked a formula from this Pack
        /// ever.
        #[serde(rename = "docsActivelyUsingAllTime")]
        pub docs_actively_using_all_time: i64,
        ///Number of times action formulas have been called.
        #[serde(rename = "numActionInvocations")]
        pub num_action_invocations: i64,
        ///Number of times regular formulas have been called.
        #[serde(rename = "numFormulaInvocations")]
        pub num_formula_invocations: i64,
        ///Number of times metadata formulas have been called.
        #[serde(rename = "numMetadataInvocations")]
        pub num_metadata_invocations: i64,
        ///Number of times sync table formulas have been called.
        #[serde(rename = "numSyncInvocations")]
        pub num_sync_invocations: i64,
        ///Amount of revenue (in USD) that the Pack has produced.
        #[serde(rename = "revenueUsd")]
        pub revenue_usd: ::std::string::String,
        ///Number of unique workspaces that have installed this Pack.
        #[serde(rename = "workspaceInstalls")]
        pub workspace_installs: i64,
        ///Number of unique workspaces that are currently involved in a trial.
        #[serde(rename = "workspacesActivelyTrialing")]
        pub workspaces_actively_trialing: i64,
        ///Number of unique workspaces that have been involved in a trial in
        /// the last 30 days.
        #[serde(rename = "workspacesActivelyTrialing30Day")]
        pub workspaces_actively_trialing30_day: i64,
        ///Number of unique workspaces that have been involved in a trial in
        /// the last 7 days.
        #[serde(rename = "workspacesActivelyTrialing7Day")]
        pub workspaces_actively_trialing7_day: i64,
        ///Number of unique workspaces that have been involved in a trial in
        /// the last 90 days.
        #[serde(rename = "workspacesActivelyTrialing90Day")]
        pub workspaces_actively_trialing90_day: i64,
        ///Number of unique workspaces that have been involved in a trial ever.
        #[serde(rename = "workspacesActivelyTrialingAllTime")]
        pub workspaces_actively_trialing_all_time: i64,
        ///Number of unique workspaces that have invoked a formula from this
        /// Pack in the past day.
        #[serde(rename = "workspacesActivelyUsing")]
        pub workspaces_actively_using: i64,
        ///Number of unique workspaces that have invoked a formula from this
        /// Pack in the past 30 days.
        #[serde(rename = "workspacesActivelyUsing30Day")]
        pub workspaces_actively_using30_day: i64,
        ///Number of unique workspaces that have invoked a formula from this
        /// Pack in the past 7 days.
        #[serde(rename = "workspacesActivelyUsing7Day")]
        pub workspaces_actively_using7_day: i64,
        ///Number of unique workspaces that have invoked a formula from this
        /// Pack in the past 90 days.
        #[serde(rename = "workspacesActivelyUsing90Day")]
        pub workspaces_actively_using90_day: i64,
        ///Number of unique workspaces that have invoked a formula from this
        /// Pack ever.
        #[serde(rename = "workspacesActivelyUsingAllTime")]
        pub workspaces_actively_using_all_time: i64,
        ///Number of unique workspaces that have recently subscribed to the
        /// Pack.
        #[serde(rename = "workspacesNewlySubscribed")]
        pub workspaces_newly_subscribed: i64,
        ///Number of unique workspaces that are currently subscribed to the
        /// Pack.
        #[serde(rename = "workspacesWithActiveSubscriptions")]
        pub workspaces_with_active_subscriptions: i64,
        ///Number of unique workspaces that subscribed after undertaking a Pack
        /// trial.
        #[serde(rename = "workspacesWithSuccessfulTrials")]
        pub workspaces_with_successful_trials: i64,
    }

    impl ::std::convert::From<&PackAnalyticsMetrics> for PackAnalyticsMetrics {
        fn from(value: &PackAnalyticsMetrics) -> Self {
            value.clone()
        }
    }

    ///Determines how the Pack analytics returned are sorted.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Determines how the Pack analytics returned are
    /// sorted.",
    ///  "type": "string",
    ///  "enum": [
    ///    "date",
    ///    "packId",
    ///    "name",
    ///    "createdAt",
    ///    "docInstalls",
    ///    "workspaceInstalls",
    ///    "numFormulaInvocations",
    ///    "numActionInvocations",
    ///    "numSyncInvocations",
    ///    "numMetadataInvocations",
    ///    "docsActivelyUsing",
    ///    "docsActivelyUsing7Day",
    ///    "docsActivelyUsing30Day",
    ///    "docsActivelyUsing90Day",
    ///    "docsActivelyUsingAllTime",
    ///    "workspacesActivelyUsing",
    ///    "workspacesActivelyUsing7Day",
    ///    "workspacesActivelyUsing30Day",
    ///    "workspacesActivelyUsing90Day",
    ///    "workspacesActivelyUsingAllTime",
    ///    "workspacesWithActiveSubscriptions",
    ///    "workspacesWithSuccessfulTrials",
    ///    "revenueUsd"
    ///  ],
    ///  "x-schema-name": "PackAnalyticsOrderBy",
    ///  "x-tsEnumNames": [
    ///    "AnalyticsDate",
    ///    "PackId",
    ///    "Name",
    ///    "CreatedAt",
    ///    "DocInstalls",
    ///    "WorkspaceInstalls",
    ///    "NumFormulaInvocations",
    ///    "NumActionInvocations",
    ///    "NumSyncInvocations",
    ///    "NumMetadataInvocations",
    ///    "DocsActivelyUsing",
    ///    "DocsActivelyUsing7Day",
    ///    "DocsActivelyUsing30Day",
    ///    "DocsActivelyUsing90Day",
    ///    "DocsActivelyUsingAllTime",
    ///    "WorkspacesActivelyUsing",
    ///    "WorkspacesActivelyUsing7Day",
    ///    "WorkspacesActivelyUsing30Day",
    ///    "WorkspacesActivelyUsing90Day",
    ///    "WorkspacesActivelyUsingAllTime",
    ///    "WorkspacesWithActiveSubscriptions",
    ///    "WorkspacesWithSuccessfulTrials",
    ///    "RevenueUsd"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackAnalyticsOrderBy {
        #[serde(rename = "date")]
        Date,
        #[serde(rename = "packId")]
        PackId,
        #[serde(rename = "name")]
        Name,
        #[serde(rename = "createdAt")]
        CreatedAt,
        #[serde(rename = "docInstalls")]
        DocInstalls,
        #[serde(rename = "workspaceInstalls")]
        WorkspaceInstalls,
        #[serde(rename = "numFormulaInvocations")]
        NumFormulaInvocations,
        #[serde(rename = "numActionInvocations")]
        NumActionInvocations,
        #[serde(rename = "numSyncInvocations")]
        NumSyncInvocations,
        #[serde(rename = "numMetadataInvocations")]
        NumMetadataInvocations,
        #[serde(rename = "docsActivelyUsing")]
        DocsActivelyUsing,
        #[serde(rename = "docsActivelyUsing7Day")]
        DocsActivelyUsing7Day,
        #[serde(rename = "docsActivelyUsing30Day")]
        DocsActivelyUsing30Day,
        #[serde(rename = "docsActivelyUsing90Day")]
        DocsActivelyUsing90Day,
        #[serde(rename = "docsActivelyUsingAllTime")]
        DocsActivelyUsingAllTime,
        #[serde(rename = "workspacesActivelyUsing")]
        WorkspacesActivelyUsing,
        #[serde(rename = "workspacesActivelyUsing7Day")]
        WorkspacesActivelyUsing7Day,
        #[serde(rename = "workspacesActivelyUsing30Day")]
        WorkspacesActivelyUsing30Day,
        #[serde(rename = "workspacesActivelyUsing90Day")]
        WorkspacesActivelyUsing90Day,
        #[serde(rename = "workspacesActivelyUsingAllTime")]
        WorkspacesActivelyUsingAllTime,
        #[serde(rename = "workspacesWithActiveSubscriptions")]
        WorkspacesWithActiveSubscriptions,
        #[serde(rename = "workspacesWithSuccessfulTrials")]
        WorkspacesWithSuccessfulTrials,
        #[serde(rename = "revenueUsd")]
        RevenueUsd,
    }

    impl ::std::convert::From<&Self> for PackAnalyticsOrderBy {
        fn from(value: &PackAnalyticsOrderBy) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackAnalyticsOrderBy {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Date => f.write_str("date"),
                Self::PackId => f.write_str("packId"),
                Self::Name => f.write_str("name"),
                Self::CreatedAt => f.write_str("createdAt"),
                Self::DocInstalls => f.write_str("docInstalls"),
                Self::WorkspaceInstalls => f.write_str("workspaceInstalls"),
                Self::NumFormulaInvocations => f.write_str("numFormulaInvocations"),
                Self::NumActionInvocations => f.write_str("numActionInvocations"),
                Self::NumSyncInvocations => f.write_str("numSyncInvocations"),
                Self::NumMetadataInvocations => f.write_str("numMetadataInvocations"),
                Self::DocsActivelyUsing => f.write_str("docsActivelyUsing"),
                Self::DocsActivelyUsing7Day => f.write_str("docsActivelyUsing7Day"),
                Self::DocsActivelyUsing30Day => f.write_str("docsActivelyUsing30Day"),
                Self::DocsActivelyUsing90Day => f.write_str("docsActivelyUsing90Day"),
                Self::DocsActivelyUsingAllTime => f.write_str("docsActivelyUsingAllTime"),
                Self::WorkspacesActivelyUsing => f.write_str("workspacesActivelyUsing"),
                Self::WorkspacesActivelyUsing7Day => f.write_str("workspacesActivelyUsing7Day"),
                Self::WorkspacesActivelyUsing30Day => f.write_str("workspacesActivelyUsing30Day"),
                Self::WorkspacesActivelyUsing90Day => f.write_str("workspacesActivelyUsing90Day"),
                Self::WorkspacesActivelyUsingAllTime => f.write_str("workspacesActivelyUsingAllTime"),
                Self::WorkspacesWithActiveSubscriptions => f.write_str("workspacesWithActiveSubscriptions"),
                Self::WorkspacesWithSuccessfulTrials => f.write_str("workspacesWithSuccessfulTrials"),
                Self::RevenueUsd => f.write_str("revenueUsd"),
            }
        }
    }

    impl ::std::str::FromStr for PackAnalyticsOrderBy {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "date" => Ok(Self::Date),
                "packId" => Ok(Self::PackId),
                "name" => Ok(Self::Name),
                "createdAt" => Ok(Self::CreatedAt),
                "docInstalls" => Ok(Self::DocInstalls),
                "workspaceInstalls" => Ok(Self::WorkspaceInstalls),
                "numFormulaInvocations" => Ok(Self::NumFormulaInvocations),
                "numActionInvocations" => Ok(Self::NumActionInvocations),
                "numSyncInvocations" => Ok(Self::NumSyncInvocations),
                "numMetadataInvocations" => Ok(Self::NumMetadataInvocations),
                "docsActivelyUsing" => Ok(Self::DocsActivelyUsing),
                "docsActivelyUsing7Day" => Ok(Self::DocsActivelyUsing7Day),
                "docsActivelyUsing30Day" => Ok(Self::DocsActivelyUsing30Day),
                "docsActivelyUsing90Day" => Ok(Self::DocsActivelyUsing90Day),
                "docsActivelyUsingAllTime" => Ok(Self::DocsActivelyUsingAllTime),
                "workspacesActivelyUsing" => Ok(Self::WorkspacesActivelyUsing),
                "workspacesActivelyUsing7Day" => Ok(Self::WorkspacesActivelyUsing7Day),
                "workspacesActivelyUsing30Day" => Ok(Self::WorkspacesActivelyUsing30Day),
                "workspacesActivelyUsing90Day" => Ok(Self::WorkspacesActivelyUsing90Day),
                "workspacesActivelyUsingAllTime" => Ok(Self::WorkspacesActivelyUsingAllTime),
                "workspacesWithActiveSubscriptions" => Ok(Self::WorkspacesWithActiveSubscriptions),
                "workspacesWithSuccessfulTrials" => Ok(Self::WorkspacesWithSuccessfulTrials),
                "revenueUsd" => Ok(Self::RevenueUsd),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackAnalyticsOrderBy {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackAnalyticsOrderBy {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackAnalyticsOrderBy {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Summary analytics for Packs.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Summary analytics for Packs.",
    ///  "type": "object",
    ///  "required": [
    ///    "totalDocInstalls",
    ///    "totalInvocations",
    ///    "totalWorkspaceInstalls"
    ///  ],
    ///  "properties": {
    ///    "totalDocInstalls": {
    ///      "description": "The number of times this Pack was installed in
    /// docs.",
    ///      "type": "integer"
    ///    },
    ///    "totalInvocations": {
    ///      "description": "The number of times formulas in this Pack were
    /// invoked.",
    ///      "type": "integer"
    ///    },
    ///    "totalWorkspaceInstalls": {
    ///      "description": "The number of times this Pack was installed in
    /// workspaces.",
    ///      "type": "integer"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackAnalyticsSummary"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackAnalyticsSummary {
        ///The number of times this Pack was installed in docs.
        #[serde(rename = "totalDocInstalls")]
        pub total_doc_installs: i64,
        ///The number of times formulas in this Pack were invoked.
        #[serde(rename = "totalInvocations")]
        pub total_invocations: i64,
        ///The number of times this Pack was installed in workspaces.
        #[serde(rename = "totalWorkspaceInstalls")]
        pub total_workspace_installs: i64,
    }

    impl ::std::convert::From<&PackAnalyticsSummary> for PackAnalyticsSummary {
        fn from(value: &PackAnalyticsSummary) -> Self {
            value.clone()
        }
    }

    ///`PackAssetType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "logo",
    ///    "cover",
    ///    "exampleImage",
    ///    "agentImage"
    ///  ],
    ///  "x-schema-name": "PackAssetType",
    ///  "x-tsEnumNames": [
    ///    "Logo",
    ///    "Cover",
    ///    "ExampleImage",
    ///    "AgentImage"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackAssetType {
        #[serde(rename = "logo")]
        Logo,
        #[serde(rename = "cover")]
        Cover,
        #[serde(rename = "exampleImage")]
        ExampleImage,
        #[serde(rename = "agentImage")]
        AgentImage,
    }

    impl ::std::convert::From<&Self> for PackAssetType {
        fn from(value: &PackAssetType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackAssetType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Logo => f.write_str("logo"),
                Self::Cover => f.write_str("cover"),
                Self::ExampleImage => f.write_str("exampleImage"),
                Self::AgentImage => f.write_str("agentImage"),
            }
        }
    }

    impl ::std::str::FromStr for PackAssetType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "logo" => Ok(Self::Logo),
                "cover" => Ok(Self::Cover),
                "exampleImage" => Ok(Self::ExampleImage),
                "agentImage" => Ok(Self::AgentImage),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackAssetType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackAssetType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackAssetType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Payload for noting a Pack asset upload is complete.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Payload for noting a Pack asset upload is complete.",
    ///  "type": "object",
    ///  "required": [
    ///    "packAssetType"
    ///  ],
    ///  "properties": {
    ///    "packAssetType": {
    ///      "$ref": "#/components/schemas/PackAssetType"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackAssetUploadCompleteRequest"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackAssetUploadCompleteRequest {
        #[serde(rename = "packAssetType")]
        pub pack_asset_type: PackAssetType,
    }

    impl ::std::convert::From<&PackAssetUploadCompleteRequest> for PackAssetUploadCompleteRequest {
        fn from(value: &PackAssetUploadCompleteRequest) -> Self {
            value.clone()
        }
    }

    ///Response for noting a Pack asset upload is complete.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Response for noting a Pack asset upload is complete.",
    ///  "type": "object",
    ///  "required": [
    ///    "assetId",
    ///    "requestId"
    ///  ],
    ///  "properties": {
    ///    "assetId": {
    ///      "description": "An identifier of this uploaded asset.",
    ///      "examples": [
    ///        "e23fcb5e564f08b71183d424c2c380c0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "requestId": {
    ///      "description": "An arbitrary unique identifier for this request.",
    ///      "examples": [
    ///        "abc-123-def-456"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackAssetUploadCompleteResponse"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackAssetUploadCompleteResponse {
        ///An identifier of this uploaded asset.
        #[serde(rename = "assetId")]
        pub asset_id: ::std::string::String,
        ///An arbitrary unique identifier for this request.
        #[serde(rename = "requestId")]
        pub request_id: ::std::string::String,
    }

    impl ::std::convert::From<&PackAssetUploadCompleteResponse> for PackAssetUploadCompleteResponse {
        fn from(value: &PackAssetUploadCompleteResponse) -> Self {
            value.clone()
        }
    }

    ///Detail about why this request was rejected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why this request was rejected.",
    ///  "type": "object",
    ///  "properties": {
    ///    "validationErrors": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackAssetUploadCompleteResponseCodaDetail {
        #[serde(rename = "validationErrors", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub validation_errors: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&PackAssetUploadCompleteResponseCodaDetail> for PackAssetUploadCompleteResponseCodaDetail {
        fn from(value: &PackAssetUploadCompleteResponseCodaDetail) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for PackAssetUploadCompleteResponseCodaDetail {
        fn default() -> Self {
            Self {
                validation_errors: Default::default(),
            }
        }
    }

    ///Information indicating where to upload the Pack asset, and an endpoint
    /// to mark the upload as complete.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Information indicating where to upload the Pack asset,
    /// and an endpoint to mark the upload as complete.",
    ///  "type": "object",
    ///  "required": [
    ///    "headers",
    ///    "packAssetUploadedPathName",
    ///    "uploadUrl"
    ///  ],
    ///  "properties": {
    ///    "headers": {
    ///      "description": "Key-value pairs of authorization headers to include
    /// in the upload request.",
    ///      "examples": [
    ///        "{\"header1\": \"value1\"}"
    ///      ],
    ///      "type": "object",
    ///      "additionalProperties": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "packAssetUploadedPathName": {
    ///      "description": "An endpoint to mark the upload as complete.",
    ///      "examples": [
    ///        "/packs/123/assets/e23fcb5e564f08b71183d424c2c380c0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "uploadUrl": {
    ///      "description": "A signed URL to be used for uploading a Pack
    /// asset.",
    ///      "examples": [
    ///        "https://coda-us-west-2-prod-blobs-upload.s3-accelerate.amazonaws.com/packs/123/assets/logo/e23fcb5e564f08b71183d424c2c380c0"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackAssetUploadInfo"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackAssetUploadInfo {
        ///Key-value pairs of authorization headers to include in the upload
        /// request.
        pub headers: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        ///An endpoint to mark the upload as complete.
        #[serde(rename = "packAssetUploadedPathName")]
        pub pack_asset_uploaded_path_name: ::std::string::String,
        ///A signed URL to be used for uploading a Pack asset.
        #[serde(rename = "uploadUrl")]
        pub upload_url: ::std::string::String,
    }

    impl ::std::convert::From<&PackAssetUploadInfo> for PackAssetUploadInfo {
        fn from(value: &PackAssetUploadInfo) -> Self {
            value.clone()
        }
    }

    ///System logs of Pack authentication requests.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "System logs of Pack authentication requests.",
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "path",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/PackLogContext"
    ///    },
    ///    "errorMessage": {
    ///      "description": "The error message.",
    ///      "type": "string"
    ///    },
    ///    "errorStack": {
    ///      "description": "The error stacktrace (internal only).",
    ///      "type": "string"
    ///    },
    ///    "path": {
    ///      "description": "The request path.",
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "auth"
    ///      ],
    ///      "x-tsType": "PackLogType.Auth"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackAuthLog"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackAuthLog {
        pub context: PackLogContext,
        ///The error message.
        #[serde(rename = "errorMessage", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error_message: ::std::option::Option<::std::string::String>,
        ///The error stacktrace (internal only).
        #[serde(rename = "errorStack", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error_stack: ::std::option::Option<::std::string::String>,
        ///The request path.
        pub path: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: PackAuthLogType,
    }

    impl ::std::convert::From<&PackAuthLog> for PackAuthLog {
        fn from(value: &PackAuthLog) -> Self {
            value.clone()
        }
    }

    ///`PackAuthLogType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "auth"
    ///  ],
    ///  "x-tsType": "PackLogType.Auth"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackAuthLogType {
        #[serde(rename = "auth")]
        Auth,
    }

    impl ::std::convert::From<&Self> for PackAuthLogType {
        fn from(value: &PackAuthLogType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackAuthLogType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Auth => f.write_str("auth"),
            }
        }
    }

    impl ::std::str::FromStr for PackAuthLogType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "auth" => Ok(Self::Auth),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackAuthLogType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackAuthLogType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackAuthLogType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Basic details about a configuration that can be used in conjunction with
    /// a pack
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Basic details about a configuration that can be used in
    /// conjunction with a pack",
    ///  "type": "object",
    ///  "required": [
    ///    "configurationId",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "configurationId": {
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "Name of the configuration",
    ///      "type": "string"
    ///    },
    ///    "policy": {
    ///      "description": "Policy associated with the configuration",
    ///      "type": "object",
    ///      "additionalProperties": true
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackConfigurationEntry"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConfigurationEntry {
        #[serde(rename = "configurationId")]
        pub configuration_id: ::std::string::String,
        ///Name of the configuration
        pub name: ::std::string::String,
        ///Policy associated with the configuration
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        pub policy: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    }

    impl ::std::convert::From<&PackConfigurationEntry> for PackConfigurationEntry {
        fn from(value: &PackConfigurationEntry) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionAwsAccessKeyCredentials`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "accessKeyId",
    ///    "secretAccessKey",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "accessKeyId": {
    ///      "type": "string"
    ///    },
    ///    "secretAccessKey": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "awsAccessKey"
    ///      ],
    ///      "x-tsType": "PackConnectionType.AwsAccessKey"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackConnectionAwsAccessKeyCredentials"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionAwsAccessKeyCredentials {
        #[serde(rename = "accessKeyId")]
        pub access_key_id: ::std::string::String,
        #[serde(rename = "secretAccessKey")]
        pub secret_access_key: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: PackConnectionAwsAccessKeyCredentialsType,
    }

    impl ::std::convert::From<&PackConnectionAwsAccessKeyCredentials> for PackConnectionAwsAccessKeyCredentials {
        fn from(value: &PackConnectionAwsAccessKeyCredentials) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionAwsAccessKeyCredentialsType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "awsAccessKey"
    ///  ],
    ///  "x-tsType": "PackConnectionType.AwsAccessKey"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackConnectionAwsAccessKeyCredentialsType {
        #[serde(rename = "awsAccessKey")]
        AwsAccessKey,
    }

    impl ::std::convert::From<&Self> for PackConnectionAwsAccessKeyCredentialsType {
        fn from(value: &PackConnectionAwsAccessKeyCredentialsType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackConnectionAwsAccessKeyCredentialsType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AwsAccessKey => f.write_str("awsAccessKey"),
            }
        }
    }

    impl ::std::str::FromStr for PackConnectionAwsAccessKeyCredentialsType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "awsAccessKey" => Ok(Self::AwsAccessKey),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackConnectionAwsAccessKeyCredentialsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackConnectionAwsAccessKeyCredentialsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackConnectionAwsAccessKeyCredentialsType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PackConnectionAwsAccessKeyMetadata`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "maskedAccessKeyId",
    ///    "maskedSecretAccessKey",
    ///    "service",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "maskedAccessKeyId": {
    ///      "type": "string"
    ///    },
    ///    "maskedSecretAccessKey": {
    ///      "type": "string"
    ///    },
    ///    "service": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "awsAccessKey"
    ///      ],
    ///      "x-tsType": "PackConnectionType.AwsAccessKey"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackConnectionAwsAccessKeyMetadata"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionAwsAccessKeyMetadata {
        #[serde(rename = "maskedAccessKeyId")]
        pub masked_access_key_id: ::std::string::String,
        #[serde(rename = "maskedSecretAccessKey")]
        pub masked_secret_access_key: ::std::string::String,
        pub service: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: PackConnectionAwsAccessKeyMetadataType,
    }

    impl ::std::convert::From<&PackConnectionAwsAccessKeyMetadata> for PackConnectionAwsAccessKeyMetadata {
        fn from(value: &PackConnectionAwsAccessKeyMetadata) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionAwsAccessKeyMetadataType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "awsAccessKey"
    ///  ],
    ///  "x-tsType": "PackConnectionType.AwsAccessKey"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackConnectionAwsAccessKeyMetadataType {
        #[serde(rename = "awsAccessKey")]
        AwsAccessKey,
    }

    impl ::std::convert::From<&Self> for PackConnectionAwsAccessKeyMetadataType {
        fn from(value: &PackConnectionAwsAccessKeyMetadataType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackConnectionAwsAccessKeyMetadataType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AwsAccessKey => f.write_str("awsAccessKey"),
            }
        }
    }

    impl ::std::str::FromStr for PackConnectionAwsAccessKeyMetadataType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "awsAccessKey" => Ok(Self::AwsAccessKey),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackConnectionAwsAccessKeyMetadataType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackConnectionAwsAccessKeyMetadataType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackConnectionAwsAccessKeyMetadataType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PackConnectionAwsAccessKeyPatch`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "accessKeyId": {
    ///      "type": "string"
    ///    },
    ///    "secretAccessKey": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "awsAccessKey"
    ///      ],
    ///      "x-tsType": "PackConnectionType.AwsAccessKey"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackConnectionAwsAccessKeyPatch"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionAwsAccessKeyPatch {
        #[serde(rename = "accessKeyId", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub access_key_id: ::std::option::Option<::std::string::String>,
        #[serde(rename = "secretAccessKey", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub secret_access_key: ::std::option::Option<::std::string::String>,
        #[serde(rename = "type")]
        pub type_: PackConnectionAwsAccessKeyPatchType,
    }

    impl ::std::convert::From<&PackConnectionAwsAccessKeyPatch> for PackConnectionAwsAccessKeyPatch {
        fn from(value: &PackConnectionAwsAccessKeyPatch) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionAwsAccessKeyPatchType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "awsAccessKey"
    ///  ],
    ///  "x-tsType": "PackConnectionType.AwsAccessKey"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackConnectionAwsAccessKeyPatchType {
        #[serde(rename = "awsAccessKey")]
        AwsAccessKey,
    }

    impl ::std::convert::From<&Self> for PackConnectionAwsAccessKeyPatchType {
        fn from(value: &PackConnectionAwsAccessKeyPatchType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackConnectionAwsAccessKeyPatchType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AwsAccessKey => f.write_str("awsAccessKey"),
            }
        }
    }

    impl ::std::str::FromStr for PackConnectionAwsAccessKeyPatchType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "awsAccessKey" => Ok(Self::AwsAccessKey),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackConnectionAwsAccessKeyPatchType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackConnectionAwsAccessKeyPatchType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackConnectionAwsAccessKeyPatchType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PackConnectionAwsAssumeRoleCredentials`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "externalId",
    ///    "roleArn",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "externalId": {
    ///      "type": "string"
    ///    },
    ///    "roleArn": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "awsAssumeRole"
    ///      ],
    ///      "x-tsType": "PackConnectionType.AwsAssumeRole"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackConnectionAwsAssumeRoleCredentials"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionAwsAssumeRoleCredentials {
        #[serde(rename = "externalId")]
        pub external_id: ::std::string::String,
        #[serde(rename = "roleArn")]
        pub role_arn: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: PackConnectionAwsAssumeRoleCredentialsType,
    }

    impl ::std::convert::From<&PackConnectionAwsAssumeRoleCredentials> for PackConnectionAwsAssumeRoleCredentials {
        fn from(value: &PackConnectionAwsAssumeRoleCredentials) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionAwsAssumeRoleCredentialsType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "awsAssumeRole"
    ///  ],
    ///  "x-tsType": "PackConnectionType.AwsAssumeRole"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackConnectionAwsAssumeRoleCredentialsType {
        #[serde(rename = "awsAssumeRole")]
        AwsAssumeRole,
    }

    impl ::std::convert::From<&Self> for PackConnectionAwsAssumeRoleCredentialsType {
        fn from(value: &PackConnectionAwsAssumeRoleCredentialsType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackConnectionAwsAssumeRoleCredentialsType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AwsAssumeRole => f.write_str("awsAssumeRole"),
            }
        }
    }

    impl ::std::str::FromStr for PackConnectionAwsAssumeRoleCredentialsType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "awsAssumeRole" => Ok(Self::AwsAssumeRole),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackConnectionAwsAssumeRoleCredentialsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackConnectionAwsAssumeRoleCredentialsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackConnectionAwsAssumeRoleCredentialsType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PackConnectionAwsAssumeRoleMetadata`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "externalId",
    ///    "roleArn",
    ///    "service",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "externalId": {
    ///      "type": "string"
    ///    },
    ///    "roleArn": {
    ///      "type": "string"
    ///    },
    ///    "service": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "awsAssumeRole"
    ///      ],
    ///      "x-tsType": "PackConnectionType.AwsAssumeRole"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackConnectionAwsAssumeRoleMetadata"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionAwsAssumeRoleMetadata {
        #[serde(rename = "externalId")]
        pub external_id: ::std::string::String,
        #[serde(rename = "roleArn")]
        pub role_arn: ::std::string::String,
        pub service: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: PackConnectionAwsAssumeRoleMetadataType,
    }

    impl ::std::convert::From<&PackConnectionAwsAssumeRoleMetadata> for PackConnectionAwsAssumeRoleMetadata {
        fn from(value: &PackConnectionAwsAssumeRoleMetadata) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionAwsAssumeRoleMetadataType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "awsAssumeRole"
    ///  ],
    ///  "x-tsType": "PackConnectionType.AwsAssumeRole"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackConnectionAwsAssumeRoleMetadataType {
        #[serde(rename = "awsAssumeRole")]
        AwsAssumeRole,
    }

    impl ::std::convert::From<&Self> for PackConnectionAwsAssumeRoleMetadataType {
        fn from(value: &PackConnectionAwsAssumeRoleMetadataType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackConnectionAwsAssumeRoleMetadataType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AwsAssumeRole => f.write_str("awsAssumeRole"),
            }
        }
    }

    impl ::std::str::FromStr for PackConnectionAwsAssumeRoleMetadataType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "awsAssumeRole" => Ok(Self::AwsAssumeRole),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackConnectionAwsAssumeRoleMetadataType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackConnectionAwsAssumeRoleMetadataType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackConnectionAwsAssumeRoleMetadataType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PackConnectionAwsAssumeRolePatch`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "externalId": {
    ///      "type": "string"
    ///    },
    ///    "roleArn": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "awsAssumeRole"
    ///      ],
    ///      "x-tsType": "PackConnectionType.AwsAssumeRole"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackConnectionAwsAssumeRolePatch"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionAwsAssumeRolePatch {
        #[serde(rename = "externalId", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub external_id: ::std::option::Option<::std::string::String>,
        #[serde(rename = "roleArn", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub role_arn: ::std::option::Option<::std::string::String>,
        #[serde(rename = "type")]
        pub type_: PackConnectionAwsAssumeRolePatchType,
    }

    impl ::std::convert::From<&PackConnectionAwsAssumeRolePatch> for PackConnectionAwsAssumeRolePatch {
        fn from(value: &PackConnectionAwsAssumeRolePatch) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionAwsAssumeRolePatchType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "awsAssumeRole"
    ///  ],
    ///  "x-tsType": "PackConnectionType.AwsAssumeRole"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackConnectionAwsAssumeRolePatchType {
        #[serde(rename = "awsAssumeRole")]
        AwsAssumeRole,
    }

    impl ::std::convert::From<&Self> for PackConnectionAwsAssumeRolePatchType {
        fn from(value: &PackConnectionAwsAssumeRolePatchType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackConnectionAwsAssumeRolePatchType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AwsAssumeRole => f.write_str("awsAssumeRole"),
            }
        }
    }

    impl ::std::str::FromStr for PackConnectionAwsAssumeRolePatchType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "awsAssumeRole" => Ok(Self::AwsAssumeRole),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackConnectionAwsAssumeRolePatchType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackConnectionAwsAssumeRolePatchType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackConnectionAwsAssumeRolePatchType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PackConnectionCustomCredentials`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "params",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "params": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "key",
    ///          "value"
    ///        ],
    ///        "properties": {
    ///          "key": {
    ///            "type": "string"
    ///          },
    ///          "value": {
    ///            "type": "string"
    ///          }
    ///        },
    ///        "additionalProperties": false
    ///      }
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "custom"
    ///      ],
    ///      "x-tsType": "PackConnectionType.Custom"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackConnectionCustomCredentials"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionCustomCredentials {
        pub params: ::std::vec::Vec<PackConnectionCustomCredentialsParamsItem>,
        #[serde(rename = "type")]
        pub type_: PackConnectionCustomCredentialsType,
    }

    impl ::std::convert::From<&PackConnectionCustomCredentials> for PackConnectionCustomCredentials {
        fn from(value: &PackConnectionCustomCredentials) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionCustomCredentialsParamsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "key",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "key": {
    ///      "type": "string"
    ///    },
    ///    "value": {
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionCustomCredentialsParamsItem {
        pub key: ::std::string::String,
        pub value: ::std::string::String,
    }

    impl ::std::convert::From<&PackConnectionCustomCredentialsParamsItem> for PackConnectionCustomCredentialsParamsItem {
        fn from(value: &PackConnectionCustomCredentialsParamsItem) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionCustomCredentialsType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "custom"
    ///  ],
    ///  "x-tsType": "PackConnectionType.Custom"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackConnectionCustomCredentialsType {
        #[serde(rename = "custom")]
        Custom,
    }

    impl ::std::convert::From<&Self> for PackConnectionCustomCredentialsType {
        fn from(value: &PackConnectionCustomCredentialsType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackConnectionCustomCredentialsType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Custom => f.write_str("custom"),
            }
        }
    }

    impl ::std::str::FromStr for PackConnectionCustomCredentialsType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "custom" => Ok(Self::Custom),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackConnectionCustomCredentialsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackConnectionCustomCredentialsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackConnectionCustomCredentialsType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PackConnectionCustomMetadata`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "domain",
    ///    "params",
    ///    "presetKeys",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "domain": {
    ///      "description": "The domain corresponding to the pre-authorized
    /// network domain in the pack.",
    ///      "type": "string"
    ///    },
    ///    "params": {
    ///      "description": "An array of objects containing the parameter key
    /// and masked value.",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "key",
    ///          "maskedValue"
    ///        ],
    ///        "properties": {
    ///          "key": {
    ///            "type": "string"
    ///          },
    ///          "maskedValue": {
    ///            "type": "string"
    ///          }
    ///        },
    ///        "additionalProperties": false
    ///      }
    ///    },
    ///    "presetKeys": {
    ///      "description": "An array containing the keys of parameters
    /// specified by the authentication config.",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "custom"
    ///      ],
    ///      "x-tsType": "PackConnectionType.Custom"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackConnectionCustomMetadata"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionCustomMetadata {
        ///The domain corresponding to the pre-authorized network domain in the
        /// pack.
        pub domain: ::std::string::String,
        ///An array of objects containing the parameter key and masked value.
        pub params: ::std::vec::Vec<PackConnectionCustomMetadataParamsItem>,
        ///An array containing the keys of parameters specified by the
        /// authentication config.
        #[serde(rename = "presetKeys")]
        pub preset_keys: ::std::vec::Vec<::std::string::String>,
        #[serde(rename = "type")]
        pub type_: PackConnectionCustomMetadataType,
    }

    impl ::std::convert::From<&PackConnectionCustomMetadata> for PackConnectionCustomMetadata {
        fn from(value: &PackConnectionCustomMetadata) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionCustomMetadataParamsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "key",
    ///    "maskedValue"
    ///  ],
    ///  "properties": {
    ///    "key": {
    ///      "type": "string"
    ///    },
    ///    "maskedValue": {
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionCustomMetadataParamsItem {
        pub key: ::std::string::String,
        #[serde(rename = "maskedValue")]
        pub masked_value: ::std::string::String,
    }

    impl ::std::convert::From<&PackConnectionCustomMetadataParamsItem> for PackConnectionCustomMetadataParamsItem {
        fn from(value: &PackConnectionCustomMetadataParamsItem) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionCustomMetadataType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "custom"
    ///  ],
    ///  "x-tsType": "PackConnectionType.Custom"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackConnectionCustomMetadataType {
        #[serde(rename = "custom")]
        Custom,
    }

    impl ::std::convert::From<&Self> for PackConnectionCustomMetadataType {
        fn from(value: &PackConnectionCustomMetadataType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackConnectionCustomMetadataType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Custom => f.write_str("custom"),
            }
        }
    }

    impl ::std::str::FromStr for PackConnectionCustomMetadataType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "custom" => Ok(Self::Custom),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackConnectionCustomMetadataType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackConnectionCustomMetadataType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackConnectionCustomMetadataType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PackConnectionCustomPatch`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "paramsToPatch": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "key",
    ///          "value"
    ///        ],
    ///        "properties": {
    ///          "key": {
    ///            "type": "string"
    ///          },
    ///          "value": {
    ///            "type": "string"
    ///          }
    ///        },
    ///        "additionalProperties": false
    ///      }
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "custom"
    ///      ],
    ///      "x-tsType": "PackConnectionType.Custom"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackConnectionCustomPatch"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionCustomPatch {
        #[serde(rename = "paramsToPatch", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub params_to_patch: ::std::vec::Vec<PackConnectionCustomPatchParamsToPatchItem>,
        #[serde(rename = "type")]
        pub type_: PackConnectionCustomPatchType,
    }

    impl ::std::convert::From<&PackConnectionCustomPatch> for PackConnectionCustomPatch {
        fn from(value: &PackConnectionCustomPatch) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionCustomPatchParamsToPatchItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "key",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "key": {
    ///      "type": "string"
    ///    },
    ///    "value": {
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionCustomPatchParamsToPatchItem {
        pub key: ::std::string::String,
        pub value: ::std::string::String,
    }

    impl ::std::convert::From<&PackConnectionCustomPatchParamsToPatchItem> for PackConnectionCustomPatchParamsToPatchItem {
        fn from(value: &PackConnectionCustomPatchParamsToPatchItem) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionCustomPatchType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "custom"
    ///  ],
    ///  "x-tsType": "PackConnectionType.Custom"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackConnectionCustomPatchType {
        #[serde(rename = "custom")]
        Custom,
    }

    impl ::std::convert::From<&Self> for PackConnectionCustomPatchType {
        fn from(value: &PackConnectionCustomPatchType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackConnectionCustomPatchType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Custom => f.write_str("custom"),
            }
        }
    }

    impl ::std::str::FromStr for PackConnectionCustomPatchType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "custom" => Ok(Self::Custom),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackConnectionCustomPatchType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackConnectionCustomPatchType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackConnectionCustomPatchType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PackConnectionGoogleServiceAccountCredentials`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "serviceAccountKey",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "serviceAccountKey": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "googleServiceAccount"
    ///      ],
    ///      "x-tsType": "PackConnectionType.GoogleServiceAccount"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackConnectionGoogleServiceAccountCredentials"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionGoogleServiceAccountCredentials {
        #[serde(rename = "serviceAccountKey")]
        pub service_account_key: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: PackConnectionGoogleServiceAccountCredentialsType,
    }

    impl ::std::convert::From<&PackConnectionGoogleServiceAccountCredentials> for PackConnectionGoogleServiceAccountCredentials {
        fn from(value: &PackConnectionGoogleServiceAccountCredentials) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionGoogleServiceAccountCredentialsType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "googleServiceAccount"
    ///  ],
    ///  "x-tsType": "PackConnectionType.GoogleServiceAccount"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackConnectionGoogleServiceAccountCredentialsType {
        #[serde(rename = "googleServiceAccount")]
        GoogleServiceAccount,
    }

    impl ::std::convert::From<&Self> for PackConnectionGoogleServiceAccountCredentialsType {
        fn from(value: &PackConnectionGoogleServiceAccountCredentialsType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackConnectionGoogleServiceAccountCredentialsType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GoogleServiceAccount => f.write_str("googleServiceAccount"),
            }
        }
    }

    impl ::std::str::FromStr for PackConnectionGoogleServiceAccountCredentialsType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "googleServiceAccount" => Ok(Self::GoogleServiceAccount),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackConnectionGoogleServiceAccountCredentialsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackConnectionGoogleServiceAccountCredentialsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackConnectionGoogleServiceAccountCredentialsType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PackConnectionGoogleServiceAccountMetadata`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "maskedServiceAccountKey",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "maskedServiceAccountKey": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "googleServiceAccount"
    ///      ],
    ///      "x-tsType": "PackConnectionType.GoogleServiceAccount"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackConnectionGoogleServiceAccountMetadata"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionGoogleServiceAccountMetadata {
        #[serde(rename = "maskedServiceAccountKey")]
        pub masked_service_account_key: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: PackConnectionGoogleServiceAccountMetadataType,
    }

    impl ::std::convert::From<&PackConnectionGoogleServiceAccountMetadata> for PackConnectionGoogleServiceAccountMetadata {
        fn from(value: &PackConnectionGoogleServiceAccountMetadata) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionGoogleServiceAccountMetadataType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "googleServiceAccount"
    ///  ],
    ///  "x-tsType": "PackConnectionType.GoogleServiceAccount"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackConnectionGoogleServiceAccountMetadataType {
        #[serde(rename = "googleServiceAccount")]
        GoogleServiceAccount,
    }

    impl ::std::convert::From<&Self> for PackConnectionGoogleServiceAccountMetadataType {
        fn from(value: &PackConnectionGoogleServiceAccountMetadataType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackConnectionGoogleServiceAccountMetadataType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GoogleServiceAccount => f.write_str("googleServiceAccount"),
            }
        }
    }

    impl ::std::str::FromStr for PackConnectionGoogleServiceAccountMetadataType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "googleServiceAccount" => Ok(Self::GoogleServiceAccount),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackConnectionGoogleServiceAccountMetadataType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackConnectionGoogleServiceAccountMetadataType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackConnectionGoogleServiceAccountMetadataType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PackConnectionGoogleServiceAccountPatch`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "serviceAccountKey": {
    ///      "type": "string",
    ///      "maxLength": 512
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "googleServiceAccount"
    ///      ],
    ///      "x-tsType": "PackConnectionType.GoogleServiceAccount"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackConnectionGoogleServiceAccountPatch"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionGoogleServiceAccountPatch {
        #[serde(rename = "serviceAccountKey", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub service_account_key: ::std::option::Option<PackConnectionGoogleServiceAccountPatchServiceAccountKey>,
        #[serde(rename = "type")]
        pub type_: PackConnectionGoogleServiceAccountPatchType,
    }

    impl ::std::convert::From<&PackConnectionGoogleServiceAccountPatch> for PackConnectionGoogleServiceAccountPatch {
        fn from(value: &PackConnectionGoogleServiceAccountPatch) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionGoogleServiceAccountPatchServiceAccountKey`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 512
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PackConnectionGoogleServiceAccountPatchServiceAccountKey(::std::string::String);
    impl ::std::ops::Deref for PackConnectionGoogleServiceAccountPatchServiceAccountKey {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PackConnectionGoogleServiceAccountPatchServiceAccountKey> for ::std::string::String {
        fn from(value: PackConnectionGoogleServiceAccountPatchServiceAccountKey) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PackConnectionGoogleServiceAccountPatchServiceAccountKey> for PackConnectionGoogleServiceAccountPatchServiceAccountKey {
        fn from(value: &PackConnectionGoogleServiceAccountPatchServiceAccountKey) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PackConnectionGoogleServiceAccountPatchServiceAccountKey {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 512usize {
                return Err("longer than 512 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PackConnectionGoogleServiceAccountPatchServiceAccountKey {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackConnectionGoogleServiceAccountPatchServiceAccountKey {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackConnectionGoogleServiceAccountPatchServiceAccountKey {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PackConnectionGoogleServiceAccountPatchServiceAccountKey {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///`PackConnectionGoogleServiceAccountPatchType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "googleServiceAccount"
    ///  ],
    ///  "x-tsType": "PackConnectionType.GoogleServiceAccount"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackConnectionGoogleServiceAccountPatchType {
        #[serde(rename = "googleServiceAccount")]
        GoogleServiceAccount,
    }

    impl ::std::convert::From<&Self> for PackConnectionGoogleServiceAccountPatchType {
        fn from(value: &PackConnectionGoogleServiceAccountPatchType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackConnectionGoogleServiceAccountPatchType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GoogleServiceAccount => f.write_str("googleServiceAccount"),
            }
        }
    }

    impl ::std::str::FromStr for PackConnectionGoogleServiceAccountPatchType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "googleServiceAccount" => Ok(Self::GoogleServiceAccount),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackConnectionGoogleServiceAccountPatchType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackConnectionGoogleServiceAccountPatchType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackConnectionGoogleServiceAccountPatchType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PackConnectionHeaderCredentials`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "token",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "token": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "header"
    ///      ],
    ///      "x-tsType": "PackConnectionType.Header"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackConnectionHeaderCredentials"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionHeaderCredentials {
        pub token: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: PackConnectionHeaderCredentialsType,
    }

    impl ::std::convert::From<&PackConnectionHeaderCredentials> for PackConnectionHeaderCredentials {
        fn from(value: &PackConnectionHeaderCredentials) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionHeaderCredentialsType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "header"
    ///  ],
    ///  "x-tsType": "PackConnectionType.Header"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackConnectionHeaderCredentialsType {
        #[serde(rename = "header")]
        Header,
    }

    impl ::std::convert::From<&Self> for PackConnectionHeaderCredentialsType {
        fn from(value: &PackConnectionHeaderCredentialsType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackConnectionHeaderCredentialsType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Header => f.write_str("header"),
            }
        }
    }

    impl ::std::str::FromStr for PackConnectionHeaderCredentialsType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "header" => Ok(Self::Header),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackConnectionHeaderCredentialsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackConnectionHeaderCredentialsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackConnectionHeaderCredentialsType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PackConnectionHeaderMetadata`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "headerName",
    ///    "tokenPrefix",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "headerName": {
    ///      "type": "string"
    ///    },
    ///    "maskedToken": {
    ///      "type": "string"
    ///    },
    ///    "tokenPrefix": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "header"
    ///      ],
    ///      "x-tsType": "PackConnectionType.Header"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackConnectionHeaderMetadata"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionHeaderMetadata {
        #[serde(rename = "headerName")]
        pub header_name: ::std::string::String,
        #[serde(rename = "maskedToken", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub masked_token: ::std::option::Option<::std::string::String>,
        #[serde(rename = "tokenPrefix")]
        pub token_prefix: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: PackConnectionHeaderMetadataType,
    }

    impl ::std::convert::From<&PackConnectionHeaderMetadata> for PackConnectionHeaderMetadata {
        fn from(value: &PackConnectionHeaderMetadata) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionHeaderMetadataType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "header"
    ///  ],
    ///  "x-tsType": "PackConnectionType.Header"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackConnectionHeaderMetadataType {
        #[serde(rename = "header")]
        Header,
    }

    impl ::std::convert::From<&Self> for PackConnectionHeaderMetadataType {
        fn from(value: &PackConnectionHeaderMetadataType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackConnectionHeaderMetadataType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Header => f.write_str("header"),
            }
        }
    }

    impl ::std::str::FromStr for PackConnectionHeaderMetadataType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "header" => Ok(Self::Header),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackConnectionHeaderMetadataType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackConnectionHeaderMetadataType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackConnectionHeaderMetadataType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PackConnectionHeaderPatch`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "token": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "header"
    ///      ],
    ///      "x-tsType": "PackConnectionType.Header"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackConnectionHeaderPatch"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionHeaderPatch {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub token: ::std::option::Option<::std::string::String>,
        #[serde(rename = "type")]
        pub type_: PackConnectionHeaderPatchType,
    }

    impl ::std::convert::From<&PackConnectionHeaderPatch> for PackConnectionHeaderPatch {
        fn from(value: &PackConnectionHeaderPatch) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionHeaderPatchType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "header"
    ///  ],
    ///  "x-tsType": "PackConnectionType.Header"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackConnectionHeaderPatchType {
        #[serde(rename = "header")]
        Header,
    }

    impl ::std::convert::From<&Self> for PackConnectionHeaderPatchType {
        fn from(value: &PackConnectionHeaderPatchType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackConnectionHeaderPatchType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Header => f.write_str("header"),
            }
        }
    }

    impl ::std::str::FromStr for PackConnectionHeaderPatchType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "header" => Ok(Self::Header),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackConnectionHeaderPatchType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackConnectionHeaderPatchType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackConnectionHeaderPatchType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PackConnectionHttpBasicCredentials`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "type",
    ///    "username"
    ///  ],
    ///  "properties": {
    ///    "password": {
    ///      "type": "string",
    ///      "x-allow-empty": true
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "httpBasic"
    ///      ],
    ///      "x-tsType": "PackConnectionType.HttpBasic"
    ///    },
    ///    "username": {
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackConnectionHttpBasicCredentials"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionHttpBasicCredentials {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub password: ::std::option::Option<::std::string::String>,
        #[serde(rename = "type")]
        pub type_: PackConnectionHttpBasicCredentialsType,
        pub username: ::std::string::String,
    }

    impl ::std::convert::From<&PackConnectionHttpBasicCredentials> for PackConnectionHttpBasicCredentials {
        fn from(value: &PackConnectionHttpBasicCredentials) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionHttpBasicCredentialsType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "httpBasic"
    ///  ],
    ///  "x-tsType": "PackConnectionType.HttpBasic"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackConnectionHttpBasicCredentialsType {
        #[serde(rename = "httpBasic")]
        HttpBasic,
    }

    impl ::std::convert::From<&Self> for PackConnectionHttpBasicCredentialsType {
        fn from(value: &PackConnectionHttpBasicCredentialsType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackConnectionHttpBasicCredentialsType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::HttpBasic => f.write_str("httpBasic"),
            }
        }
    }

    impl ::std::str::FromStr for PackConnectionHttpBasicCredentialsType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "httpBasic" => Ok(Self::HttpBasic),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackConnectionHttpBasicCredentialsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackConnectionHttpBasicCredentialsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackConnectionHttpBasicCredentialsType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PackConnectionHttpBasicMetadata`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "maskedPassword": {
    ///      "type": "string"
    ///    },
    ///    "maskedUsername": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "httpBasic"
    ///      ],
    ///      "x-tsType": "PackConnectionType.HttpBasic"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackConnectionHttpBasicMetadata"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionHttpBasicMetadata {
        #[serde(rename = "maskedPassword", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub masked_password: ::std::option::Option<::std::string::String>,
        #[serde(rename = "maskedUsername", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub masked_username: ::std::option::Option<::std::string::String>,
        #[serde(rename = "type")]
        pub type_: PackConnectionHttpBasicMetadataType,
    }

    impl ::std::convert::From<&PackConnectionHttpBasicMetadata> for PackConnectionHttpBasicMetadata {
        fn from(value: &PackConnectionHttpBasicMetadata) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionHttpBasicMetadataType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "httpBasic"
    ///  ],
    ///  "x-tsType": "PackConnectionType.HttpBasic"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackConnectionHttpBasicMetadataType {
        #[serde(rename = "httpBasic")]
        HttpBasic,
    }

    impl ::std::convert::From<&Self> for PackConnectionHttpBasicMetadataType {
        fn from(value: &PackConnectionHttpBasicMetadataType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackConnectionHttpBasicMetadataType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::HttpBasic => f.write_str("httpBasic"),
            }
        }
    }

    impl ::std::str::FromStr for PackConnectionHttpBasicMetadataType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "httpBasic" => Ok(Self::HttpBasic),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackConnectionHttpBasicMetadataType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackConnectionHttpBasicMetadataType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackConnectionHttpBasicMetadataType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PackConnectionHttpBasicPatch`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "password": {
    ///      "type": "string",
    ///      "x-allow-empty": true
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "httpBasic"
    ///      ],
    ///      "x-tsType": "PackConnectionType.HttpBasic"
    ///    },
    ///    "username": {
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackConnectionHttpBasicPatch"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionHttpBasicPatch {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub password: ::std::option::Option<::std::string::String>,
        #[serde(rename = "type")]
        pub type_: PackConnectionHttpBasicPatchType,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub username: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&PackConnectionHttpBasicPatch> for PackConnectionHttpBasicPatch {
        fn from(value: &PackConnectionHttpBasicPatch) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionHttpBasicPatchType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "httpBasic"
    ///  ],
    ///  "x-tsType": "PackConnectionType.HttpBasic"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackConnectionHttpBasicPatchType {
        #[serde(rename = "httpBasic")]
        HttpBasic,
    }

    impl ::std::convert::From<&Self> for PackConnectionHttpBasicPatchType {
        fn from(value: &PackConnectionHttpBasicPatchType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackConnectionHttpBasicPatchType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::HttpBasic => f.write_str("httpBasic"),
            }
        }
    }

    impl ::std::str::FromStr for PackConnectionHttpBasicPatchType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "httpBasic" => Ok(Self::HttpBasic),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackConnectionHttpBasicPatchType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackConnectionHttpBasicPatchType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackConnectionHttpBasicPatchType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PackConnectionMultiHeaderCredentials`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "tokens",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "tokens": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "key",
    ///          "value"
    ///        ],
    ///        "properties": {
    ///          "key": {
    ///            "type": "string"
    ///          },
    ///          "value": {
    ///            "type": "string"
    ///          }
    ///        },
    ///        "additionalProperties": false
    ///      }
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "multiHeader"
    ///      ],
    ///      "x-tsType": "PackConnectionType.MultiHeader"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackConnectionMultiHeaderCredentials"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionMultiHeaderCredentials {
        pub tokens: ::std::vec::Vec<PackConnectionMultiHeaderCredentialsTokensItem>,
        #[serde(rename = "type")]
        pub type_: PackConnectionMultiHeaderCredentialsType,
    }

    impl ::std::convert::From<&PackConnectionMultiHeaderCredentials> for PackConnectionMultiHeaderCredentials {
        fn from(value: &PackConnectionMultiHeaderCredentials) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionMultiHeaderCredentialsTokensItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "key",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "key": {
    ///      "type": "string"
    ///    },
    ///    "value": {
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionMultiHeaderCredentialsTokensItem {
        pub key: ::std::string::String,
        pub value: ::std::string::String,
    }

    impl ::std::convert::From<&PackConnectionMultiHeaderCredentialsTokensItem> for PackConnectionMultiHeaderCredentialsTokensItem {
        fn from(value: &PackConnectionMultiHeaderCredentialsTokensItem) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionMultiHeaderCredentialsType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "multiHeader"
    ///  ],
    ///  "x-tsType": "PackConnectionType.MultiHeader"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackConnectionMultiHeaderCredentialsType {
        #[serde(rename = "multiHeader")]
        MultiHeader,
    }

    impl ::std::convert::From<&Self> for PackConnectionMultiHeaderCredentialsType {
        fn from(value: &PackConnectionMultiHeaderCredentialsType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackConnectionMultiHeaderCredentialsType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::MultiHeader => f.write_str("multiHeader"),
            }
        }
    }

    impl ::std::str::FromStr for PackConnectionMultiHeaderCredentialsType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "multiHeader" => Ok(Self::MultiHeader),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackConnectionMultiHeaderCredentialsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackConnectionMultiHeaderCredentialsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackConnectionMultiHeaderCredentialsType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PackConnectionMultiHeaderMetadata`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "headers",
    ///    "presets",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "headers": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "headerName",
    ///          "maskedToken"
    ///        ],
    ///        "properties": {
    ///          "headerName": {
    ///            "type": "string"
    ///          },
    ///          "maskedToken": {
    ///            "type": "string"
    ///          },
    ///          "tokenPrefix": {
    ///            "type": "string"
    ///          }
    ///        },
    ///        "additionalProperties": false
    ///      }
    ///    },
    ///    "presets": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "headerName"
    ///        ],
    ///        "properties": {
    ///          "headerName": {
    ///            "type": "string"
    ///          },
    ///          "tokenPrefix": {
    ///            "type": "string"
    ///          }
    ///        },
    ///        "additionalProperties": false
    ///      }
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "multiHeader"
    ///      ],
    ///      "x-tsType": "PackConnectionType.MultiHeader"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackConnectionMultiHeaderMetadata"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionMultiHeaderMetadata {
        pub headers: ::std::vec::Vec<PackConnectionMultiHeaderMetadataHeadersItem>,
        pub presets: ::std::vec::Vec<PackConnectionMultiHeaderMetadataPresetsItem>,
        #[serde(rename = "type")]
        pub type_: PackConnectionMultiHeaderMetadataType,
    }

    impl ::std::convert::From<&PackConnectionMultiHeaderMetadata> for PackConnectionMultiHeaderMetadata {
        fn from(value: &PackConnectionMultiHeaderMetadata) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionMultiHeaderMetadataHeadersItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "headerName",
    ///    "maskedToken"
    ///  ],
    ///  "properties": {
    ///    "headerName": {
    ///      "type": "string"
    ///    },
    ///    "maskedToken": {
    ///      "type": "string"
    ///    },
    ///    "tokenPrefix": {
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionMultiHeaderMetadataHeadersItem {
        #[serde(rename = "headerName")]
        pub header_name: ::std::string::String,
        #[serde(rename = "maskedToken")]
        pub masked_token: ::std::string::String,
        #[serde(rename = "tokenPrefix", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub token_prefix: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&PackConnectionMultiHeaderMetadataHeadersItem> for PackConnectionMultiHeaderMetadataHeadersItem {
        fn from(value: &PackConnectionMultiHeaderMetadataHeadersItem) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionMultiHeaderMetadataPresetsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "headerName"
    ///  ],
    ///  "properties": {
    ///    "headerName": {
    ///      "type": "string"
    ///    },
    ///    "tokenPrefix": {
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionMultiHeaderMetadataPresetsItem {
        #[serde(rename = "headerName")]
        pub header_name: ::std::string::String,
        #[serde(rename = "tokenPrefix", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub token_prefix: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&PackConnectionMultiHeaderMetadataPresetsItem> for PackConnectionMultiHeaderMetadataPresetsItem {
        fn from(value: &PackConnectionMultiHeaderMetadataPresetsItem) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionMultiHeaderMetadataType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "multiHeader"
    ///  ],
    ///  "x-tsType": "PackConnectionType.MultiHeader"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackConnectionMultiHeaderMetadataType {
        #[serde(rename = "multiHeader")]
        MultiHeader,
    }

    impl ::std::convert::From<&Self> for PackConnectionMultiHeaderMetadataType {
        fn from(value: &PackConnectionMultiHeaderMetadataType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackConnectionMultiHeaderMetadataType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::MultiHeader => f.write_str("multiHeader"),
            }
        }
    }

    impl ::std::str::FromStr for PackConnectionMultiHeaderMetadataType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "multiHeader" => Ok(Self::MultiHeader),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackConnectionMultiHeaderMetadataType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackConnectionMultiHeaderMetadataType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackConnectionMultiHeaderMetadataType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PackConnectionMultiHeaderPatch`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "tokensToPatch": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "key",
    ///          "value"
    ///        ],
    ///        "properties": {
    ///          "key": {
    ///            "type": "string"
    ///          },
    ///          "value": {
    ///            "type": "string"
    ///          }
    ///        },
    ///        "additionalProperties": false
    ///      }
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "multiHeader"
    ///      ],
    ///      "x-tsType": "PackConnectionType.MultiHeader"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackConnectionMultiHeaderPatch"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionMultiHeaderPatch {
        #[serde(rename = "tokensToPatch", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub tokens_to_patch: ::std::vec::Vec<PackConnectionMultiHeaderPatchTokensToPatchItem>,
        #[serde(rename = "type")]
        pub type_: PackConnectionMultiHeaderPatchType,
    }

    impl ::std::convert::From<&PackConnectionMultiHeaderPatch> for PackConnectionMultiHeaderPatch {
        fn from(value: &PackConnectionMultiHeaderPatch) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionMultiHeaderPatchTokensToPatchItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "key",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "key": {
    ///      "type": "string"
    ///    },
    ///    "value": {
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionMultiHeaderPatchTokensToPatchItem {
        pub key: ::std::string::String,
        pub value: ::std::string::String,
    }

    impl ::std::convert::From<&PackConnectionMultiHeaderPatchTokensToPatchItem> for PackConnectionMultiHeaderPatchTokensToPatchItem {
        fn from(value: &PackConnectionMultiHeaderPatchTokensToPatchItem) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionMultiHeaderPatchType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "multiHeader"
    ///  ],
    ///  "x-tsType": "PackConnectionType.MultiHeader"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackConnectionMultiHeaderPatchType {
        #[serde(rename = "multiHeader")]
        MultiHeader,
    }

    impl ::std::convert::From<&Self> for PackConnectionMultiHeaderPatchType {
        fn from(value: &PackConnectionMultiHeaderPatchType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackConnectionMultiHeaderPatchType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::MultiHeader => f.write_str("multiHeader"),
            }
        }
    }

    impl ::std::str::FromStr for PackConnectionMultiHeaderPatchType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "multiHeader" => Ok(Self::MultiHeader),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackConnectionMultiHeaderPatchType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackConnectionMultiHeaderPatchType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackConnectionMultiHeaderPatchType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PackConnectionOauth2ClientCredentials`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "clientId",
    ///    "clientSecret",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "clientId": {
    ///      "type": "string",
    ///      "maxLength": 512
    ///    },
    ///    "clientSecret": {
    ///      "type": "string",
    ///      "maxLength": 512
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "oauth2ClientCredentials"
    ///      ],
    ///      "x-tsType": "PackConnectionType.OAuth2ClientCredentials"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackConnectionOauth2ClientCredentials"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionOauth2ClientCredentials {
        #[serde(rename = "clientId")]
        pub client_id: PackConnectionOauth2ClientCredentialsClientId,
        #[serde(rename = "clientSecret")]
        pub client_secret: PackConnectionOauth2ClientCredentialsClientSecret,
        #[serde(rename = "type")]
        pub type_: PackConnectionOauth2ClientCredentialsType,
    }

    impl ::std::convert::From<&PackConnectionOauth2ClientCredentials> for PackConnectionOauth2ClientCredentials {
        fn from(value: &PackConnectionOauth2ClientCredentials) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionOauth2ClientCredentialsClientId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 512
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PackConnectionOauth2ClientCredentialsClientId(::std::string::String);
    impl ::std::ops::Deref for PackConnectionOauth2ClientCredentialsClientId {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PackConnectionOauth2ClientCredentialsClientId> for ::std::string::String {
        fn from(value: PackConnectionOauth2ClientCredentialsClientId) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PackConnectionOauth2ClientCredentialsClientId> for PackConnectionOauth2ClientCredentialsClientId {
        fn from(value: &PackConnectionOauth2ClientCredentialsClientId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PackConnectionOauth2ClientCredentialsClientId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 512usize {
                return Err("longer than 512 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PackConnectionOauth2ClientCredentialsClientId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackConnectionOauth2ClientCredentialsClientId {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackConnectionOauth2ClientCredentialsClientId {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PackConnectionOauth2ClientCredentialsClientId {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///`PackConnectionOauth2ClientCredentialsClientSecret`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 512
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PackConnectionOauth2ClientCredentialsClientSecret(::std::string::String);
    impl ::std::ops::Deref for PackConnectionOauth2ClientCredentialsClientSecret {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PackConnectionOauth2ClientCredentialsClientSecret> for ::std::string::String {
        fn from(value: PackConnectionOauth2ClientCredentialsClientSecret) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PackConnectionOauth2ClientCredentialsClientSecret> for PackConnectionOauth2ClientCredentialsClientSecret {
        fn from(value: &PackConnectionOauth2ClientCredentialsClientSecret) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PackConnectionOauth2ClientCredentialsClientSecret {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 512usize {
                return Err("longer than 512 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PackConnectionOauth2ClientCredentialsClientSecret {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackConnectionOauth2ClientCredentialsClientSecret {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackConnectionOauth2ClientCredentialsClientSecret {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PackConnectionOauth2ClientCredentialsClientSecret {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///`PackConnectionOauth2ClientCredentialsMetadata`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "location",
    ///    "maskedClientId",
    ///    "maskedClientSecret",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "location": {
    ///      "$ref": "#/components/schemas/PackOAuth2ClientCredentialsLocation"
    ///    },
    ///    "maskedClientId": {
    ///      "type": "string"
    ///    },
    ///    "maskedClientSecret": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "oauth2ClientCredentials"
    ///      ],
    ///      "x-tsType": "PackConnectionType.OAuth2ClientCredentials"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackConnectionOauth2ClientCredentialsMetadata"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionOauth2ClientCredentialsMetadata {
        pub location: PackOAuth2ClientCredentialsLocation,
        #[serde(rename = "maskedClientId")]
        pub masked_client_id: ::std::string::String,
        #[serde(rename = "maskedClientSecret")]
        pub masked_client_secret: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: PackConnectionOauth2ClientCredentialsMetadataType,
    }

    impl ::std::convert::From<&PackConnectionOauth2ClientCredentialsMetadata> for PackConnectionOauth2ClientCredentialsMetadata {
        fn from(value: &PackConnectionOauth2ClientCredentialsMetadata) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionOauth2ClientCredentialsMetadataType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "oauth2ClientCredentials"
    ///  ],
    ///  "x-tsType": "PackConnectionType.OAuth2ClientCredentials"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackConnectionOauth2ClientCredentialsMetadataType {
        #[serde(rename = "oauth2ClientCredentials")]
        Oauth2ClientCredentials,
    }

    impl ::std::convert::From<&Self> for PackConnectionOauth2ClientCredentialsMetadataType {
        fn from(value: &PackConnectionOauth2ClientCredentialsMetadataType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackConnectionOauth2ClientCredentialsMetadataType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Oauth2ClientCredentials => f.write_str("oauth2ClientCredentials"),
            }
        }
    }

    impl ::std::str::FromStr for PackConnectionOauth2ClientCredentialsMetadataType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "oauth2ClientCredentials" => Ok(Self::Oauth2ClientCredentials),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackConnectionOauth2ClientCredentialsMetadataType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackConnectionOauth2ClientCredentialsMetadataType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackConnectionOauth2ClientCredentialsMetadataType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PackConnectionOauth2ClientCredentialsPatch`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "clientId": {
    ///      "type": "string",
    ///      "maxLength": 512
    ///    },
    ///    "clientSecret": {
    ///      "type": "string",
    ///      "maxLength": 512
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "oauth2ClientCredentials"
    ///      ],
    ///      "x-tsType": "PackConnectionType.OAuth2ClientCredentials"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackConnectionOauth2ClientCredentialsPatch"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionOauth2ClientCredentialsPatch {
        #[serde(rename = "clientId", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub client_id: ::std::option::Option<PackConnectionOauth2ClientCredentialsPatchClientId>,
        #[serde(rename = "clientSecret", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub client_secret: ::std::option::Option<PackConnectionOauth2ClientCredentialsPatchClientSecret>,
        #[serde(rename = "type")]
        pub type_: PackConnectionOauth2ClientCredentialsPatchType,
    }

    impl ::std::convert::From<&PackConnectionOauth2ClientCredentialsPatch> for PackConnectionOauth2ClientCredentialsPatch {
        fn from(value: &PackConnectionOauth2ClientCredentialsPatch) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionOauth2ClientCredentialsPatchClientId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 512
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PackConnectionOauth2ClientCredentialsPatchClientId(::std::string::String);
    impl ::std::ops::Deref for PackConnectionOauth2ClientCredentialsPatchClientId {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PackConnectionOauth2ClientCredentialsPatchClientId> for ::std::string::String {
        fn from(value: PackConnectionOauth2ClientCredentialsPatchClientId) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PackConnectionOauth2ClientCredentialsPatchClientId> for PackConnectionOauth2ClientCredentialsPatchClientId {
        fn from(value: &PackConnectionOauth2ClientCredentialsPatchClientId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PackConnectionOauth2ClientCredentialsPatchClientId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 512usize {
                return Err("longer than 512 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PackConnectionOauth2ClientCredentialsPatchClientId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackConnectionOauth2ClientCredentialsPatchClientId {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackConnectionOauth2ClientCredentialsPatchClientId {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PackConnectionOauth2ClientCredentialsPatchClientId {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///`PackConnectionOauth2ClientCredentialsPatchClientSecret`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 512
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PackConnectionOauth2ClientCredentialsPatchClientSecret(::std::string::String);
    impl ::std::ops::Deref for PackConnectionOauth2ClientCredentialsPatchClientSecret {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PackConnectionOauth2ClientCredentialsPatchClientSecret> for ::std::string::String {
        fn from(value: PackConnectionOauth2ClientCredentialsPatchClientSecret) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PackConnectionOauth2ClientCredentialsPatchClientSecret> for PackConnectionOauth2ClientCredentialsPatchClientSecret {
        fn from(value: &PackConnectionOauth2ClientCredentialsPatchClientSecret) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PackConnectionOauth2ClientCredentialsPatchClientSecret {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 512usize {
                return Err("longer than 512 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PackConnectionOauth2ClientCredentialsPatchClientSecret {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackConnectionOauth2ClientCredentialsPatchClientSecret {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackConnectionOauth2ClientCredentialsPatchClientSecret {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PackConnectionOauth2ClientCredentialsPatchClientSecret {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///`PackConnectionOauth2ClientCredentialsPatchType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "oauth2ClientCredentials"
    ///  ],
    ///  "x-tsType": "PackConnectionType.OAuth2ClientCredentials"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackConnectionOauth2ClientCredentialsPatchType {
        #[serde(rename = "oauth2ClientCredentials")]
        Oauth2ClientCredentials,
    }

    impl ::std::convert::From<&Self> for PackConnectionOauth2ClientCredentialsPatchType {
        fn from(value: &PackConnectionOauth2ClientCredentialsPatchType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackConnectionOauth2ClientCredentialsPatchType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Oauth2ClientCredentials => f.write_str("oauth2ClientCredentials"),
            }
        }
    }

    impl ::std::str::FromStr for PackConnectionOauth2ClientCredentialsPatchType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "oauth2ClientCredentials" => Ok(Self::Oauth2ClientCredentials),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackConnectionOauth2ClientCredentialsPatchType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackConnectionOauth2ClientCredentialsPatchType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackConnectionOauth2ClientCredentialsPatchType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PackConnectionOauth2ClientCredentialsType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "oauth2ClientCredentials"
    ///  ],
    ///  "x-tsType": "PackConnectionType.OAuth2ClientCredentials"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackConnectionOauth2ClientCredentialsType {
        #[serde(rename = "oauth2ClientCredentials")]
        Oauth2ClientCredentials,
    }

    impl ::std::convert::From<&Self> for PackConnectionOauth2ClientCredentialsType {
        fn from(value: &PackConnectionOauth2ClientCredentialsType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackConnectionOauth2ClientCredentialsType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Oauth2ClientCredentials => f.write_str("oauth2ClientCredentials"),
            }
        }
    }

    impl ::std::str::FromStr for PackConnectionOauth2ClientCredentialsType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "oauth2ClientCredentials" => Ok(Self::Oauth2ClientCredentials),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackConnectionOauth2ClientCredentialsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackConnectionOauth2ClientCredentialsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackConnectionOauth2ClientCredentialsType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Type of Pack connections.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Type of Pack connections.",
    ///  "type": "string",
    ///  "enum": [
    ///    "header",
    ///    "multiHeader",
    ///    "urlParam",
    ///    "httpBasic",
    ///    "custom",
    ///    "oauth2ClientCredentials",
    ///    "googleServiceAccount",
    ///    "awsAssumeRole",
    ///    "awsAccessKey"
    ///  ],
    ///  "x-schema-name": "PackConnectionType",
    ///  "x-tsEnumNames": [
    ///    "Header",
    ///    "MultiHeader",
    ///    "UrlParam",
    ///    "HttpBasic",
    ///    "Custom",
    ///    "OAuth2ClientCredentials",
    ///    "GoogleServiceAccount",
    ///    "AwsAssumeRole",
    ///    "AwsAccessKey"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackConnectionType {
        #[serde(rename = "header")]
        Header,
        #[serde(rename = "multiHeader")]
        MultiHeader,
        #[serde(rename = "urlParam")]
        UrlParam,
        #[serde(rename = "httpBasic")]
        HttpBasic,
        #[serde(rename = "custom")]
        Custom,
        #[serde(rename = "oauth2ClientCredentials")]
        Oauth2ClientCredentials,
        #[serde(rename = "googleServiceAccount")]
        GoogleServiceAccount,
        #[serde(rename = "awsAssumeRole")]
        AwsAssumeRole,
        #[serde(rename = "awsAccessKey")]
        AwsAccessKey,
    }

    impl ::std::convert::From<&Self> for PackConnectionType {
        fn from(value: &PackConnectionType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackConnectionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Header => f.write_str("header"),
                Self::MultiHeader => f.write_str("multiHeader"),
                Self::UrlParam => f.write_str("urlParam"),
                Self::HttpBasic => f.write_str("httpBasic"),
                Self::Custom => f.write_str("custom"),
                Self::Oauth2ClientCredentials => f.write_str("oauth2ClientCredentials"),
                Self::GoogleServiceAccount => f.write_str("googleServiceAccount"),
                Self::AwsAssumeRole => f.write_str("awsAssumeRole"),
                Self::AwsAccessKey => f.write_str("awsAccessKey"),
            }
        }
    }

    impl ::std::str::FromStr for PackConnectionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "header" => Ok(Self::Header),
                "multiHeader" => Ok(Self::MultiHeader),
                "urlParam" => Ok(Self::UrlParam),
                "httpBasic" => Ok(Self::HttpBasic),
                "custom" => Ok(Self::Custom),
                "oauth2ClientCredentials" => Ok(Self::Oauth2ClientCredentials),
                "googleServiceAccount" => Ok(Self::GoogleServiceAccount),
                "awsAssumeRole" => Ok(Self::AwsAssumeRole),
                "awsAccessKey" => Ok(Self::AwsAccessKey),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackConnectionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackConnectionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackConnectionType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PackConnectionUrlParamCredentials`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "params",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "params": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "key",
    ///          "value"
    ///        ],
    ///        "properties": {
    ///          "key": {
    ///            "type": "string"
    ///          },
    ///          "value": {
    ///            "type": "string"
    ///          }
    ///        },
    ///        "additionalProperties": false
    ///      }
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "urlParam"
    ///      ],
    ///      "x-tsType": "PackConnectionType.UrlParam"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackConnectionUrlParamCredentials"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionUrlParamCredentials {
        pub params: ::std::vec::Vec<PackConnectionUrlParamCredentialsParamsItem>,
        #[serde(rename = "type")]
        pub type_: PackConnectionUrlParamCredentialsType,
    }

    impl ::std::convert::From<&PackConnectionUrlParamCredentials> for PackConnectionUrlParamCredentials {
        fn from(value: &PackConnectionUrlParamCredentials) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionUrlParamCredentialsParamsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "key",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "key": {
    ///      "type": "string"
    ///    },
    ///    "value": {
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionUrlParamCredentialsParamsItem {
        pub key: ::std::string::String,
        pub value: ::std::string::String,
    }

    impl ::std::convert::From<&PackConnectionUrlParamCredentialsParamsItem> for PackConnectionUrlParamCredentialsParamsItem {
        fn from(value: &PackConnectionUrlParamCredentialsParamsItem) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionUrlParamCredentialsType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "urlParam"
    ///  ],
    ///  "x-tsType": "PackConnectionType.UrlParam"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackConnectionUrlParamCredentialsType {
        #[serde(rename = "urlParam")]
        UrlParam,
    }

    impl ::std::convert::From<&Self> for PackConnectionUrlParamCredentialsType {
        fn from(value: &PackConnectionUrlParamCredentialsType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackConnectionUrlParamCredentialsType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::UrlParam => f.write_str("urlParam"),
            }
        }
    }

    impl ::std::str::FromStr for PackConnectionUrlParamCredentialsType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "urlParam" => Ok(Self::UrlParam),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackConnectionUrlParamCredentialsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackConnectionUrlParamCredentialsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackConnectionUrlParamCredentialsType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PackConnectionUrlParamMetadata`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "domain",
    ///    "params",
    ///    "presetKeys",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "domain": {
    ///      "type": "string"
    ///    },
    ///    "params": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "key",
    ///          "maskedValue"
    ///        ],
    ///        "properties": {
    ///          "key": {
    ///            "type": "string"
    ///          },
    ///          "maskedValue": {
    ///            "type": "string"
    ///          }
    ///        },
    ///        "additionalProperties": false
    ///      }
    ///    },
    ///    "presetKeys": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "urlParam"
    ///      ],
    ///      "x-tsType": "PackConnectionType.UrlParam"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackConnectionUrlParamMetadata"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionUrlParamMetadata {
        pub domain: ::std::string::String,
        pub params: ::std::vec::Vec<PackConnectionUrlParamMetadataParamsItem>,
        #[serde(rename = "presetKeys")]
        pub preset_keys: ::std::vec::Vec<::std::string::String>,
        #[serde(rename = "type")]
        pub type_: PackConnectionUrlParamMetadataType,
    }

    impl ::std::convert::From<&PackConnectionUrlParamMetadata> for PackConnectionUrlParamMetadata {
        fn from(value: &PackConnectionUrlParamMetadata) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionUrlParamMetadataParamsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "key",
    ///    "maskedValue"
    ///  ],
    ///  "properties": {
    ///    "key": {
    ///      "type": "string"
    ///    },
    ///    "maskedValue": {
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionUrlParamMetadataParamsItem {
        pub key: ::std::string::String,
        #[serde(rename = "maskedValue")]
        pub masked_value: ::std::string::String,
    }

    impl ::std::convert::From<&PackConnectionUrlParamMetadataParamsItem> for PackConnectionUrlParamMetadataParamsItem {
        fn from(value: &PackConnectionUrlParamMetadataParamsItem) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionUrlParamMetadataType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "urlParam"
    ///  ],
    ///  "x-tsType": "PackConnectionType.UrlParam"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackConnectionUrlParamMetadataType {
        #[serde(rename = "urlParam")]
        UrlParam,
    }

    impl ::std::convert::From<&Self> for PackConnectionUrlParamMetadataType {
        fn from(value: &PackConnectionUrlParamMetadataType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackConnectionUrlParamMetadataType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::UrlParam => f.write_str("urlParam"),
            }
        }
    }

    impl ::std::str::FromStr for PackConnectionUrlParamMetadataType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "urlParam" => Ok(Self::UrlParam),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackConnectionUrlParamMetadataType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackConnectionUrlParamMetadataType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackConnectionUrlParamMetadataType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PackConnectionUrlParamPatch`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "paramsToPatch": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "key",
    ///          "value"
    ///        ],
    ///        "properties": {
    ///          "key": {
    ///            "type": "string"
    ///          },
    ///          "value": {
    ///            "type": "string"
    ///          }
    ///        },
    ///        "additionalProperties": false
    ///      }
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "urlParam"
    ///      ],
    ///      "x-tsType": "PackConnectionType.UrlParam"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackConnectionUrlParamPatch"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionUrlParamPatch {
        #[serde(rename = "paramsToPatch", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub params_to_patch: ::std::vec::Vec<PackConnectionUrlParamPatchParamsToPatchItem>,
        #[serde(rename = "type")]
        pub type_: PackConnectionUrlParamPatchType,
    }

    impl ::std::convert::From<&PackConnectionUrlParamPatch> for PackConnectionUrlParamPatch {
        fn from(value: &PackConnectionUrlParamPatch) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionUrlParamPatchParamsToPatchItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "key",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "key": {
    ///      "type": "string"
    ///    },
    ///    "value": {
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackConnectionUrlParamPatchParamsToPatchItem {
        pub key: ::std::string::String,
        pub value: ::std::string::String,
    }

    impl ::std::convert::From<&PackConnectionUrlParamPatchParamsToPatchItem> for PackConnectionUrlParamPatchParamsToPatchItem {
        fn from(value: &PackConnectionUrlParamPatchParamsToPatchItem) -> Self {
            value.clone()
        }
    }

    ///`PackConnectionUrlParamPatchType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "urlParam"
    ///  ],
    ///  "x-tsType": "PackConnectionType.UrlParam"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackConnectionUrlParamPatchType {
        #[serde(rename = "urlParam")]
        UrlParam,
    }

    impl ::std::convert::From<&Self> for PackConnectionUrlParamPatchType {
        fn from(value: &PackConnectionUrlParamPatchType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackConnectionUrlParamPatchType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::UrlParam => f.write_str("urlParam"),
            }
        }
    }

    impl ::std::str::FromStr for PackConnectionUrlParamPatchType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "urlParam" => Ok(Self::UrlParam),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackConnectionUrlParamPatchType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackConnectionUrlParamPatchType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackConnectionUrlParamPatchType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Pack log generated by developer's custom logging with context.logger.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Pack log generated by developer's custom logging with
    /// context.logger.",
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "level",
    ///    "message",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/PackLogContext"
    ///    },
    ///    "level": {
    ///      "$ref": "#/components/schemas/LogLevel"
    ///    },
    ///    "message": {
    ///      "description": "The message that's passed into context.logger.",
    ///      "examples": [
    ///        "The formula is called!"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "custom"
    ///      ],
    ///      "x-tsType": "PackLogType.Custom"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackCustomLog"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackCustomLog {
        pub context: PackLogContext,
        pub level: LogLevel,
        ///The message that's passed into context.logger.
        pub message: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: PackCustomLogType,
    }

    impl ::std::convert::From<&PackCustomLog> for PackCustomLog {
        fn from(value: &PackCustomLog) -> Self {
            value.clone()
        }
    }

    ///`PackCustomLogType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "custom"
    ///  ],
    ///  "x-tsType": "PackLogType.Custom"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackCustomLogType {
        #[serde(rename = "custom")]
        Custom,
    }

    impl ::std::convert::From<&Self> for PackCustomLogType {
        fn from(value: &PackCustomLogType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackCustomLogType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Custom => f.write_str("custom"),
            }
        }
    }

    impl ::std::str::FromStr for PackCustomLogType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "custom" => Ok(Self::Custom),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackCustomLogType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackCustomLogType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackCustomLogType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The full description of the Pack.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The full description of the Pack.",
    ///  "examples": [
    ///    "This Pack allows users to calculate the surface area and volume of a
    /// few common 3D shapes, like cubes and pyramids."
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 8192
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PackDescription(::std::string::String);
    impl ::std::ops::Deref for PackDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PackDescription> for ::std::string::String {
        fn from(value: PackDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PackDescription> for PackDescription {
        fn from(value: &PackDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PackDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 8192usize {
                return Err("longer than 8192 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PackDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PackDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///Widest principal a Pack is available to.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Widest principal a Pack is available to.",
    ///  "type": "string",
    ///  "enum": [
    ///    "public",
    ///    "workspace",
    ///    "private"
    ///  ],
    ///  "x-schema-name": "PackDiscoverability",
    ///  "x-tsEnumNames": [
    ///    "Public",
    ///    "Workspace",
    ///    "Private"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackDiscoverability {
        #[serde(rename = "public")]
        Public,
        #[serde(rename = "workspace")]
        Workspace,
        #[serde(rename = "private")]
        Private,
    }

    impl ::std::convert::From<&Self> for PackDiscoverability {
        fn from(value: &PackDiscoverability) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackDiscoverability {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Public => f.write_str("public"),
                Self::Workspace => f.write_str("workspace"),
                Self::Private => f.write_str("private"),
            }
        }
    }

    impl ::std::str::FromStr for PackDiscoverability {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "public" => Ok(Self::Public),
                "workspace" => Ok(Self::Workspace),
                "private" => Ok(Self::Private),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackDiscoverability {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackDiscoverability {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackDiscoverability {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///A Pack's featured doc.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A Pack's featured doc.",
    ///  "type": "object",
    ///  "required": [
    ///    "doc",
    ///    "isPinned"
    ///  ],
    ///  "properties": {
    ///    "doc": {
    ///      "$ref": "#/components/schemas/DocReference"
    ///    },
    ///    "docStatus": {
    ///      "$ref": "#/components/schemas/FeaturedDocStatus"
    ///    },
    ///    "isPinned": {
    ///      "description": "Whether or not this featured doc is pinned.",
    ///      "type": "boolean"
    ///    },
    ///    "publishedUrl": {
    ///      "description": "The URL of the published doc, if available.",
    ///      "type": "string",
    ///      "format": "url"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackFeaturedDoc"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackFeaturedDoc {
        pub doc: DocReference,
        #[serde(rename = "docStatus", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub doc_status: ::std::option::Option<FeaturedDocStatus>,
        ///Whether or not this featured doc is pinned.
        #[serde(rename = "isPinned")]
        pub is_pinned: bool,
        ///The URL of the published doc, if available.
        #[serde(rename = "publishedUrl", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub published_url: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&PackFeaturedDoc> for PackFeaturedDoc {
        fn from(value: &PackFeaturedDoc) -> Self {
            value.clone()
        }
    }

    ///Item representing a featured doc in the update Pack featured docs
    /// request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Item representing a featured doc in the update Pack
    /// featured docs request.",
    ///  "type": "object",
    ///  "required": [
    ///    "url"
    ///  ],
    ///  "properties": {
    ///    "isPinned": {
    ///      "description": "Whether or not the current doc should be pinned.",
    ///      "type": "boolean"
    ///    },
    ///    "url": {
    ///      "description": "A URL to a doc.",
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackFeaturedDocRequestItem"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackFeaturedDocRequestItem {
        ///Whether or not the current doc should be pinned.
        #[serde(rename = "isPinned", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_pinned: ::std::option::Option<bool>,
        ///A URL to a doc.
        pub url: ::std::string::String,
    }

    impl ::std::convert::From<&PackFeaturedDocRequestItem> for PackFeaturedDocRequestItem {
        fn from(value: &PackFeaturedDocRequestItem) -> Self {
            value.clone()
        }
    }

    ///List of a Pack's featured docs.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "List of a Pack's featured docs.",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "A list of featured docs for the Pack.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PackFeaturedDoc"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackFeaturedDocsResponse"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackFeaturedDocsResponse {
        ///A list of featured docs for the Pack.
        pub items: ::std::vec::Vec<PackFeaturedDoc>,
    }

    impl ::std::convert::From<&PackFeaturedDocsResponse> for PackFeaturedDocsResponse {
        fn from(value: &PackFeaturedDocsResponse) -> Self {
            value.clone()
        }
    }

    ///System logs of Pack calls to context.fetcher.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "System logs of Pack calls to context.fetcher.",
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "baseUrl": {
    ///      "description": "base URL of the fetcher request, with all query
    /// parameters stripped off.",
    ///      "examples": [
    ///        "https://coda.io/api"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "cacheHit": {
    ///      "description": "true if the fetcher request hits catche instead of
    /// actually requesting the remote service.",
    ///      "type": "boolean"
    ///    },
    ///    "context": {
    ///      "$ref": "#/components/schemas/PackLogContext"
    ///    },
    ///    "duration": {
    ///      "description": "Duration of the fetcher request in miliseconds.",
    ///      "type": "number"
    ///    },
    ///    "method": {
    ///      "type": "string",
    ///      "enum": [
    ///        "GET",
    ///        "POST",
    ///        "PUT",
    ///        "DELETE",
    ///        "PATCH",
    ///        "HEAD"
    ///      ]
    ///    },
    ///    "requestSizeBytes": {
    ///      "description": "The number of bytes in the HTTP request sent",
    ///      "type": "number"
    ///    },
    ///    "responseCode": {
    ///      "type": "number"
    ///    },
    ///    "responseSizeBytes": {
    ///      "description": "The number of bytes in the HTTP response received",
    ///      "type": "number"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "fetcher"
    ///      ],
    ///      "x-tsType": "PackLogType.Fetcher"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackFetcherLog"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackFetcherLog {
        ///base URL of the fetcher request, with all query parameters stripped
        /// off.
        #[serde(rename = "baseUrl", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub base_url: ::std::option::Option<::std::string::String>,
        ///true if the fetcher request hits catche instead of actually
        /// requesting the remote service.
        #[serde(rename = "cacheHit", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cache_hit: ::std::option::Option<bool>,
        pub context: PackLogContext,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub duration: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub method: ::std::option::Option<PackFetcherLogMethod>,
        #[serde(rename = "requestSizeBytes", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub request_size_bytes: ::std::option::Option<f64>,
        #[serde(rename = "responseCode", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub response_code: ::std::option::Option<f64>,
        #[serde(rename = "responseSizeBytes", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub response_size_bytes: ::std::option::Option<f64>,
        #[serde(rename = "type")]
        pub type_: PackFetcherLogType,
    }

    impl ::std::convert::From<&PackFetcherLog> for PackFetcherLog {
        fn from(value: &PackFetcherLog) -> Self {
            value.clone()
        }
    }

    ///Details for pack fetcher logs
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Details for pack fetcher logs",
    ///  "type": "object",
    ///  "required": [
    ///    "request",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "request": {
    ///      "type": "string"
    ///    },
    ///    "response": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "fetcher"
    ///      ],
    ///      "x-tsType": "PackLogType.Fetcher"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackFetcherLogDetails"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackFetcherLogDetails {
        pub request: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub response: ::std::option::Option<::std::string::String>,
        #[serde(rename = "type")]
        pub type_: PackFetcherLogDetailsType,
    }

    impl ::std::convert::From<&PackFetcherLogDetails> for PackFetcherLogDetails {
        fn from(value: &PackFetcherLogDetails) -> Self {
            value.clone()
        }
    }

    ///`PackFetcherLogDetailsType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "fetcher"
    ///  ],
    ///  "x-tsType": "PackLogType.Fetcher"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackFetcherLogDetailsType {
        #[serde(rename = "fetcher")]
        Fetcher,
    }

    impl ::std::convert::From<&Self> for PackFetcherLogDetailsType {
        fn from(value: &PackFetcherLogDetailsType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackFetcherLogDetailsType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Fetcher => f.write_str("fetcher"),
            }
        }
    }

    impl ::std::str::FromStr for PackFetcherLogDetailsType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "fetcher" => Ok(Self::Fetcher),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackFetcherLogDetailsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackFetcherLogDetailsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackFetcherLogDetailsType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PackFetcherLogMethod`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "GET",
    ///    "POST",
    ///    "PUT",
    ///    "DELETE",
    ///    "PATCH",
    ///    "HEAD"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackFetcherLogMethod {
        #[serde(rename = "GET")]
        Get,
        #[serde(rename = "POST")]
        Post,
        #[serde(rename = "PUT")]
        Put,
        #[serde(rename = "DELETE")]
        Delete,
        #[serde(rename = "PATCH")]
        Patch,
        #[serde(rename = "HEAD")]
        Head,
    }

    impl ::std::convert::From<&Self> for PackFetcherLogMethod {
        fn from(value: &PackFetcherLogMethod) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackFetcherLogMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Get => f.write_str("GET"),
                Self::Post => f.write_str("POST"),
                Self::Put => f.write_str("PUT"),
                Self::Delete => f.write_str("DELETE"),
                Self::Patch => f.write_str("PATCH"),
                Self::Head => f.write_str("HEAD"),
            }
        }
    }

    impl ::std::str::FromStr for PackFetcherLogMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "GET" => Ok(Self::Get),
                "POST" => Ok(Self::Post),
                "PUT" => Ok(Self::Put),
                "DELETE" => Ok(Self::Delete),
                "PATCH" => Ok(Self::Patch),
                "HEAD" => Ok(Self::Head),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackFetcherLogMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackFetcherLogMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackFetcherLogMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PackFetcherLogType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "fetcher"
    ///  ],
    ///  "x-tsType": "PackLogType.Fetcher"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackFetcherLogType {
        #[serde(rename = "fetcher")]
        Fetcher,
    }

    impl ::std::convert::From<&Self> for PackFetcherLogType {
        fn from(value: &PackFetcherLogType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackFetcherLogType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Fetcher => f.write_str("fetcher"),
            }
        }
    }

    impl ::std::str::FromStr for PackFetcherLogType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "fetcher" => Ok(Self::Fetcher),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackFetcherLogType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackFetcherLogType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackFetcherLogType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///A collection of analytics for Coda Packs formulas over a date range.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A collection of analytics for Coda Packs formulas over
    /// a date range.",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PackFormulaAnalyticsItem"
    ///      }
    ///    },
    ///    "nextPageLink": {
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/nextPageLink"
    ///        },
    ///        {
    ///          "examples": [
    ///            "https://coda.io/apis/v1/analytics/packs/:packId/formulas?pageToken=xyz"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      ]
    ///    },
    ///    "nextPageToken": {
    ///      "$ref": "#/components/schemas/nextPageToken"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackFormulaAnalyticsCollection"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackFormulaAnalyticsCollection {
        pub items: ::std::vec::Vec<PackFormulaAnalyticsItem>,
        #[serde(rename = "nextPageLink", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_link: ::std::option::Option<NextPageLink>,
        #[serde(rename = "nextPageToken", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_token: ::std::option::Option<NextPageToken>,
    }

    impl ::std::convert::From<&PackFormulaAnalyticsCollection> for PackFormulaAnalyticsCollection {
        fn from(value: &PackFormulaAnalyticsCollection) -> Self {
            value.clone()
        }
    }

    ///Analytics data for a Coda Pack formula.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Analytics data for a Coda Pack formula.",
    ///  "type": "object",
    ///  "required": [
    ///    "formula",
    ///    "metrics"
    ///  ],
    ///  "properties": {
    ///    "formula": {
    ///      "$ref": "#/components/schemas/PackFormulaIdentifier"
    ///    },
    ///    "metrics": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PackFormulaAnalyticsMetrics"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackFormulaAnalyticsItem"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackFormulaAnalyticsItem {
        pub formula: PackFormulaIdentifier,
        pub metrics: ::std::vec::Vec<PackFormulaAnalyticsMetrics>,
    }

    impl ::std::convert::From<&PackFormulaAnalyticsItem> for PackFormulaAnalyticsItem {
        fn from(value: &PackFormulaAnalyticsItem) -> Self {
            value.clone()
        }
    }

    ///Analytics metrics for a Coda Pack formula.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Analytics metrics for a Coda Pack formula.",
    ///  "type": "object",
    ///  "required": [
    ///    "date",
    ///    "docsActivelyUsing",
    ///    "docsActivelyUsing30Day",
    ///    "docsActivelyUsing7Day",
    ///    "docsActivelyUsing90Day",
    ///    "docsActivelyUsingAllTime",
    ///    "errors",
    ///    "formulaInvocations",
    ///    "workspacesActivelyUsing",
    ///    "workspacesActivelyUsing30Day",
    ///    "workspacesActivelyUsing7Day",
    ///    "workspacesActivelyUsing90Day",
    ///    "workspacesActivelyUsingAllTime"
    ///  ],
    ///  "properties": {
    ///    "date": {
    ///      "description": "Date of the analytics data.",
    ///      "examples": [
    ///        "2020-09-02"
    ///      ],
    ///      "type": "string",
    ///      "format": "date"
    ///    },
    ///    "docsActivelyUsing": {
    ///      "description": "Number of unique docs that have invoked a formula
    /// from this Pack in the past day.",
    ///      "examples": [
    ///        50
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "docsActivelyUsing30Day": {
    ///      "description": "Number of unique docs that have invoked a formula
    /// from this Pack in the past 30 days.",
    ///      "examples": [
    ///        200
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "docsActivelyUsing7Day": {
    ///      "description": "Number of unique docs that have invoked a formula
    /// from this Pack in the past 7 days.",
    ///      "examples": [
    ///        100
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "docsActivelyUsing90Day": {
    ///      "description": "Number of unique docs that have invoked a formula
    /// from this Pack in the past 90 days.",
    ///      "examples": [
    ///        300
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "docsActivelyUsingAllTime": {
    ///      "description": "Number of unique docs that have invoked a formula
    /// from this Pack ever.",
    ///      "examples": [
    ///        500
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "errors": {
    ///      "description": "Number of errors from invocations.",
    ///      "examples": [
    ///        5
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "formulaInvocations": {
    ///      "description": "Number of times this formula has been invoked.",
    ///      "examples": [
    ///        123
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "medianLatencyMs": {
    ///      "description": "Median latency of an invocation in milliseconds.
    /// Only present for daily metrics.",
    ///      "examples": [
    ///        500
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "medianResponseSizeBytes": {
    ///      "description": "Median response size in bytes. Only present for
    /// daily metrics.",
    ///      "examples": [
    ///        300
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "revenueUsd": {
    ///      "description": "Amount of revenue (in USD) that the Pack has
    /// produced.",
    ///      "type": "string"
    ///    },
    ///    "workspacesActivelyTrialing": {
    ///      "description": "Number of unique workspaces that are currently
    /// involved in a trial.",
    ///      "type": "integer"
    ///    },
    ///    "workspacesActivelyTrialing30Day": {
    ///      "description": "Number of unique workspaces that have been involved
    /// in a trial in the last 30 days.",
    ///      "type": "integer"
    ///    },
    ///    "workspacesActivelyTrialing7Day": {
    ///      "description": "Number of unique workspaces that have been involved
    /// in a trial in the last 7 days.",
    ///      "type": "integer"
    ///    },
    ///    "workspacesActivelyTrialing90Day": {
    ///      "description": "Number of unique workspaces that have been involved
    /// in a trial in the last 90 days.",
    ///      "type": "integer"
    ///    },
    ///    "workspacesActivelyTrialingAllTime": {
    ///      "description": "Number of unique workspaces that have been involved
    /// in a trial ever.",
    ///      "type": "integer"
    ///    },
    ///    "workspacesActivelyUsing": {
    ///      "description": "Number of unique workspaces that have invoked a
    /// formula from this Pack in the past day.",
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "workspacesActivelyUsing30Day": {
    ///      "description": "Number of unique workspaces that have invoked a
    /// formula from this Pack in the past 30 days.",
    ///      "examples": [
    ///        20
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "workspacesActivelyUsing7Day": {
    ///      "description": "Number of unique workspaces that have invoked a
    /// formula from this Pack in the past 7 days.",
    ///      "examples": [
    ///        15
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "workspacesActivelyUsing90Day": {
    ///      "description": "Number of unique workspaces that have invoked a
    /// formula from this Pack in the past 90 days.",
    ///      "examples": [
    ///        30
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "workspacesActivelyUsingAllTime": {
    ///      "description": "Number of unique workspaces that have invoked a
    /// formula from this Pack ever.",
    ///      "examples": [
    ///        50
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "workspacesNewlySubscribed": {
    ///      "description": "Number of unique workspaces that have recently
    /// subscribed to the Pack.",
    ///      "type": "integer"
    ///    },
    ///    "workspacesWithActiveSubscriptions": {
    ///      "description": "Number of unique workspaces that are currently
    /// subscribed to the Pack.",
    ///      "type": "integer"
    ///    },
    ///    "workspacesWithSuccessfulTrials": {
    ///      "description": "Number of unique workspaces that subscribed after
    /// undertaking a Pack trial.",
    ///      "type": "integer"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackFormulaAnalyticsMetrics"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackFormulaAnalyticsMetrics {
        ///Date of the analytics data.
        pub date: ::chrono::naive::NaiveDate,
        ///Number of unique docs that have invoked a formula from this Pack in
        /// the past day.
        #[serde(rename = "docsActivelyUsing")]
        pub docs_actively_using: i64,
        ///Number of unique docs that have invoked a formula from this Pack in
        /// the past 30 days.
        #[serde(rename = "docsActivelyUsing30Day")]
        pub docs_actively_using30_day: i64,
        ///Number of unique docs that have invoked a formula from this Pack in
        /// the past 7 days.
        #[serde(rename = "docsActivelyUsing7Day")]
        pub docs_actively_using7_day: i64,
        ///Number of unique docs that have invoked a formula from this Pack in
        /// the past 90 days.
        #[serde(rename = "docsActivelyUsing90Day")]
        pub docs_actively_using90_day: i64,
        ///Number of unique docs that have invoked a formula from this Pack
        /// ever.
        #[serde(rename = "docsActivelyUsingAllTime")]
        pub docs_actively_using_all_time: i64,
        ///Number of errors from invocations.
        pub errors: i64,
        ///Number of times this formula has been invoked.
        #[serde(rename = "formulaInvocations")]
        pub formula_invocations: i64,
        ///Median latency of an invocation in milliseconds. Only present for
        /// daily metrics.
        #[serde(rename = "medianLatencyMs", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub median_latency_ms: ::std::option::Option<i64>,
        ///Median response size in bytes. Only present for daily metrics.
        #[serde(rename = "medianResponseSizeBytes", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub median_response_size_bytes: ::std::option::Option<i64>,
        ///Amount of revenue (in USD) that the Pack has produced.
        #[serde(rename = "revenueUsd", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub revenue_usd: ::std::option::Option<::std::string::String>,
        ///Number of unique workspaces that are currently involved in a trial.
        #[serde(rename = "workspacesActivelyTrialing", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub workspaces_actively_trialing: ::std::option::Option<i64>,
        ///Number of unique workspaces that have been involved in a trial in
        /// the last 30 days.
        #[serde(rename = "workspacesActivelyTrialing30Day", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub workspaces_actively_trialing30_day: ::std::option::Option<i64>,
        ///Number of unique workspaces that have been involved in a trial in
        /// the last 7 days.
        #[serde(rename = "workspacesActivelyTrialing7Day", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub workspaces_actively_trialing7_day: ::std::option::Option<i64>,
        ///Number of unique workspaces that have been involved in a trial in
        /// the last 90 days.
        #[serde(rename = "workspacesActivelyTrialing90Day", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub workspaces_actively_trialing90_day: ::std::option::Option<i64>,
        ///Number of unique workspaces that have been involved in a trial ever.
        #[serde(rename = "workspacesActivelyTrialingAllTime", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub workspaces_actively_trialing_all_time: ::std::option::Option<i64>,
        ///Number of unique workspaces that have invoked a formula from this
        /// Pack in the past day.
        #[serde(rename = "workspacesActivelyUsing")]
        pub workspaces_actively_using: i64,
        ///Number of unique workspaces that have invoked a formula from this
        /// Pack in the past 30 days.
        #[serde(rename = "workspacesActivelyUsing30Day")]
        pub workspaces_actively_using30_day: i64,
        ///Number of unique workspaces that have invoked a formula from this
        /// Pack in the past 7 days.
        #[serde(rename = "workspacesActivelyUsing7Day")]
        pub workspaces_actively_using7_day: i64,
        ///Number of unique workspaces that have invoked a formula from this
        /// Pack in the past 90 days.
        #[serde(rename = "workspacesActivelyUsing90Day")]
        pub workspaces_actively_using90_day: i64,
        ///Number of unique workspaces that have invoked a formula from this
        /// Pack ever.
        #[serde(rename = "workspacesActivelyUsingAllTime")]
        pub workspaces_actively_using_all_time: i64,
        ///Number of unique workspaces that have recently subscribed to the
        /// Pack.
        #[serde(rename = "workspacesNewlySubscribed", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub workspaces_newly_subscribed: ::std::option::Option<i64>,
        ///Number of unique workspaces that are currently subscribed to the
        /// Pack.
        #[serde(rename = "workspacesWithActiveSubscriptions", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub workspaces_with_active_subscriptions: ::std::option::Option<i64>,
        ///Number of unique workspaces that subscribed after undertaking a Pack
        /// trial.
        #[serde(rename = "workspacesWithSuccessfulTrials", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub workspaces_with_successful_trials: ::std::option::Option<i64>,
    }

    impl ::std::convert::From<&PackFormulaAnalyticsMetrics> for PackFormulaAnalyticsMetrics {
        fn from(value: &PackFormulaAnalyticsMetrics) -> Self {
            value.clone()
        }
    }

    ///Determines how the Pack formula analytics returned are sorted.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Determines how the Pack formula analytics returned are
    /// sorted.",
    ///  "type": "string",
    ///  "enum": [
    ///    "date",
    ///    "formulaName",
    ///    "formulaType",
    ///    "formulaInvocations",
    ///    "medianLatencyMs",
    ///    "medianResponseSizeBytes",
    ///    "errors",
    ///    "docsActivelyUsing",
    ///    "docsActivelyUsing7Day",
    ///    "docsActivelyUsing30Day",
    ///    "docsActivelyUsing90Day",
    ///    "docsActivelyUsingAllTime",
    ///    "workspacesActivelyUsing",
    ///    "workspacesActivelyUsing7Day",
    ///    "workspacesActivelyUsing30Day",
    ///    "workspacesActivelyUsing90Day",
    ///    "workspacesActivelyUsingAllTime"
    ///  ],
    ///  "x-schema-name": "PackFormulaAnalyticsOrderBy",
    ///  "x-tsEnumNames": [
    ///    "AnalyticsDate",
    ///    "FormulaName",
    ///    "FormulaType",
    ///    "FormulaInvocations",
    ///    "MedianLatencyMs",
    ///    "MedianResponseSizeBytes",
    ///    "Errors",
    ///    "DocsActivelyUsing",
    ///    "DocsActivelyUsing7Day",
    ///    "DocsActivelyUsing30Day",
    ///    "DocsActivelyUsing90Day",
    ///    "DocsActivelyUsingAllTime",
    ///    "WorkspacesActivelyUsing",
    ///    "WorkspacesActivelyUsing7Day",
    ///    "WorkspacesActivelyUsing30Day",
    ///    "WorkspacesActivelyUsing90Day",
    ///    "WorkspacesActivelyUsingAllTime"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackFormulaAnalyticsOrderBy {
        #[serde(rename = "date")]
        Date,
        #[serde(rename = "formulaName")]
        FormulaName,
        #[serde(rename = "formulaType")]
        FormulaType,
        #[serde(rename = "formulaInvocations")]
        FormulaInvocations,
        #[serde(rename = "medianLatencyMs")]
        MedianLatencyMs,
        #[serde(rename = "medianResponseSizeBytes")]
        MedianResponseSizeBytes,
        #[serde(rename = "errors")]
        Errors,
        #[serde(rename = "docsActivelyUsing")]
        DocsActivelyUsing,
        #[serde(rename = "docsActivelyUsing7Day")]
        DocsActivelyUsing7Day,
        #[serde(rename = "docsActivelyUsing30Day")]
        DocsActivelyUsing30Day,
        #[serde(rename = "docsActivelyUsing90Day")]
        DocsActivelyUsing90Day,
        #[serde(rename = "docsActivelyUsingAllTime")]
        DocsActivelyUsingAllTime,
        #[serde(rename = "workspacesActivelyUsing")]
        WorkspacesActivelyUsing,
        #[serde(rename = "workspacesActivelyUsing7Day")]
        WorkspacesActivelyUsing7Day,
        #[serde(rename = "workspacesActivelyUsing30Day")]
        WorkspacesActivelyUsing30Day,
        #[serde(rename = "workspacesActivelyUsing90Day")]
        WorkspacesActivelyUsing90Day,
        #[serde(rename = "workspacesActivelyUsingAllTime")]
        WorkspacesActivelyUsingAllTime,
    }

    impl ::std::convert::From<&Self> for PackFormulaAnalyticsOrderBy {
        fn from(value: &PackFormulaAnalyticsOrderBy) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackFormulaAnalyticsOrderBy {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Date => f.write_str("date"),
                Self::FormulaName => f.write_str("formulaName"),
                Self::FormulaType => f.write_str("formulaType"),
                Self::FormulaInvocations => f.write_str("formulaInvocations"),
                Self::MedianLatencyMs => f.write_str("medianLatencyMs"),
                Self::MedianResponseSizeBytes => f.write_str("medianResponseSizeBytes"),
                Self::Errors => f.write_str("errors"),
                Self::DocsActivelyUsing => f.write_str("docsActivelyUsing"),
                Self::DocsActivelyUsing7Day => f.write_str("docsActivelyUsing7Day"),
                Self::DocsActivelyUsing30Day => f.write_str("docsActivelyUsing30Day"),
                Self::DocsActivelyUsing90Day => f.write_str("docsActivelyUsing90Day"),
                Self::DocsActivelyUsingAllTime => f.write_str("docsActivelyUsingAllTime"),
                Self::WorkspacesActivelyUsing => f.write_str("workspacesActivelyUsing"),
                Self::WorkspacesActivelyUsing7Day => f.write_str("workspacesActivelyUsing7Day"),
                Self::WorkspacesActivelyUsing30Day => f.write_str("workspacesActivelyUsing30Day"),
                Self::WorkspacesActivelyUsing90Day => f.write_str("workspacesActivelyUsing90Day"),
                Self::WorkspacesActivelyUsingAllTime => f.write_str("workspacesActivelyUsingAllTime"),
            }
        }
    }

    impl ::std::str::FromStr for PackFormulaAnalyticsOrderBy {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "date" => Ok(Self::Date),
                "formulaName" => Ok(Self::FormulaName),
                "formulaType" => Ok(Self::FormulaType),
                "formulaInvocations" => Ok(Self::FormulaInvocations),
                "medianLatencyMs" => Ok(Self::MedianLatencyMs),
                "medianResponseSizeBytes" => Ok(Self::MedianResponseSizeBytes),
                "errors" => Ok(Self::Errors),
                "docsActivelyUsing" => Ok(Self::DocsActivelyUsing),
                "docsActivelyUsing7Day" => Ok(Self::DocsActivelyUsing7Day),
                "docsActivelyUsing30Day" => Ok(Self::DocsActivelyUsing30Day),
                "docsActivelyUsing90Day" => Ok(Self::DocsActivelyUsing90Day),
                "docsActivelyUsingAllTime" => Ok(Self::DocsActivelyUsingAllTime),
                "workspacesActivelyUsing" => Ok(Self::WorkspacesActivelyUsing),
                "workspacesActivelyUsing7Day" => Ok(Self::WorkspacesActivelyUsing7Day),
                "workspacesActivelyUsing30Day" => Ok(Self::WorkspacesActivelyUsing30Day),
                "workspacesActivelyUsing90Day" => Ok(Self::WorkspacesActivelyUsing90Day),
                "workspacesActivelyUsingAllTime" => Ok(Self::WorkspacesActivelyUsingAllTime),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackFormulaAnalyticsOrderBy {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackFormulaAnalyticsOrderBy {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackFormulaAnalyticsOrderBy {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PackFormulaIdentifier`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "name",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "name": {
    ///      "description": "The Pack formula name.",
    ///      "examples": [
    ///        "SquareRoot"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "$ref": "#/components/schemas/PackFormulaType"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackFormulaIdentifier"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackFormulaIdentifier {
        ///The Pack formula name.
        pub name: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: PackFormulaType,
    }

    impl ::std::convert::From<&PackFormulaIdentifier> for PackFormulaIdentifier {
        fn from(value: &PackFormulaIdentifier) -> Self {
            value.clone()
        }
    }

    ///`PackFormulaType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "action",
    ///    "formula",
    ///    "sync",
    ///    "metadata"
    ///  ],
    ///  "x-schema-name": "PackFormulaType",
    ///  "x-tsEnumNames": [
    ///    "Action",
    ///    "Formula",
    ///    "Sync",
    ///    "Metadata"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackFormulaType {
        #[serde(rename = "action")]
        Action,
        #[serde(rename = "formula")]
        Formula,
        #[serde(rename = "sync")]
        Sync,
        #[serde(rename = "metadata")]
        Metadata,
    }

    impl ::std::convert::From<&Self> for PackFormulaType {
        fn from(value: &PackFormulaType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackFormulaType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Action => f.write_str("action"),
                Self::Formula => f.write_str("formula"),
                Self::Sync => f.write_str("sync"),
                Self::Metadata => f.write_str("metadata"),
            }
        }
    }

    impl ::std::str::FromStr for PackFormulaType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "action" => Ok(Self::Action),
                "formula" => Ok(Self::Formula),
                "sync" => Ok(Self::Sync),
                "metadata" => Ok(Self::Metadata),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackFormulaType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackFormulaType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackFormulaType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PackGlobalPrincipal`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "worldwide"
    ///      ],
    ///      "x-tsType": "PackPrincipalType.Worldwide"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackGlobalPrincipal"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackGlobalPrincipal {
        #[serde(rename = "type")]
        pub type_: PackGlobalPrincipalType,
    }

    impl ::std::convert::From<&PackGlobalPrincipal> for PackGlobalPrincipal {
        fn from(value: &PackGlobalPrincipal) -> Self {
            value.clone()
        }
    }

    ///`PackGlobalPrincipalType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "worldwide"
    ///  ],
    ///  "x-tsType": "PackPrincipalType.Worldwide"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackGlobalPrincipalType {
        #[serde(rename = "worldwide")]
        Worldwide,
    }

    impl ::std::convert::From<&Self> for PackGlobalPrincipalType {
        fn from(value: &PackGlobalPrincipalType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackGlobalPrincipalType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Worldwide => f.write_str("worldwide"),
            }
        }
    }

    impl ::std::str::FromStr for PackGlobalPrincipalType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "worldwide" => Ok(Self::Worldwide),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackGlobalPrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackGlobalPrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackGlobalPrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///A Pack image file.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A Pack image file.",
    ///  "type": "object",
    ///  "required": [
    ///    "assetId",
    ///    "filename",
    ///    "imageUrl"
    ///  ],
    ///  "properties": {
    ///    "altText": {
    ///      "description": "The alt text for the image.",
    ///      "type": "string"
    ///    },
    ///    "assetId": {
    ///      "description": "The asset id of the Pack's image.",
    ///      "type": "string"
    ///    },
    ///    "filename": {
    ///      "description": "The name of the image file.",
    ///      "type": "string"
    ///    },
    ///    "imageUrl": {
    ///      "description": "The URL to the image file.",
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "mimeType": {
    ///      "description": "The media type of the image.",
    ///      "examples": [
    ///        "image/jpeg"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackImageFile"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackImageFile {
        ///The alt text for the image.
        #[serde(rename = "altText", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub alt_text: ::std::option::Option<::std::string::String>,
        ///The asset id of the Pack's image.
        #[serde(rename = "assetId")]
        pub asset_id: ::std::string::String,
        ///The name of the image file.
        pub filename: ::std::string::String,
        ///The URL to the image file.
        #[serde(rename = "imageUrl")]
        pub image_url: ::std::string::String,
        ///The media type of the image.
        #[serde(rename = "mimeType", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mime_type: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&PackImageFile> for PackImageFile {
        fn from(value: &PackImageFile) -> Self {
            value.clone()
        }
    }

    ///Pack log generated by an executing ingestion. Contains metadata helpful
    /// for debugging
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Pack log generated by an executing ingestion. Contains
    /// metadata helpful for debugging",
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "level",
    ///    "message",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/PackLogContext"
    ///    },
    ///    "level": {
    ///      "$ref": "#/components/schemas/LogLevel"
    ///    },
    ///    "message": {
    ///      "description": "The message that's passed into context.logger.",
    ///      "examples": [
    ///        "The formula is called!"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "ingestionDebug"
    ///      ],
    ///      "x-tsType": "PackLogType.IngestionDebug"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackIngestionDebugLog"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackIngestionDebugLog {
        pub context: PackLogContext,
        pub level: LogLevel,
        ///The message that's passed into context.logger.
        pub message: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: PackIngestionDebugLogType,
    }

    impl ::std::convert::From<&PackIngestionDebugLog> for PackIngestionDebugLog {
        fn from(value: &PackIngestionDebugLog) -> Self {
            value.clone()
        }
    }

    ///`PackIngestionDebugLogType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ingestionDebug"
    ///  ],
    ///  "x-tsType": "PackLogType.IngestionDebug"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackIngestionDebugLogType {
        #[serde(rename = "ingestionDebug")]
        IngestionDebug,
    }

    impl ::std::convert::From<&Self> for PackIngestionDebugLogType {
        fn from(value: &PackIngestionDebugLogType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackIngestionDebugLogType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::IngestionDebug => f.write_str("ingestionDebug"),
            }
        }
    }

    impl ::std::str::FromStr for PackIngestionDebugLogType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ingestionDebug" => Ok(Self::IngestionDebug),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackIngestionDebugLogType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackIngestionDebugLogType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackIngestionDebugLogType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Pack log generated by an executing ingestion.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Pack log generated by an executing ingestion.",
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "level",
    ///    "message",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/PackLogContext"
    ///    },
    ///    "level": {
    ///      "$ref": "#/components/schemas/LogLevel"
    ///    },
    ///    "message": {
    ///      "description": "The message that's passed into context.logger.",
    ///      "examples": [
    ///        "The formula is called!"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "ingestionLifecycle"
    ///      ],
    ///      "x-tsType": "PackLogType.IngestionLifecycle"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackIngestionLifecycleLog"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackIngestionLifecycleLog {
        pub context: PackLogContext,
        pub level: LogLevel,
        ///The message that's passed into context.logger.
        pub message: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: PackIngestionLifecycleLogType,
    }

    impl ::std::convert::From<&PackIngestionLifecycleLog> for PackIngestionLifecycleLog {
        fn from(value: &PackIngestionLifecycleLog) -> Self {
            value.clone()
        }
    }

    ///`PackIngestionLifecycleLogType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ingestionLifecycle"
    ///  ],
    ///  "x-tsType": "PackLogType.IngestionLifecycle"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackIngestionLifecycleLogType {
        #[serde(rename = "ingestionLifecycle")]
        IngestionLifecycle,
    }

    impl ::std::convert::From<&Self> for PackIngestionLifecycleLogType {
        fn from(value: &PackIngestionLifecycleLogType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackIngestionLifecycleLogType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::IngestionLifecycle => f.write_str("ingestionLifecycle"),
            }
        }
    }

    impl ::std::str::FromStr for PackIngestionLifecycleLogType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ingestionLifecycle" => Ok(Self::IngestionLifecycle),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackIngestionLifecycleLogType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackIngestionLifecycleLogType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackIngestionLifecycleLogType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Coda internal logs from the packs infrastructure. Only visible to
    /// Codans.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Coda internal logs from the packs infrastructure. Only
    /// visible to Codans.",
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "level",
    ///    "message",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/PackLogContext"
    ///    },
    ///    "level": {
    ///      "$ref": "#/components/schemas/LogLevel"
    ///    },
    ///    "message": {
    ///      "description": "The log message.",
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "internal"
    ///      ],
    ///      "x-tsType": "PackLogType.Internal"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackInternalLog"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackInternalLog {
        pub context: PackLogContext,
        pub level: LogLevel,
        ///The log message.
        pub message: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: PackInternalLogType,
    }

    impl ::std::convert::From<&PackInternalLog> for PackInternalLog {
        fn from(value: &PackInternalLog) -> Self {
            value.clone()
        }
    }

    ///`PackInternalLogType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "internal"
    ///  ],
    ///  "x-tsType": "PackLogType.Internal"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackInternalLogType {
        #[serde(rename = "internal")]
        Internal,
    }

    impl ::std::convert::From<&Self> for PackInternalLogType {
        fn from(value: &PackInternalLogType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackInternalLogType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Internal => f.write_str("internal"),
            }
        }
    }

    impl ::std::str::FromStr for PackInternalLogType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "internal" => Ok(Self::Internal),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackInternalLogType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackInternalLogType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackInternalLogType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///System logs of the invocations of the Pack.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "System logs of the invocations of the Pack.",
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "cacheHit": {
    ///      "description": "True if the formula returned a prior result without
    /// executing.",
    ///      "type": "boolean"
    ///    },
    ///    "context": {
    ///      "$ref": "#/components/schemas/PackLogContext"
    ///    },
    ///    "duration": {
    ///      "description": "Duration of the formula exeuction in miliseconds.",
    ///      "type": "number"
    ///    },
    ///    "error": {
    ///      "description": "Error info if this invocation resulted in an
    /// error.",
    ///      "type": "object",
    ///      "required": [
    ///        "message"
    ///      ],
    ///      "properties": {
    ///        "message": {
    ///          "type": "string"
    ///        },
    ///        "stack": {
    ///          "type": "string"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "invocation"
    ///      ],
    ///      "x-tsType": "PackLogType.Invocation"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackInvocationLog"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackInvocationLog {
        ///True if the formula returned a prior result without executing.
        #[serde(rename = "cacheHit", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cache_hit: ::std::option::Option<bool>,
        pub context: PackLogContext,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub duration: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<PackInvocationLogError>,
        #[serde(rename = "type")]
        pub type_: PackInvocationLogType,
    }

    impl ::std::convert::From<&PackInvocationLog> for PackInvocationLog {
        fn from(value: &PackInvocationLog) -> Self {
            value.clone()
        }
    }

    ///Details for pack invocation logs
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Details for pack invocation logs",
    ///  "type": "object",
    ///  "required": [
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "completionJson": {
    ///      "description": "Only used by sync invocations.",
    ///      "type": "string"
    ///    },
    ///    "continuationJson": {
    ///      "description": "Only used by sync invocations.",
    ///      "type": "string"
    ///    },
    ///    "deletedItemIdsJson": {
    ///      "description": "Only used by sync invocations.",
    ///      "type": "string"
    ///    },
    ///    "permissionsContextJson": {
    ///      "description": "Only used by sync invocations.",
    ///      "type": "string"
    ///    },
    ///    "result": {
    ///      "type": "object",
    ///      "required": [
    ///        "boolVal",
    ///        "dateVal",
    ///        "doubleVal",
    ///        "int64Val",
    ///        "objectVal",
    ///        "stringVal"
    ///      ],
    ///      "properties": {
    ///        "boolVal": {
    ///          "type": "boolean"
    ///        },
    ///        "dateVal": {
    ///          "type": "number"
    ///        },
    ///        "doubleVal": {
    ///          "type": "number"
    ///        },
    ///        "int64Val": {
    ///          "type": "number"
    ///        },
    ///        "objectVal": {
    ///          "type": "string"
    ///        },
    ///        "stringVal": {
    ///          "type": "string"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    },
    ///    "resultDetail": {
    ///      "description": "Supplementary information about the result.",
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "invocation"
    ///      ],
    ///      "x-tsType": "PackLogType.Invocation"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackInvocationLogDetails"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackInvocationLogDetails {
        ///Only used by sync invocations.
        #[serde(rename = "completionJson", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub completion_json: ::std::option::Option<::std::string::String>,
        ///Only used by sync invocations.
        #[serde(rename = "continuationJson", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub continuation_json: ::std::option::Option<::std::string::String>,
        ///Only used by sync invocations.
        #[serde(rename = "deletedItemIdsJson", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub deleted_item_ids_json: ::std::option::Option<::std::string::String>,
        ///Only used by sync invocations.
        #[serde(rename = "permissionsContextJson", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub permissions_context_json: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<PackInvocationLogDetailsResult>,
        ///Supplementary information about the result.
        #[serde(rename = "resultDetail", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result_detail: ::std::option::Option<::std::string::String>,
        #[serde(rename = "type")]
        pub type_: PackInvocationLogDetailsType,
    }

    impl ::std::convert::From<&PackInvocationLogDetails> for PackInvocationLogDetails {
        fn from(value: &PackInvocationLogDetails) -> Self {
            value.clone()
        }
    }

    ///`PackInvocationLogDetailsResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "boolVal",
    ///    "dateVal",
    ///    "doubleVal",
    ///    "int64Val",
    ///    "objectVal",
    ///    "stringVal"
    ///  ],
    ///  "properties": {
    ///    "boolVal": {
    ///      "type": "boolean"
    ///    },
    ///    "dateVal": {
    ///      "type": "number"
    ///    },
    ///    "doubleVal": {
    ///      "type": "number"
    ///    },
    ///    "int64Val": {
    ///      "type": "number"
    ///    },
    ///    "objectVal": {
    ///      "type": "string"
    ///    },
    ///    "stringVal": {
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackInvocationLogDetailsResult {
        #[serde(rename = "boolVal")]
        pub bool_val: bool,
        #[serde(rename = "dateVal")]
        pub date_val: f64,
        #[serde(rename = "doubleVal")]
        pub double_val: f64,
        #[serde(rename = "int64Val")]
        pub int64_val: f64,
        #[serde(rename = "objectVal")]
        pub object_val: ::std::string::String,
        #[serde(rename = "stringVal")]
        pub string_val: ::std::string::String,
    }

    impl ::std::convert::From<&PackInvocationLogDetailsResult> for PackInvocationLogDetailsResult {
        fn from(value: &PackInvocationLogDetailsResult) -> Self {
            value.clone()
        }
    }

    ///`PackInvocationLogDetailsType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "invocation"
    ///  ],
    ///  "x-tsType": "PackLogType.Invocation"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackInvocationLogDetailsType {
        #[serde(rename = "invocation")]
        Invocation,
    }

    impl ::std::convert::From<&Self> for PackInvocationLogDetailsType {
        fn from(value: &PackInvocationLogDetailsType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackInvocationLogDetailsType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Invocation => f.write_str("invocation"),
            }
        }
    }

    impl ::std::str::FromStr for PackInvocationLogDetailsType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "invocation" => Ok(Self::Invocation),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackInvocationLogDetailsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackInvocationLogDetailsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackInvocationLogDetailsType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Error info if this invocation resulted in an error.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Error info if this invocation resulted in an error.",
    ///  "type": "object",
    ///  "required": [
    ///    "message"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "type": "string"
    ///    },
    ///    "stack": {
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackInvocationLogError {
        pub message: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub stack: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&PackInvocationLogError> for PackInvocationLogError {
        fn from(value: &PackInvocationLogError) -> Self {
            value.clone()
        }
    }

    ///`PackInvocationLogType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "invocation"
    ///  ],
    ///  "x-tsType": "PackLogType.Invocation"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackInvocationLogType {
        #[serde(rename = "invocation")]
        Invocation,
    }

    impl ::std::convert::From<&Self> for PackInvocationLogType {
        fn from(value: &PackInvocationLogType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackInvocationLogType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Invocation => f.write_str("invocation"),
            }
        }
    }

    impl ::std::str::FromStr for PackInvocationLogType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "invocation" => Ok(Self::Invocation),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackInvocationLogType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackInvocationLogType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackInvocationLogType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///A Pack listing.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A Pack listing.",
    ///  "type": "object",
    ///  "required": [
    ///    "categories",
    ///    "description",
    ///    "externalMetadataUrl",
    ///    "logoUrl",
    ///    "makers",
    ///    "name",
    ///    "packId",
    ///    "packVersion",
    ///    "sdkVersion",
    ///    "shortDescription"
    ///  ],
    ///  "properties": {
    ///    "agentDescription": {
    ///      "description": "A full description for the pack as an agent.",
    ///      "examples": [
    ///        "Chat with a comprehensive tool that can calculate cool geometric
    /// formulas like surface area, volume, and other mathematical operations.
    /// This agent can help with complex calculations and provide detailed
    /// explanations."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "agentImages": {
    ///      "description": "The agent images for the Pack.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PackImageFile"
    ///      }
    ///    },
    ///    "agentShortDescription": {
    ///      "description": "A short description for the pack as an agent.",
    ///      "examples": [
    ///        "Chat with a tool that can calculate cool geometric formulas like
    /// surface area."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "bundledPackPlan": {
    ///      "$ref": "#/components/schemas/BundledPackPlan"
    ///    },
    ///    "categories": {
    ///      "description": "Publishing Categories associated with this Pack.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PublishingCategory"
    ///      }
    ///    },
    ///    "certified": {
    ///      "description": "Denotes if the pack is certified by Coda.",
    ///      "type": "boolean"
    ///    },
    ///    "certifiedAgent": {
    ///      "description": "Denotes if the pack is certified by Grammarly to be
    /// optimized for agent usage.",
    ///      "type": "boolean"
    ///    },
    ///    "coverUrl": {
    ///      "description": "The link to the cover photo of the Pack.",
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "description": {
    ///      "description": "The full description of the Pack.",
    ///      "examples": [
    ///        "This Pack allows users to calculate the surface area and volume
    /// of a few common 3D shapes, like cubes and pyramids."
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 8192
    ///    },
    ///    "exampleImages": {
    ///      "description": "The example images for the Pack.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PackImageFile"
    ///      }
    ///    },
    ///    "externalMetadataUrl": {
    ///      "description": "The URL where complete metadata about the contents
    /// of the Pack version can be downloaded.",
    ///      "examples": [
    ///        "https://codahosted.io/packs/12345/1.2.3/metadata/0c892064aa5cb.json"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "lastReleasedAt": {
    ///      "description": "The timestamp of the latest release of this Pack.",
    ///      "examples": [
    ///        "2018-04-11T00:18:57.946Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "logoUrl": {
    ///      "description": "The link to the logo of the Pack.",
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "makers": {
    ///      "description": "Makers associated with this Pack.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/MakerSummary"
    ///      }
    ///    },
    ///    "minimumFeatureSet": {
    ///      "$ref": "#/components/schemas/FeatureSet"
    ///    },
    ///    "name": {
    ///      "description": "The name of the Pack.",
    ///      "examples": [
    ///        "Cool Geometry Formulas"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "packId": {
    ///      "description": "ID of the Pack.",
    ///      "examples": [
    ///        1003
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "packVersion": {
    ///      "description": "The version of the Pack.",
    ///      "examples": [
    ///        "1.0.3"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "privacyPolicyUrl": {
    ///      "description": "A Privacy Policy URL for the Pack.",
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "releaseId": {
    ///      "description": "The current release number of the Pack if released,
    /// otherwise undefined.",
    ///      "examples": [
    ///        2
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "sdkVersion": {
    ///      "description": "What Packs SDK version was this version built on.",
    ///      "examples": [
    ///        "1.5.1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "shortDescription": {
    ///      "description": "A short version of the description of the Pack.",
    ///      "examples": [
    ///        "Calculate cool geometric formulas like surface area."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "sourceCodeVisibility": {
    ///      "$ref": "#/components/schemas/PackSourceCodeVisibility"
    ///    },
    ///    "standardPackPlan": {
    ///      "$ref": "#/components/schemas/StandardPackPlan"
    ///    },
    ///    "supportEmail": {
    ///      "description": "A contact email for the Pack.",
    ///      "examples": [
    ///        "user@email.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "termsOfServiceUrl": {
    ///      "description": "A Terms of Service URL for the Pack.",
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "unrestrictedFeatureSet": {
    ///      "$ref": "#/components/schemas/FeatureSet"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackListing"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackListing {
        ///A full description for the pack as an agent.
        #[serde(rename = "agentDescription", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub agent_description: ::std::option::Option<::std::string::String>,
        ///The agent images for the Pack.
        #[serde(rename = "agentImages", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub agent_images: ::std::vec::Vec<PackImageFile>,
        ///A short description for the pack as an agent.
        #[serde(rename = "agentShortDescription", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub agent_short_description: ::std::option::Option<::std::string::String>,
        #[serde(rename = "bundledPackPlan", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bundled_pack_plan: ::std::option::Option<BundledPackPlan>,
        ///Publishing Categories associated with this Pack.
        pub categories: ::std::vec::Vec<PublishingCategory>,
        ///Denotes if the pack is certified by Coda.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub certified: ::std::option::Option<bool>,
        ///Denotes if the pack is certified by Grammarly to be optimized for
        /// agent usage.
        #[serde(rename = "certifiedAgent", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub certified_agent: ::std::option::Option<bool>,
        ///The link to the cover photo of the Pack.
        #[serde(rename = "coverUrl", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cover_url: ::std::option::Option<::std::string::String>,
        ///The full description of the Pack.
        pub description: PackListingDescription,
        ///The example images for the Pack.
        #[serde(rename = "exampleImages", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub example_images: ::std::vec::Vec<PackImageFile>,
        ///The URL where complete metadata about the contents of the Pack
        /// version can be downloaded.
        #[serde(rename = "externalMetadataUrl")]
        pub external_metadata_url: ::std::string::String,
        ///The timestamp of the latest release of this Pack.
        #[serde(rename = "lastReleasedAt", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_released_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        ///The link to the logo of the Pack.
        #[serde(rename = "logoUrl")]
        pub logo_url: ::std::string::String,
        ///Makers associated with this Pack.
        pub makers: ::std::vec::Vec<MakerSummary>,
        #[serde(rename = "minimumFeatureSet", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub minimum_feature_set: ::std::option::Option<FeatureSet>,
        ///The name of the Pack.
        pub name: ::std::string::String,
        #[serde(rename = "packId")]
        pub pack_id: f64,
        ///The version of the Pack.
        #[serde(rename = "packVersion")]
        pub pack_version: ::std::string::String,
        ///A Privacy Policy URL for the Pack.
        #[serde(rename = "privacyPolicyUrl", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub privacy_policy_url: ::std::option::Option<::std::string::String>,
        #[serde(rename = "releaseId", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub release_id: ::std::option::Option<f64>,
        ///What Packs SDK version was this version built on.
        #[serde(rename = "sdkVersion")]
        pub sdk_version: ::std::string::String,
        ///A short version of the description of the Pack.
        #[serde(rename = "shortDescription")]
        pub short_description: ::std::string::String,
        #[serde(rename = "sourceCodeVisibility", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub source_code_visibility: ::std::option::Option<PackSourceCodeVisibility>,
        #[serde(rename = "standardPackPlan", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub standard_pack_plan: ::std::option::Option<StandardPackPlan>,
        ///A contact email for the Pack.
        #[serde(rename = "supportEmail", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub support_email: ::std::option::Option<::std::string::String>,
        ///A Terms of Service URL for the Pack.
        #[serde(rename = "termsOfServiceUrl", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub terms_of_service_url: ::std::option::Option<::std::string::String>,
        #[serde(rename = "unrestrictedFeatureSet", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub unrestricted_feature_set: ::std::option::Option<FeatureSet>,
    }

    impl ::std::convert::From<&PackListing> for PackListing {
        fn from(value: &PackListing) -> Self {
            value.clone()
        }
    }

    ///The full description of the Pack.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The full description of the Pack.",
    ///  "examples": [
    ///    "This Pack allows users to calculate the surface area and volume of a
    /// few common 3D shapes, like cubes and pyramids."
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 8192
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PackListingDescription(::std::string::String);
    impl ::std::ops::Deref for PackListingDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PackListingDescription> for ::std::string::String {
        fn from(value: PackListingDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PackListingDescription> for PackListingDescription {
        fn from(value: &PackListingDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PackListingDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 8192usize {
                return Err("longer than 8192 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PackListingDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackListingDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackListingDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PackListingDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///A detailed Pack listing.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A detailed Pack listing.",
    ///  "type": "object",
    ///  "required": [
    ///    "categories",
    ///    "description",
    ///    "discoverability",
    ///    "externalMetadataUrl",
    ///    "logoUrl",
    ///    "makers",
    ///    "name",
    ///    "packId",
    ///    "packVersion",
    ///    "sdkVersion",
    ///    "shortDescription",
    ///    "userAccess"
    ///  ],
    ///  "properties": {
    ///    "agentDescription": {
    ///      "description": "A full description for the pack as an agent.",
    ///      "examples": [
    ///        "Chat with a comprehensive tool that can calculate cool geometric
    /// formulas like surface area, volume, and other mathematical operations.
    /// This agent can help with complex calculations and provide detailed
    /// explanations."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "agentImages": {
    ///      "description": "The agent images for the Pack.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PackImageFile"
    ///      }
    ///    },
    ///    "agentShortDescription": {
    ///      "description": "A short description for the pack as an agent.",
    ///      "examples": [
    ///        "Chat with a tool that can calculate cool geometric formulas like
    /// surface area."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "bundledPackPlan": {
    ///      "$ref": "#/components/schemas/BundledPackPlan"
    ///    },
    ///    "categories": {
    ///      "description": "Publishing Categories associated with this Pack.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PublishingCategory"
    ///      }
    ///    },
    ///    "certified": {
    ///      "description": "Denotes if the pack is certified by Coda.",
    ///      "type": "boolean"
    ///    },
    ///    "certifiedAgent": {
    ///      "description": "Denotes if the pack is certified by Grammarly to be
    /// optimized for agent usage.",
    ///      "type": "boolean"
    ///    },
    ///    "codaHelpCenterUrl": {
    ///      "description": "The URL of a Coda Help Center article with
    /// documentation about the Pack. This will only exist for select
    /// Coda-authored Packs.",
    ///      "type": "string"
    ///    },
    ///    "configuration": {
    ///      "$ref": "#/components/schemas/PackConfigurationEntry"
    ///    },
    ///    "coverUrl": {
    ///      "description": "The link to the cover photo of the Pack.",
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "description": {
    ///      "description": "The full description of the Pack.",
    ///      "examples": [
    ///        "This Pack allows users to calculate the surface area and volume
    /// of a few common 3D shapes, like cubes and pyramids."
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 8192
    ///    },
    ///    "discoverability": {
    ///      "$ref": "#/components/schemas/PackDiscoverability"
    ///    },
    ///    "exampleImages": {
    ///      "description": "The example images for the Pack.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PackImageFile"
    ///      }
    ///    },
    ///    "externalMetadataUrl": {
    ///      "description": "The URL where complete metadata about the contents
    /// of the Pack version can be downloaded.",
    ///      "examples": [
    ///        "https://codahosted.io/packs/12345/1.2.3/metadata/0c892064aa5cb.json"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "lastReleasedAt": {
    ///      "description": "The timestamp of the latest release of this Pack.",
    ///      "examples": [
    ///        "2018-04-11T00:18:57.946Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "logoUrl": {
    ///      "description": "The link to the logo of the Pack.",
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "makers": {
    ///      "description": "Makers associated with this Pack.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/MakerSummary"
    ///      }
    ///    },
    ///    "minimumFeatureSet": {
    ///      "$ref": "#/components/schemas/FeatureSet"
    ///    },
    ///    "name": {
    ///      "description": "The name of the Pack.",
    ///      "examples": [
    ///        "Cool Geometry Formulas"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "packId": {
    ///      "description": "ID of the Pack.",
    ///      "examples": [
    ///        1003
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "packVersion": {
    ///      "description": "The version of the Pack.",
    ///      "examples": [
    ///        "1.0.3"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "privacyPolicyUrl": {
    ///      "description": "A Privacy Policy URL for the Pack.",
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "releaseId": {
    ///      "description": "The current release number of the Pack if released,
    /// otherwise undefined.",
    ///      "examples": [
    ///        2
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "sdkVersion": {
    ///      "description": "What Packs SDK version was this version built on.",
    ///      "examples": [
    ///        "1.5.1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "shortDescription": {
    ///      "description": "A short version of the description of the Pack.",
    ///      "examples": [
    ///        "Calculate cool geometric formulas like surface area."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "sourceCodeVisibility": {
    ///      "$ref": "#/components/schemas/PackSourceCodeVisibility"
    ///    },
    ///    "standardPackPlan": {
    ///      "$ref": "#/components/schemas/StandardPackPlan"
    ///    },
    ///    "supportEmail": {
    ///      "description": "A contact email for the Pack.",
    ///      "examples": [
    ///        "user@email.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "termsOfServiceUrl": {
    ///      "description": "A Terms of Service URL for the Pack.",
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "unrestrictedFeatureSet": {
    ///      "$ref": "#/components/schemas/FeatureSet"
    ///    },
    ///    "userAccess": {
    ///      "$ref": "#/components/schemas/PackUserAccess"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackListingDetail"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackListingDetail {
        ///A full description for the pack as an agent.
        #[serde(rename = "agentDescription", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub agent_description: ::std::option::Option<::std::string::String>,
        ///The agent images for the Pack.
        #[serde(rename = "agentImages", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub agent_images: ::std::vec::Vec<PackImageFile>,
        ///A short description for the pack as an agent.
        #[serde(rename = "agentShortDescription", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub agent_short_description: ::std::option::Option<::std::string::String>,
        #[serde(rename = "bundledPackPlan", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bundled_pack_plan: ::std::option::Option<BundledPackPlan>,
        ///Publishing Categories associated with this Pack.
        pub categories: ::std::vec::Vec<PublishingCategory>,
        ///Denotes if the pack is certified by Coda.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub certified: ::std::option::Option<bool>,
        ///Denotes if the pack is certified by Grammarly to be optimized for
        /// agent usage.
        #[serde(rename = "certifiedAgent", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub certified_agent: ::std::option::Option<bool>,
        ///The URL of a Coda Help Center article with documentation about the
        /// Pack. This will only exist for select Coda-authored Packs.
        #[serde(rename = "codaHelpCenterUrl", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub coda_help_center_url: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub configuration: ::std::option::Option<PackConfigurationEntry>,
        ///The link to the cover photo of the Pack.
        #[serde(rename = "coverUrl", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cover_url: ::std::option::Option<::std::string::String>,
        ///The full description of the Pack.
        pub description: PackListingDetailDescription,
        pub discoverability: PackDiscoverability,
        ///The example images for the Pack.
        #[serde(rename = "exampleImages", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub example_images: ::std::vec::Vec<PackImageFile>,
        ///The URL where complete metadata about the contents of the Pack
        /// version can be downloaded.
        #[serde(rename = "externalMetadataUrl")]
        pub external_metadata_url: ::std::string::String,
        ///The timestamp of the latest release of this Pack.
        #[serde(rename = "lastReleasedAt", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_released_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        ///The link to the logo of the Pack.
        #[serde(rename = "logoUrl")]
        pub logo_url: ::std::string::String,
        ///Makers associated with this Pack.
        pub makers: ::std::vec::Vec<MakerSummary>,
        #[serde(rename = "minimumFeatureSet", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub minimum_feature_set: ::std::option::Option<FeatureSet>,
        ///The name of the Pack.
        pub name: ::std::string::String,
        #[serde(rename = "packId")]
        pub pack_id: f64,
        ///The version of the Pack.
        #[serde(rename = "packVersion")]
        pub pack_version: ::std::string::String,
        ///A Privacy Policy URL for the Pack.
        #[serde(rename = "privacyPolicyUrl", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub privacy_policy_url: ::std::option::Option<::std::string::String>,
        #[serde(rename = "releaseId", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub release_id: ::std::option::Option<f64>,
        ///What Packs SDK version was this version built on.
        #[serde(rename = "sdkVersion")]
        pub sdk_version: ::std::string::String,
        ///A short version of the description of the Pack.
        #[serde(rename = "shortDescription")]
        pub short_description: ::std::string::String,
        #[serde(rename = "sourceCodeVisibility", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub source_code_visibility: ::std::option::Option<PackSourceCodeVisibility>,
        #[serde(rename = "standardPackPlan", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub standard_pack_plan: ::std::option::Option<StandardPackPlan>,
        ///A contact email for the Pack.
        #[serde(rename = "supportEmail", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub support_email: ::std::option::Option<::std::string::String>,
        ///A Terms of Service URL for the Pack.
        #[serde(rename = "termsOfServiceUrl", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub terms_of_service_url: ::std::option::Option<::std::string::String>,
        #[serde(rename = "unrestrictedFeatureSet", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub unrestricted_feature_set: ::std::option::Option<FeatureSet>,
        #[serde(rename = "userAccess")]
        pub user_access: PackUserAccess,
    }

    impl ::std::convert::From<&PackListingDetail> for PackListingDetail {
        fn from(value: &PackListingDetail) -> Self {
            value.clone()
        }
    }

    ///The full description of the Pack.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The full description of the Pack.",
    ///  "examples": [
    ///    "This Pack allows users to calculate the surface area and volume of a
    /// few common 3D shapes, like cubes and pyramids."
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 8192
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PackListingDetailDescription(::std::string::String);
    impl ::std::ops::Deref for PackListingDetailDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PackListingDetailDescription> for ::std::string::String {
        fn from(value: PackListingDetailDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PackListingDetailDescription> for PackListingDetailDescription {
        fn from(value: &PackListingDetailDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PackListingDetailDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 8192usize {
                return Err("longer than 8192 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PackListingDetailDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackListingDetailDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackListingDetailDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PackListingDetailDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///Type of context in which a Pack is being installed.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Type of context in which a Pack is being installed.",
    ///  "type": "string",
    ///  "enum": [
    ///    "workspace",
    ///    "doc"
    ///  ],
    ///  "x-schema-name": "PackListingInstallContextType",
    ///  "x-tsEnumNames": [
    ///    "Workspace",
    ///    "Doc"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackListingInstallContextType {
        #[serde(rename = "workspace")]
        Workspace,
        #[serde(rename = "doc")]
        Doc,
    }

    impl ::std::convert::From<&Self> for PackListingInstallContextType {
        fn from(value: &PackListingInstallContextType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackListingInstallContextType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Workspace => f.write_str("workspace"),
                Self::Doc => f.write_str("doc"),
            }
        }
    }

    impl ::std::str::FromStr for PackListingInstallContextType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "workspace" => Ok(Self::Workspace),
                "doc" => Ok(Self::Doc),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackListingInstallContextType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackListingInstallContextType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackListingInstallContextType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///A list of Pack listings.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A list of Pack listings.",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PackListing"
    ///      }
    ///    },
    ///    "nextPageLink": {
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/nextPageLink"
    ///        },
    ///        {
    ///          "examples": [
    ///            "https://coda.io/apis/v1/packs/listings?pageToken=xyz"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      ]
    ///    },
    ///    "nextPageToken": {
    ///      "$ref": "#/components/schemas/nextPageToken"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackListingList"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackListingList {
        pub items: ::std::vec::Vec<PackListing>,
        #[serde(rename = "nextPageLink", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_link: ::std::option::Option<NextPageLink>,
        #[serde(rename = "nextPageToken", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_token: ::std::option::Option<NextPageToken>,
    }

    impl ::std::convert::From<&PackListingList> for PackListingList {
        fn from(value: &PackListingList) -> Self {
            value.clone()
        }
    }

    ///Determines how the Pack listings returned are sorted.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Determines how the Pack listings returned are sorted.",
    ///  "type": "string",
    ///  "enum": [
    ///    "packId",
    ///    "name",
    ///    "packVersion",
    ///    "packVersionModifiedAt"
    ///  ],
    ///  "x-schema-name": "PackListingsSortBy",
    ///  "x-tsEnumNames": [
    ///    "PackId",
    ///    "Name",
    ///    "PackVersion",
    ///    "PackVersionModifiedAt"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackListingsSortBy {
        #[serde(rename = "packId")]
        PackId,
        #[serde(rename = "name")]
        Name,
        #[serde(rename = "packVersion")]
        PackVersion,
        #[serde(rename = "packVersionModifiedAt")]
        PackVersionModifiedAt,
    }

    impl ::std::convert::From<&Self> for PackListingsSortBy {
        fn from(value: &PackListingsSortBy) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackListingsSortBy {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::PackId => f.write_str("packId"),
                Self::Name => f.write_str("name"),
                Self::PackVersion => f.write_str("packVersion"),
                Self::PackVersionModifiedAt => f.write_str("packVersionModifiedAt"),
            }
        }
    }

    impl ::std::str::FromStr for PackListingsSortBy {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "packId" => Ok(Self::PackId),
                "name" => Ok(Self::Name),
                "packVersion" => Ok(Self::PackVersion),
                "packVersionModifiedAt" => Ok(Self::PackVersionModifiedAt),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackListingsSortBy {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackListingsSortBy {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackListingsSortBy {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///A record of Pack log.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A record of Pack log.",
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/PackCustomLog"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PackInvocationLog"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PackFetcherLog"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PackInternalLog"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PackAuthLog"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PackIngestionLifecycleLog"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PackIngestionDebugLog"
    ///    }
    ///  ],
    ///  "x-schema-name": "PackLog"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum PackLog {
        CustomLog(PackCustomLog),
        InvocationLog(PackInvocationLog),
        FetcherLog(PackFetcherLog),
        InternalLog(PackInternalLog),
        AuthLog(PackAuthLog),
        IngestionLifecycleLog(PackIngestionLifecycleLog),
        IngestionDebugLog(PackIngestionDebugLog),
    }

    impl ::std::convert::From<&Self> for PackLog {
        fn from(value: &PackLog) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<PackCustomLog> for PackLog {
        fn from(value: PackCustomLog) -> Self {
            Self::CustomLog(value)
        }
    }

    impl ::std::convert::From<PackInvocationLog> for PackLog {
        fn from(value: PackInvocationLog) -> Self {
            Self::InvocationLog(value)
        }
    }

    impl ::std::convert::From<PackFetcherLog> for PackLog {
        fn from(value: PackFetcherLog) -> Self {
            Self::FetcherLog(value)
        }
    }

    impl ::std::convert::From<PackInternalLog> for PackLog {
        fn from(value: PackInternalLog) -> Self {
            Self::InternalLog(value)
        }
    }

    impl ::std::convert::From<PackAuthLog> for PackLog {
        fn from(value: PackAuthLog) -> Self {
            Self::AuthLog(value)
        }
    }

    impl ::std::convert::From<PackIngestionLifecycleLog> for PackLog {
        fn from(value: PackIngestionLifecycleLog) -> Self {
            Self::IngestionLifecycleLog(value)
        }
    }

    impl ::std::convert::From<PackIngestionDebugLog> for PackLog {
        fn from(value: PackIngestionDebugLog) -> Self {
            Self::IngestionDebugLog(value)
        }
    }

    ///Logging context that comes with a Pack log.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Logging context that comes with a Pack log.",
    ///  "type": "object",
    ///  "required": [
    ///    "connectionId",
    ///    "createdAt",
    ///    "detailsKey",
    ///    "docId",
    ///    "formulaName",
    ///    "logId",
    ///    "packId",
    ///    "packVersion",
    ///    "requestId",
    ///    "requestType",
    ///    "userId"
    ///  ],
    ///  "properties": {
    ///    "additionalMetadata": {
    ///      "description": "Additional metadata for the ingestion log.",
    ///      "type": "object"
    ///    },
    ///    "autocompleteParameterName": {
    ///      "description": "If this formula invocation was for a parameter
    /// auto-complete, this names the parameter.",
    ///      "type": "string"
    ///    },
    ///    "connectionId": {
    ///      "type": "string"
    ///    },
    ///    "connectionName": {
    ///      "type": "string"
    ///    },
    ///    "createdAt": {
    ///      "description": "Creation time of the log.",
    ///      "examples": [
    ///        "2018-04-11T00:18:57.946Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "detailsKey": {
    ///      "description": "Key to be used in fetching log details.",
    ///      "type": "string"
    ///    },
    ///    "docColumnId": {
    ///      "description": "Doc canvas column id where the formula was fired
    /// from.",
    ///      "type": "string"
    ///    },
    ///    "docId": {
    ///      "type": "string"
    ///    },
    ///    "docObjectId": {
    ///      "description": "Doc canvas object id where the formula was fired
    /// from.",
    ///      "type": "string"
    ///    },
    ///    "docRowId": {
    ///      "description": "Doc canvas row id where the formula was fired
    /// from.",
    ///      "type": "string"
    ///    },
    ///    "formulaName": {
    ///      "type": "string"
    ///    },
    ///    "ingestionChildExecutionIndex": {
    ///      "description": "Child execution id for this ingestion log.",
    ///      "type": "number"
    ///    },
    ///    "ingestionExecutionAttempt": {
    ///      "description": "Execution attempt for this ingestion log.",
    ///      "type": "integer"
    ///    },
    ///    "ingestionExecutionId": {
    ///      "description": "Unique identifier of the ingestion execution that
    /// triggered this log.",
    ///      "type": "string"
    ///    },
    ///    "ingestionId": {
    ///      "description": "Unique identifier of the ingestion that triggered
    /// this log.",
    ///      "type": "string"
    ///    },
    ///    "ingestionParentItemId": {
    ///      "description": "Parent item id for this ingestion log.",
    ///      "type": "string"
    ///    },
    ///    "ingestionParentStage": {
    ///      "description": "An ingestion lifecycle stage that this ingestion
    /// log is bundled under.",
    ///      "type": "string"
    ///    },
    ///    "ingestionProcessId": {
    ///      "description": "Unique identifier of the ingestion processing call
    /// that triggered this log.",
    ///      "type": "string"
    ///    },
    ///    "ingestionStage": {
    ///      "description": "Stage along the ingestion lifecycle that this log
    /// was created in.",
    ///      "type": "string"
    ///    },
    ///    "invocationSource": {
    ///      "description": "If this formula was invoked by something other than
    /// a user action, this should say what that was.",
    ///      "type": "string"
    ///    },
    ///    "isContinuedSyncTable": {
    ///      "description": "True if this is an execution of a sync table which
    /// received a pagination parameter.",
    ///      "type": "boolean"
    ///    },
    ///    "isSyncTable": {
    ///      "description": "True if this is a formula invocation loading a page
    /// of a sync table, or metadata for a sync table (like creating a dynamic
    /// schema).",
    ///      "type": "boolean"
    ///    },
    ///    "logId": {
    ///      "description": "Unique identifier of this log record.",
    ///      "type": "string"
    ///    },
    ///    "packId": {
    ///      "type": "string"
    ///    },
    ///    "packVersion": {
    ///      "type": "string"
    ///    },
    ///    "requestId": {
    ///      "description": "A unique identifier of the Pack invocation that can
    /// be used to associate all log types generated in one call of a Pack
    /// formula.\n",
    ///      "type": "string"
    ///    },
    ///    "requestType": {
    ///      "$ref": "#/components/schemas/PackLogRequestType"
    ///    },
    ///    "rootIngestionId": {
    ///      "description": "Unique identifier of the root ingestion that
    /// triggered this log.",
    ///      "type": "string"
    ///    },
    ///    "userId": {
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackLogContext"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackLogContext {
        ///Additional metadata for the ingestion log.
        #[serde(rename = "additionalMetadata", default, skip_serializing_if = "::serde_json::Map::is_empty")]
        pub additional_metadata: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        ///If this formula invocation was for a parameter auto-complete, this
        /// names the parameter.
        #[serde(rename = "autocompleteParameterName", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub autocomplete_parameter_name: ::std::option::Option<::std::string::String>,
        #[serde(rename = "connectionId")]
        pub connection_id: ::std::string::String,
        #[serde(rename = "connectionName", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub connection_name: ::std::option::Option<::std::string::String>,
        ///Creation time of the log.
        #[serde(rename = "createdAt")]
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        ///Key to be used in fetching log details.
        #[serde(rename = "detailsKey")]
        pub details_key: ::std::string::String,
        ///Doc canvas column id where the formula was fired from.
        #[serde(rename = "docColumnId", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub doc_column_id: ::std::option::Option<::std::string::String>,
        #[serde(rename = "docId")]
        pub doc_id: ::std::string::String,
        ///Doc canvas object id where the formula was fired from.
        #[serde(rename = "docObjectId", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub doc_object_id: ::std::option::Option<::std::string::String>,
        ///Doc canvas row id where the formula was fired from.
        #[serde(rename = "docRowId", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub doc_row_id: ::std::option::Option<::std::string::String>,
        #[serde(rename = "formulaName")]
        pub formula_name: ::std::string::String,
        #[serde(rename = "ingestionChildExecutionIndex", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub ingestion_child_execution_index: ::std::option::Option<f64>,
        ///Execution attempt for this ingestion log.
        #[serde(rename = "ingestionExecutionAttempt", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub ingestion_execution_attempt: ::std::option::Option<i64>,
        ///Unique identifier of the ingestion execution that triggered this
        /// log.
        #[serde(rename = "ingestionExecutionId", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub ingestion_execution_id: ::std::option::Option<::std::string::String>,
        ///Unique identifier of the ingestion that triggered this log.
        #[serde(rename = "ingestionId", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub ingestion_id: ::std::option::Option<::std::string::String>,
        ///Parent item id for this ingestion log.
        #[serde(rename = "ingestionParentItemId", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub ingestion_parent_item_id: ::std::option::Option<::std::string::String>,
        ///An ingestion lifecycle stage that this ingestion log is bundled
        /// under.
        #[serde(rename = "ingestionParentStage", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub ingestion_parent_stage: ::std::option::Option<::std::string::String>,
        ///Unique identifier of the ingestion processing call that triggered
        /// this log.
        #[serde(rename = "ingestionProcessId", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub ingestion_process_id: ::std::option::Option<::std::string::String>,
        ///Stage along the ingestion lifecycle that this log was created in.
        #[serde(rename = "ingestionStage", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub ingestion_stage: ::std::option::Option<::std::string::String>,
        ///If this formula was invoked by something other than a user action,
        /// this should say what that was.
        #[serde(rename = "invocationSource", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub invocation_source: ::std::option::Option<::std::string::String>,
        ///True if this is an execution of a sync table which received a
        /// pagination parameter.
        #[serde(rename = "isContinuedSyncTable", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_continued_sync_table: ::std::option::Option<bool>,
        ///True if this is a formula invocation loading a page of a sync table,
        /// or metadata for a sync table (like creating a dynamic schema).
        #[serde(rename = "isSyncTable", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_sync_table: ::std::option::Option<bool>,
        ///Unique identifier of this log record.
        #[serde(rename = "logId")]
        pub log_id: ::std::string::String,
        #[serde(rename = "packId")]
        pub pack_id: ::std::string::String,
        #[serde(rename = "packVersion")]
        pub pack_version: ::std::string::String,
        ///A unique identifier of the Pack invocation that can be used to
        /// associate all log types generated in one call of a Pack formula.
        #[serde(rename = "requestId")]
        pub request_id: ::std::string::String,
        #[serde(rename = "requestType")]
        pub request_type: PackLogRequestType,
        ///Unique identifier of the root ingestion that triggered this log.
        #[serde(rename = "rootIngestionId", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub root_ingestion_id: ::std::option::Option<::std::string::String>,
        #[serde(rename = "userId")]
        pub user_id: ::std::string::String,
    }

    impl ::std::convert::From<&PackLogContext> for PackLogContext {
        fn from(value: &PackLogContext) -> Self {
            value.clone()
        }
    }

    ///Details for a pack log.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Details for a pack log.",
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/PackFetcherLogDetails"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PackInvocationLogDetails"
    ///    }
    ///  ],
    ///  "x-schema-name": "PackLogDetails"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum PackLogDetails {
        FetcherLogDetails(PackFetcherLogDetails),
        InvocationLogDetails(PackInvocationLogDetails),
    }

    impl ::std::convert::From<&Self> for PackLogDetails {
        fn from(value: &PackLogDetails) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<PackFetcherLogDetails> for PackLogDetails {
        fn from(value: PackFetcherLogDetails) -> Self {
            Self::FetcherLogDetails(value)
        }
    }

    impl ::std::convert::From<PackInvocationLogDetails> for PackLogDetails {
        fn from(value: PackInvocationLogDetails) -> Self {
            Self::InvocationLogDetails(value)
        }
    }

    ///The context request type where a Pack log is generated.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The context request type where a Pack log is
    /// generated.",
    ///  "type": "string",
    ///  "enum": [
    ///    "unknown",
    ///    "connectionNameMetadataRequest",
    ///    "parameterAutocompleteMetadataRequest",
    ///    "postAuthSetupMetadataRequest",
    ///    "propertyOptionsMetadataRequest",
    ///    "getSyncTableSchemaMetadataRequest",
    ///    "getDynamicSyncTableNameMetadataRequest",
    ///    "listSyncTableDynamicUrlsMetadataRequest",
    ///    "searchSyncTableDynamicUrlsMetadataRequest",
    ///    "getDynamicSyncTableDisplayUrlMetadataRequest",
    ///    "getIdentifiersForConnectionRequest",
    ///    "invokeFormulaRequest",
    ///    "invokeSyncFormulaRequest",
    ///    "invokeSyncUpdateFormulaRequest",
    ///    "invokeExecuteGetPermissionsRequest",
    ///    "validateParametersMetadataRequest"
    ///  ],
    ///  "x-schema-name": "PackLogRequestType",
    ///  "x-tsEnumNames": [
    ///    "Unknown",
    ///    "ConnectionNameMetadataRequest",
    ///    "ParameterAutocompleteMetadataRequest",
    ///    "PostAuthSetupMetadataRequest",
    ///    "PropertyOptionsMetadataRequest",
    ///    "GetSyncTableSchemaMetadataRequest",
    ///    "GetDynamicSyncTableNameMetadataRequest",
    ///    "ListSyncTableDynamicUrlsMetadataRequest",
    ///    "SearchSyncTableDynamicUrlsMetadataRequest",
    ///    "GetDynamicSyncTableDisplayUrlMetadataRequest",
    ///    "ValidateParametersMetadataRequest",
    ///    "GetIdentifiersForConnectionRequest",
    ///    "InvokeFormulaRequest",
    ///    "InvokeSyncFormulaRequest",
    ///    "InvokeSyncUpdateFormulaRequest",
    ///    "InvokeExecuteGetPermissionsRequest"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackLogRequestType {
        #[serde(rename = "unknown")]
        Unknown,
        #[serde(rename = "connectionNameMetadataRequest")]
        ConnectionNameMetadataRequest,
        #[serde(rename = "parameterAutocompleteMetadataRequest")]
        ParameterAutocompleteMetadataRequest,
        #[serde(rename = "postAuthSetupMetadataRequest")]
        PostAuthSetupMetadataRequest,
        #[serde(rename = "propertyOptionsMetadataRequest")]
        PropertyOptionsMetadataRequest,
        #[serde(rename = "getSyncTableSchemaMetadataRequest")]
        GetSyncTableSchemaMetadataRequest,
        #[serde(rename = "getDynamicSyncTableNameMetadataRequest")]
        GetDynamicSyncTableNameMetadataRequest,
        #[serde(rename = "listSyncTableDynamicUrlsMetadataRequest")]
        ListSyncTableDynamicUrlsMetadataRequest,
        #[serde(rename = "searchSyncTableDynamicUrlsMetadataRequest")]
        SearchSyncTableDynamicUrlsMetadataRequest,
        #[serde(rename = "getDynamicSyncTableDisplayUrlMetadataRequest")]
        GetDynamicSyncTableDisplayUrlMetadataRequest,
        #[serde(rename = "getIdentifiersForConnectionRequest")]
        GetIdentifiersForConnectionRequest,
        #[serde(rename = "invokeFormulaRequest")]
        InvokeFormulaRequest,
        #[serde(rename = "invokeSyncFormulaRequest")]
        InvokeSyncFormulaRequest,
        #[serde(rename = "invokeSyncUpdateFormulaRequest")]
        InvokeSyncUpdateFormulaRequest,
        #[serde(rename = "invokeExecuteGetPermissionsRequest")]
        InvokeExecuteGetPermissionsRequest,
        #[serde(rename = "validateParametersMetadataRequest")]
        ValidateParametersMetadataRequest,
    }

    impl ::std::convert::From<&Self> for PackLogRequestType {
        fn from(value: &PackLogRequestType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackLogRequestType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Unknown => f.write_str("unknown"),
                Self::ConnectionNameMetadataRequest => f.write_str("connectionNameMetadataRequest"),
                Self::ParameterAutocompleteMetadataRequest => f.write_str("parameterAutocompleteMetadataRequest"),
                Self::PostAuthSetupMetadataRequest => f.write_str("postAuthSetupMetadataRequest"),
                Self::PropertyOptionsMetadataRequest => f.write_str("propertyOptionsMetadataRequest"),
                Self::GetSyncTableSchemaMetadataRequest => f.write_str("getSyncTableSchemaMetadataRequest"),
                Self::GetDynamicSyncTableNameMetadataRequest => f.write_str("getDynamicSyncTableNameMetadataRequest"),
                Self::ListSyncTableDynamicUrlsMetadataRequest => f.write_str("listSyncTableDynamicUrlsMetadataRequest"),
                Self::SearchSyncTableDynamicUrlsMetadataRequest => f.write_str("searchSyncTableDynamicUrlsMetadataRequest"),
                Self::GetDynamicSyncTableDisplayUrlMetadataRequest => f.write_str("getDynamicSyncTableDisplayUrlMetadataRequest"),
                Self::GetIdentifiersForConnectionRequest => f.write_str("getIdentifiersForConnectionRequest"),
                Self::InvokeFormulaRequest => f.write_str("invokeFormulaRequest"),
                Self::InvokeSyncFormulaRequest => f.write_str("invokeSyncFormulaRequest"),
                Self::InvokeSyncUpdateFormulaRequest => f.write_str("invokeSyncUpdateFormulaRequest"),
                Self::InvokeExecuteGetPermissionsRequest => f.write_str("invokeExecuteGetPermissionsRequest"),
                Self::ValidateParametersMetadataRequest => f.write_str("validateParametersMetadataRequest"),
            }
        }
    }

    impl ::std::str::FromStr for PackLogRequestType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "unknown" => Ok(Self::Unknown),
                "connectionNameMetadataRequest" => Ok(Self::ConnectionNameMetadataRequest),
                "parameterAutocompleteMetadataRequest" => Ok(Self::ParameterAutocompleteMetadataRequest),
                "postAuthSetupMetadataRequest" => Ok(Self::PostAuthSetupMetadataRequest),
                "propertyOptionsMetadataRequest" => Ok(Self::PropertyOptionsMetadataRequest),
                "getSyncTableSchemaMetadataRequest" => Ok(Self::GetSyncTableSchemaMetadataRequest),
                "getDynamicSyncTableNameMetadataRequest" => Ok(Self::GetDynamicSyncTableNameMetadataRequest),
                "listSyncTableDynamicUrlsMetadataRequest" => Ok(Self::ListSyncTableDynamicUrlsMetadataRequest),
                "searchSyncTableDynamicUrlsMetadataRequest" => Ok(Self::SearchSyncTableDynamicUrlsMetadataRequest),
                "getDynamicSyncTableDisplayUrlMetadataRequest" => Ok(Self::GetDynamicSyncTableDisplayUrlMetadataRequest),
                "getIdentifiersForConnectionRequest" => Ok(Self::GetIdentifiersForConnectionRequest),
                "invokeFormulaRequest" => Ok(Self::InvokeFormulaRequest),
                "invokeSyncFormulaRequest" => Ok(Self::InvokeSyncFormulaRequest),
                "invokeSyncUpdateFormulaRequest" => Ok(Self::InvokeSyncUpdateFormulaRequest),
                "invokeExecuteGetPermissionsRequest" => Ok(Self::InvokeExecuteGetPermissionsRequest),
                "validateParametersMetadataRequest" => Ok(Self::ValidateParametersMetadataRequest),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackLogRequestType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackLogRequestType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackLogRequestType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PackLogType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "custom",
    ///    "fetcher",
    ///    "invocation",
    ///    "internal",
    ///    "auth",
    ///    "ingestionLifecycle",
    ///    "ingestionDebug"
    ///  ],
    ///  "x-schema-name": "PackLogType",
    ///  "x-tsEnumNames": [
    ///    "Custom",
    ///    "Fetcher",
    ///    "Invocation",
    ///    "Internal",
    ///    "Auth",
    ///    "IngestionLifecycle",
    ///    "IngestionDebug"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackLogType {
        #[serde(rename = "custom")]
        Custom,
        #[serde(rename = "fetcher")]
        Fetcher,
        #[serde(rename = "invocation")]
        Invocation,
        #[serde(rename = "internal")]
        Internal,
        #[serde(rename = "auth")]
        Auth,
        #[serde(rename = "ingestionLifecycle")]
        IngestionLifecycle,
        #[serde(rename = "ingestionDebug")]
        IngestionDebug,
    }

    impl ::std::convert::From<&Self> for PackLogType {
        fn from(value: &PackLogType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackLogType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Custom => f.write_str("custom"),
                Self::Fetcher => f.write_str("fetcher"),
                Self::Invocation => f.write_str("invocation"),
                Self::Internal => f.write_str("internal"),
                Self::Auth => f.write_str("auth"),
                Self::IngestionLifecycle => f.write_str("ingestionLifecycle"),
                Self::IngestionDebug => f.write_str("ingestionDebug"),
            }
        }
    }

    impl ::std::str::FromStr for PackLogType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "custom" => Ok(Self::Custom),
                "fetcher" => Ok(Self::Fetcher),
                "invocation" => Ok(Self::Invocation),
                "internal" => Ok(Self::Internal),
                "auth" => Ok(Self::Auth),
                "ingestionLifecycle" => Ok(Self::IngestionLifecycle),
                "ingestionDebug" => Ok(Self::IngestionDebug),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackLogType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackLogType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackLogType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///List of Pack logs.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "List of Pack logs.",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PackLog"
    ///      }
    ///    },
    ///    "nextPageLink": {
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/nextPageLink"
    ///        },
    ///        {
    ///          "examples": [
    ///            "https://coda.io/apis/v1/packs/1/logs?pageToken=xyz"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      ]
    ///    },
    ///    "nextPageToken": {
    ///      "$ref": "#/components/schemas/nextPageToken"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackLogsList"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackLogsList {
        pub items: ::std::vec::Vec<PackLog>,
        #[serde(rename = "nextPageLink", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_link: ::std::option::Option<NextPageLink>,
        #[serde(rename = "nextPageToken", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_token: ::std::option::Option<NextPageToken>,
    }

    impl ::std::convert::From<&PackLogsList> for PackLogsList {
        fn from(value: &PackLogsList) -> Self {
            value.clone()
        }
    }

    ///The name of the Pack.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the Pack.",
    ///  "examples": [
    ///    "Cool Geometry Formulas"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 128
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PackName(::std::string::String);
    impl ::std::ops::Deref for PackName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PackName> for ::std::string::String {
        fn from(value: PackName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PackName> for PackName {
        fn from(value: &PackName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PackName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 128usize {
                return Err("longer than 128 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PackName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackName {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackName {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PackName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///Location of including OAuth2 client credentials in a request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Location of including OAuth2 client credentials in a
    /// request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "automatic",
    ///    "body",
    ///    "header"
    ///  ],
    ///  "x-schema-name": "PackOAuth2ClientCredentialsLocation",
    ///  "x-tsEnumNames": [
    ///    "Automatic",
    ///    "Body",
    ///    "Header"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackOAuth2ClientCredentialsLocation {
        #[serde(rename = "automatic")]
        Automatic,
        #[serde(rename = "body")]
        Body,
        #[serde(rename = "header")]
        Header,
    }

    impl ::std::convert::From<&Self> for PackOAuth2ClientCredentialsLocation {
        fn from(value: &PackOAuth2ClientCredentialsLocation) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackOAuth2ClientCredentialsLocation {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Automatic => f.write_str("automatic"),
                Self::Body => f.write_str("body"),
                Self::Header => f.write_str("header"),
            }
        }
    }

    impl ::std::str::FromStr for PackOAuth2ClientCredentialsLocation {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "automatic" => Ok(Self::Automatic),
                "body" => Ok(Self::Body),
                "header" => Ok(Self::Header),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackOAuth2ClientCredentialsLocation {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackOAuth2ClientCredentialsLocation {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackOAuth2ClientCredentialsLocation {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The Pack OAuth configuration metadata.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The Pack OAuth configuration metadata.",
    ///  "type": "object",
    ///  "required": [
    ///    "authorizationUrl",
    ///    "maskedClientId",
    ///    "maskedClientSecret",
    ///    "redirectUri",
    ///    "tokenUrl"
    ///  ],
    ///  "properties": {
    ///    "authorizationUrl": {
    ///      "description": "Authorization URL of the OAuth provider.",
    ///      "type": "string"
    ///    },
    ///    "maskedClientId": {
    ///      "description": "Masked OAuth client id. If not set, empty string
    /// will be returned.",
    ///      "type": "string"
    ///    },
    ///    "maskedClientSecret": {
    ///      "description": "Masked OAuth client secret. If not set, empty
    /// string will be returned.",
    ///      "type": "string"
    ///    },
    ///    "redirectUri": {
    ///      "description": "Redirect URI of the Pack.",
    ///      "type": "string"
    ///    },
    ///    "scopes": {
    ///      "description": "Optional scopes of the OAuth client.",
    ///      "type": "string"
    ///    },
    ///    "tokenPrefix": {
    ///      "description": "Optional token prefix that's used to make the API
    /// request.",
    ///      "type": "string"
    ///    },
    ///    "tokenUrl": {
    ///      "description": "Token URL of the OAuth provider.",
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackOauthConfigMetadata"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackOauthConfigMetadata {
        ///Authorization URL of the OAuth provider.
        #[serde(rename = "authorizationUrl")]
        pub authorization_url: ::std::string::String,
        ///Masked OAuth client id. If not set, empty string will be returned.
        #[serde(rename = "maskedClientId")]
        pub masked_client_id: ::std::string::String,
        ///Masked OAuth client secret. If not set, empty string will be
        /// returned.
        #[serde(rename = "maskedClientSecret")]
        pub masked_client_secret: ::std::string::String,
        ///Redirect URI of the Pack.
        #[serde(rename = "redirectUri")]
        pub redirect_uri: ::std::string::String,
        ///Optional scopes of the OAuth client.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub scopes: ::std::option::Option<::std::string::String>,
        ///Optional token prefix that's used to make the API request.
        #[serde(rename = "tokenPrefix", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub token_prefix: ::std::option::Option<::std::string::String>,
        ///Token URL of the OAuth provider.
        #[serde(rename = "tokenUrl")]
        pub token_url: ::std::string::String,
    }

    impl ::std::convert::From<&PackOauthConfigMetadata> for PackOauthConfigMetadata {
        fn from(value: &PackOauthConfigMetadata) -> Self {
            value.clone()
        }
    }

    ///Describes restrictions that a user's organization has placed on a pack
    /// for Coda Brain ingestions
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes restrictions that a user's organization has
    /// placed on a pack for Coda Brain ingestions",
    ///  "type": "object",
    ///  "required": [
    ///    "canRequestAccess",
    ///    "hasRequestedAccess",
    ///    "requiresConfiguration"
    ///  ],
    ///  "properties": {
    ///    "allowedConfigurations": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PackConfigurationEntry"
    ///      }
    ///    },
    ///    "allowedPackIds": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "number"
    ///      }
    ///    },
    ///    "canRequestAccess": {
    ///      "type": "boolean"
    ///    },
    ///    "hasRequestedAccess": {
    ///      "type": "boolean"
    ///    },
    ///    "requiresConfiguration": {
    ///      "type": "boolean"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackOrganizationAccessForCodaBrain"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackOrganizationAccessForCodaBrain {
        #[serde(rename = "allowedConfigurations", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub allowed_configurations: ::std::vec::Vec<PackConfigurationEntry>,
        #[serde(rename = "allowedPackIds", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub allowed_pack_ids: ::std::vec::Vec<f64>,
        #[serde(rename = "canRequestAccess")]
        pub can_request_access: bool,
        #[serde(rename = "hasRequestedAccess")]
        pub has_requested_access: bool,
        #[serde(rename = "requiresConfiguration")]
        pub requires_configuration: bool,
    }

    impl ::std::convert::From<&PackOrganizationAccessForCodaBrain> for PackOrganizationAccessForCodaBrain {
        fn from(value: &PackOrganizationAccessForCodaBrain) -> Self {
            value.clone()
        }
    }

    ///Describes restrictions that a user's organization has placed on a pack
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes restrictions that a user's organization has
    /// placed on a pack",
    ///  "type": "object",
    ///  "required": [
    ///    "canRequestAccess",
    ///    "hasRequestedAccess",
    ///    "requiresConfiguration"
    ///  ],
    ///  "properties": {
    ///    "allowedConfigurations": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PackConfigurationEntry"
    ///      }
    ///    },
    ///    "allowedPackIds": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "number"
    ///      }
    ///    },
    ///    "canRequestAccess": {
    ///      "type": "boolean"
    ///    },
    ///    "hasRequestedAccess": {
    ///      "type": "boolean"
    ///    },
    ///    "incompatibleDocFolder": {
    ///      "$ref": "#/components/schemas/FolderReference"
    ///    },
    ///    "incompatibleDocOwner": {
    ///      "$ref": "#/components/schemas/UserSummary"
    ///    },
    ///    "incompatibleDocPermissions": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Permission"
    ///      }
    ///    },
    ///    "isDocOwner": {
    ///      "type": "boolean"
    ///    },
    ///    "requiresConfiguration": {
    ///      "type": "boolean"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackOrganizationAccessForDocs"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackOrganizationAccessForDocs {
        #[serde(rename = "allowedConfigurations", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub allowed_configurations: ::std::vec::Vec<PackConfigurationEntry>,
        #[serde(rename = "allowedPackIds", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub allowed_pack_ids: ::std::vec::Vec<f64>,
        #[serde(rename = "canRequestAccess")]
        pub can_request_access: bool,
        #[serde(rename = "hasRequestedAccess")]
        pub has_requested_access: bool,
        #[serde(rename = "incompatibleDocFolder", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub incompatible_doc_folder: ::std::option::Option<FolderReference>,
        #[serde(rename = "incompatibleDocOwner", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub incompatible_doc_owner: ::std::option::Option<UserSummary>,
        #[serde(rename = "incompatibleDocPermissions", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub incompatible_doc_permissions: ::std::vec::Vec<Permission>,
        #[serde(rename = "isDocOwner", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_doc_owner: ::std::option::Option<bool>,
        #[serde(rename = "requiresConfiguration")]
        pub requires_configuration: bool,
    }

    impl ::std::convert::From<&PackOrganizationAccessForDocs> for PackOrganizationAccessForDocs {
        fn from(value: &PackOrganizationAccessForDocs) -> Self {
            value.clone()
        }
    }

    ///Metadata about a Pack permission.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Metadata about a Pack permission.",
    ///  "type": "object",
    ///  "required": [
    ///    "access",
    ///    "id",
    ///    "principal"
    ///  ],
    ///  "properties": {
    ///    "access": {
    ///      "$ref": "#/components/schemas/PackAccessType"
    ///    },
    ///    "id": {
    ///      "description": "Id for the Permission",
    ///      "type": "string"
    ///    },
    ///    "principal": {
    ///      "$ref": "#/components/schemas/PackPrincipal"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackPermission"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackPermission {
        pub access: PackAccessType,
        ///Id for the Permission
        pub id: ::std::string::String,
        pub principal: PackPrincipal,
    }

    impl ::std::convert::From<&PackPermission> for PackPermission {
        fn from(value: &PackPermission) -> Self {
            value.clone()
        }
    }

    ///List of Pack permissions.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "List of Pack permissions.",
    ///  "type": "object",
    ///  "required": [
    ///    "items",
    ///    "permissionUsers"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PackPermission"
    ///      }
    ///    },
    ///    "permissionUsers": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/UserSummary"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackPermissionList"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackPermissionList {
        pub items: ::std::vec::Vec<PackPermission>,
        #[serde(rename = "permissionUsers")]
        pub permission_users: ::std::vec::Vec<UserSummary>,
    }

    impl ::std::convert::From<&PackPermissionList> for PackPermissionList {
        fn from(value: &PackPermissionList) -> Self {
            value.clone()
        }
    }

    ///Currency needed to subscribe to the Pack.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Currency needed to subscribe to the Pack.",
    ///  "type": "string",
    ///  "enum": [
    ///    "USD"
    ///  ],
    ///  "x-schema-name": "PackPlanCurrency",
    ///  "x-tsEnumNames": [
    ///    "Usd"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackPlanCurrency {
        #[serde(rename = "USD")]
        Usd,
    }

    impl ::std::convert::From<&Self> for PackPlanCurrency {
        fn from(value: &PackPlanCurrency) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackPlanCurrency {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Usd => f.write_str("USD"),
            }
        }
    }

    impl ::std::str::FromStr for PackPlanCurrency {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "USD" => Ok(Self::Usd),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackPlanCurrency {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackPlanCurrency {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackPlanCurrency {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Type of pricing used to subscribe to a Pack.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Type of pricing used to subscribe to a Pack.",
    ///  "type": "string",
    ///  "enum": [
    ///    "Free",
    ///    "MonthlyDocMaker",
    ///    "BundledWithTier"
    ///  ],
    ///  "x-schema-name": "PackPlanPricingType",
    ///  "x-tsEnumNames": [
    ///    "Free",
    ///    "MonthlyDocMaker",
    ///    "BundledWithTier"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackPlanPricingType {
        Free,
        MonthlyDocMaker,
        BundledWithTier,
    }

    impl ::std::convert::From<&Self> for PackPlanPricingType {
        fn from(value: &PackPlanPricingType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackPlanPricingType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Free => f.write_str("Free"),
                Self::MonthlyDocMaker => f.write_str("MonthlyDocMaker"),
                Self::BundledWithTier => f.write_str("BundledWithTier"),
            }
        }
    }

    impl ::std::str::FromStr for PackPlanPricingType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "Free" => Ok(Self::Free),
                "MonthlyDocMaker" => Ok(Self::MonthlyDocMaker),
                "BundledWithTier" => Ok(Self::BundledWithTier),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackPlanPricingType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackPlanPricingType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackPlanPricingType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Metadata about a Pack principal.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Metadata about a Pack principal.",
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/PackUserPrincipal"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PackWorkspacePrincipal"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PackGlobalPrincipal"
    ///    }
    ///  ],
    ///  "x-schema-name": "PackPrincipal"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum PackPrincipal {
        UserPrincipal(PackUserPrincipal),
        WorkspacePrincipal(PackWorkspacePrincipal),
        GlobalPrincipal(PackGlobalPrincipal),
    }

    impl ::std::convert::From<&Self> for PackPrincipal {
        fn from(value: &PackPrincipal) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<PackUserPrincipal> for PackPrincipal {
        fn from(value: PackUserPrincipal) -> Self {
            Self::UserPrincipal(value)
        }
    }

    impl ::std::convert::From<PackWorkspacePrincipal> for PackPrincipal {
        fn from(value: PackWorkspacePrincipal) -> Self {
            Self::WorkspacePrincipal(value)
        }
    }

    impl ::std::convert::From<PackGlobalPrincipal> for PackPrincipal {
        fn from(value: PackGlobalPrincipal) -> Self {
            Self::GlobalPrincipal(value)
        }
    }

    ///Type of Pack permissions.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Type of Pack permissions.",
    ///  "type": "string",
    ///  "enum": [
    ///    "user",
    ///    "workspace",
    ///    "worldwide"
    ///  ],
    ///  "x-schema-name": "PackPrincipalType",
    ///  "x-tsEnumNames": [
    ///    "User",
    ///    "Workspace",
    ///    "Worldwide"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackPrincipalType {
        #[serde(rename = "user")]
        User,
        #[serde(rename = "workspace")]
        Workspace,
        #[serde(rename = "worldwide")]
        Worldwide,
    }

    impl ::std::convert::From<&Self> for PackPrincipalType {
        fn from(value: &PackPrincipalType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackPrincipalType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::User => f.write_str("user"),
                Self::Workspace => f.write_str("workspace"),
                Self::Worldwide => f.write_str("worldwide"),
            }
        }
    }

    impl ::std::str::FromStr for PackPrincipalType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "user" => Ok(Self::User),
                "workspace" => Ok(Self::Workspace),
                "worldwide" => Ok(Self::Worldwide),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackPrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackPrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackPrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Rate limit in Pack settings.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Rate limit in Pack settings.",
    ///  "type": "object",
    ///  "required": [
    ///    "intervalSeconds",
    ///    "operationsPerInterval"
    ///  ],
    ///  "properties": {
    ///    "intervalSeconds": {
    ///      "description": "The rate limit interval in seconds.",
    ///      "examples": [
    ///        3600
    ///      ],
    ///      "type": "integer",
    ///      "maximum": 86400.0,
    ///      "minimum": 1.0
    ///    },
    ///    "operationsPerInterval": {
    ///      "description": "The maximum number of Pack operations that can be
    /// performed in a given interval.",
    ///      "examples": [
    ///        20
    ///      ],
    ///      "type": "integer",
    ///      "minimum": 0.0
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackRateLimit"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackRateLimit {
        ///The rate limit interval in seconds.
        #[serde(rename = "intervalSeconds")]
        pub interval_seconds: ::std::num::NonZeroU64,
        ///The maximum number of Pack operations that can be performed in a
        /// given interval.
        #[serde(rename = "operationsPerInterval")]
        pub operations_per_interval: u64,
    }

    impl ::std::convert::From<&PackRateLimit> for PackRateLimit {
        fn from(value: &PackRateLimit) -> Self {
            value.clone()
        }
    }

    ///Details about a Pack release.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Details about a Pack release.",
    ///  "type": "object",
    ///  "required": [
    ///    "createdAt",
    ///    "packId",
    ///    "packVersion",
    ///    "releaseId",
    ///    "releaseNotes",
    ///    "sdkVersion"
    ///  ],
    ///  "properties": {
    ///    "createdAt": {
    ///      "description": "Timestamp for when the release was created.",
    ///      "examples": [
    ///        "2018-04-11T00:18:57.946Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "packId": {
    ///      "description": "ID of the Packs.",
    ///      "examples": [
    ///        1003
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "packVersion": {
    ///      "description": "The semantic format of the Pack version.",
    ///      "examples": [
    ///        "1.0.3"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "releaseId": {
    ///      "description": "The release number of the Pack version if it has
    /// one.",
    ///      "examples": [
    ///        2
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "releaseNotes": {
    ///      "description": "Developer notes.",
    ///      "examples": [
    ///        "The first release."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "sdkVersion": {
    ///      "description": "What Packs SDK version was this version built on.",
    ///      "examples": [
    ///        "1.5.1"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackRelease"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackRelease {
        ///Timestamp for when the release was created.
        #[serde(rename = "createdAt")]
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        #[serde(rename = "packId")]
        pub pack_id: f64,
        ///The semantic format of the Pack version.
        #[serde(rename = "packVersion")]
        pub pack_version: ::std::string::String,
        #[serde(rename = "releaseId")]
        pub release_id: f64,
        ///Developer notes.
        #[serde(rename = "releaseNotes")]
        pub release_notes: ::std::string::String,
        ///What Packs SDK version was this version built on.
        #[serde(rename = "sdkVersion")]
        pub sdk_version: ::std::string::String,
    }

    impl ::std::convert::From<&PackRelease> for PackRelease {
        fn from(value: &PackRelease) -> Self {
            value.clone()
        }
    }

    ///List of Pack releases.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "List of Pack releases.",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PackRelease"
    ///      }
    ///    },
    ///    "nextPageLink": {
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/nextPageLink"
    ///        },
    ///        {
    ///          "examples": [
    ///            "https://coda.io/apis/v1/packs/1/releases?pageToken=xyz"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      ]
    ///    },
    ///    "nextPageToken": {
    ///      "$ref": "#/components/schemas/nextPageToken"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackReleaseList"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackReleaseList {
        pub items: ::std::vec::Vec<PackRelease>,
        #[serde(rename = "nextPageLink", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_link: ::std::option::Option<NextPageLink>,
        #[serde(rename = "nextPageToken", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_token: ::std::option::Option<NextPageToken>,
    }

    impl ::std::convert::From<&PackReleaseList> for PackReleaseList {
        fn from(value: &PackReleaseList) -> Self {
            value.clone()
        }
    }

    ///A short version of the description of the Pack.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A short version of the description of the Pack.",
    ///  "examples": [
    ///    "Calculate cool geometric formulas like surface area."
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 256
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PackShortDescription(::std::string::String);
    impl ::std::ops::Deref for PackShortDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PackShortDescription> for ::std::string::String {
        fn from(value: PackShortDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PackShortDescription> for PackShortDescription {
        fn from(value: &PackShortDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PackShortDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 256usize {
                return Err("longer than 256 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PackShortDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackShortDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackShortDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PackShortDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///`PackSource`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "web",
    ///    "cli"
    ///  ],
    ///  "x-schema-name": "PackSource",
    ///  "x-tsEnumNames": [
    ///    "Web",
    ///    "Cli"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackSource {
        #[serde(rename = "web")]
        Web,
        #[serde(rename = "cli")]
        Cli,
    }

    impl ::std::convert::From<&Self> for PackSource {
        fn from(value: &PackSource) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackSource {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Web => f.write_str("web"),
                Self::Cli => f.write_str("cli"),
            }
        }
    }

    impl ::std::str::FromStr for PackSource {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "web" => Ok(Self::Web),
                "cli" => Ok(Self::Cli),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackSource {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackSource {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackSource {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Details about a Pack's source code.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Details about a Pack's source code.",
    ///  "type": "object",
    ///  "required": [
    ///    "filename",
    ///    "url"
    ///  ],
    ///  "properties": {
    ///    "filename": {
    ///      "description": "name of the file",
    ///      "examples": [
    ///        "main.ts"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "url": {
    ///      "description": "The URL to download the source code from",
    ///      "examples": [
    ///        "https://coda-us-west-2-prod-packs.s3.us-west-2.amazonaws.com/packs/123/1/main.ts"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackSourceCode"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackSourceCode {
        ///name of the file
        pub filename: ::std::string::String,
        ///The URL to download the source code from
        pub url: ::std::string::String,
    }

    impl ::std::convert::From<&PackSourceCode> for PackSourceCode {
        fn from(value: &PackSourceCode) -> Self {
            value.clone()
        }
    }

    ///Information indicating where to upload the Pack source code, and an
    /// endpoint to mark the upload as complete.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Information indicating where to upload the Pack source
    /// code, and an endpoint to mark the upload as complete.",
    ///  "type": "object",
    ///  "required": [
    ///    "files"
    ///  ],
    ///  "properties": {
    ///    "files": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PackSourceCode"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackSourceCodeInfo"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackSourceCodeInfo {
        pub files: ::std::vec::Vec<PackSourceCode>,
    }

    impl ::std::convert::From<&PackSourceCodeInfo> for PackSourceCodeInfo {
        fn from(value: &PackSourceCodeInfo) -> Self {
            value.clone()
        }
    }

    ///Payload for noting a Pack source code upload is complete.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Payload for noting a Pack source code upload is
    /// complete.",
    ///  "type": "object",
    ///  "required": [
    ///    "codeHash",
    ///    "filename"
    ///  ],
    ///  "properties": {
    ///    "codeHash": {
    ///      "description": "A SHA-256 hash of the source code used to identify
    /// duplicate uploads.",
    ///      "examples": [
    ///        123456
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "filename": {
    ///      "examples": [
    ///        "main.ts"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackSourceCodeUploadCompleteRequest"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackSourceCodeUploadCompleteRequest {
        ///A SHA-256 hash of the source code used to identify duplicate
        /// uploads.
        #[serde(rename = "codeHash")]
        pub code_hash: ::std::string::String,
        pub filename: ::std::string::String,
    }

    impl ::std::convert::From<&PackSourceCodeUploadCompleteRequest> for PackSourceCodeUploadCompleteRequest {
        fn from(value: &PackSourceCodeUploadCompleteRequest) -> Self {
            value.clone()
        }
    }

    ///Response for noting a Pack source code upload is complete.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Response for noting a Pack source code upload is
    /// complete.",
    ///  "type": "object",
    ///  "required": [
    ///    "requestId"
    ///  ],
    ///  "properties": {
    ///    "requestId": {
    ///      "description": "An arbitrary unique identifier for this request.",
    ///      "examples": [
    ///        "abc-123-def-456"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackSourceCodeUploadCompleteResponse"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackSourceCodeUploadCompleteResponse {
        ///An arbitrary unique identifier for this request.
        #[serde(rename = "requestId")]
        pub request_id: ::std::string::String,
    }

    impl ::std::convert::From<&PackSourceCodeUploadCompleteResponse> for PackSourceCodeUploadCompleteResponse {
        fn from(value: &PackSourceCodeUploadCompleteResponse) -> Self {
            value.clone()
        }
    }

    ///Detail about why this request was rejected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why this request was rejected.",
    ///  "type": "object",
    ///  "properties": {
    ///    "validationErrors": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackSourceCodeUploadCompleteResponseCodaDetail {
        #[serde(rename = "validationErrors", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub validation_errors: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&PackSourceCodeUploadCompleteResponseCodaDetail> for PackSourceCodeUploadCompleteResponseCodaDetail {
        fn from(value: &PackSourceCodeUploadCompleteResponseCodaDetail) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for PackSourceCodeUploadCompleteResponseCodaDetail {
        fn default() -> Self {
            Self {
                validation_errors: Default::default(),
            }
        }
    }

    ///Information indicating where to upload the Pack source code, and an
    /// endpoint to mark the upload as complete.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Information indicating where to upload the Pack source
    /// code, and an endpoint to mark the upload as complete.",
    ///  "type": "object",
    ///  "required": [
    ///    "headers",
    ///    "uploadUrl",
    ///    "uploadedPathName"
    ///  ],
    ///  "properties": {
    ///    "headers": {
    ///      "description": "Key-value pairs of authorization headers to include
    /// in the upload request.",
    ///      "examples": [
    ///        "{\"header1\": \"value1\"}"
    ///      ],
    ///      "type": "object",
    ///      "additionalProperties": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "uploadUrl": {
    ///      "description": "A signed URL to be used for uploading a Pack source
    /// code.",
    ///      "examples": [
    ///        "https://coda-us-west-2-prod-packs-upload.s3-accelerate.amazonaws.com/packUploads/123/1/main.ts"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "uploadedPathName": {
    ///      "description": "An endpoint to mark the upload as complete.",
    ///      "examples": [
    ///        "/packs/123/versions/1/sourceCode/uploadComplete"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackSourceCodeUploadInfo"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackSourceCodeUploadInfo {
        ///Key-value pairs of authorization headers to include in the upload
        /// request.
        pub headers: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        ///A signed URL to be used for uploading a Pack source code.
        #[serde(rename = "uploadUrl")]
        pub upload_url: ::std::string::String,
        ///An endpoint to mark the upload as complete.
        #[serde(rename = "uploadedPathName")]
        pub uploaded_path_name: ::std::string::String,
    }

    impl ::std::convert::From<&PackSourceCodeUploadInfo> for PackSourceCodeUploadInfo {
        fn from(value: &PackSourceCodeUploadInfo) -> Self {
            value.clone()
        }
    }

    ///Visibility of a pack's source code.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Visibility of a pack's source code.",
    ///  "type": "string",
    ///  "enum": [
    ///    "private",
    ///    "shared"
    ///  ],
    ///  "x-schema-name": "PackSourceCodeVisibility",
    ///  "x-tsEnumNames": [
    ///    "Private",
    ///    "Shared"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackSourceCodeVisibility {
        #[serde(rename = "private")]
        Private,
        #[serde(rename = "shared")]
        Shared,
    }

    impl ::std::convert::From<&Self> for PackSourceCodeVisibility {
        fn from(value: &PackSourceCodeVisibility) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackSourceCodeVisibility {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Private => f.write_str("private"),
                Self::Shared => f.write_str("shared"),
            }
        }
    }

    impl ::std::str::FromStr for PackSourceCodeVisibility {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "private" => Ok(Self::Private),
                "shared" => Ok(Self::Shared),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackSourceCodeVisibility {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackSourceCodeVisibility {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackSourceCodeVisibility {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Summary of a Pack.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Summary of a Pack.",
    ///  "type": "object",
    ///  "required": [
    ///    "categories",
    ///    "description",
    ///    "id",
    ///    "name",
    ///    "shortDescription",
    ///    "workspaceId"
    ///  ],
    ///  "properties": {
    ///    "agentDescription": {
    ///      "description": "A full description for the pack as an agent.",
    ///      "examples": [
    ///        "Chat with a comprehensive tool that can calculate cool geometric
    /// formulas like surface area, volume, and other mathematical operations.
    /// This agent can help with complex calculations and provide detailed
    /// explanations."
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 8192
    ///    },
    ///    "agentImages": {
    ///      "description": "The agent images for the Pack.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PackImageFile"
    ///      }
    ///    },
    ///    "agentShortDescription": {
    ///      "description": "A short description for the pack as an agent.",
    ///      "examples": [
    ///        "Chat with a tool that can calculate cool geometric formulas like
    /// surface area."
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 256
    ///    },
    ///    "categories": {
    ///      "description": "Publishing categories associated with this Pack.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PublishingCategory"
    ///      }
    ///    },
    ///    "certified": {
    ///      "description": "Denotes if the pack is certified by Coda.",
    ///      "type": "boolean"
    ///    },
    ///    "certifiedAgent": {
    ///      "description": "Denotes if the pack is certified by Grammarly to be
    /// optimized for agent usage.",
    ///      "type": "boolean"
    ///    },
    ///    "coverUrl": {
    ///      "description": "The link to the cover photo of the Pack.",
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "description": {
    ///      "description": "The full description of the Pack.",
    ///      "examples": [
    ///        "This Pack allows users to calculate the surface area and volume
    /// of a few common 3D shapes, like cubes and pyramids."
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 8192
    ///    },
    ///    "exampleImages": {
    ///      "description": "The example images for the Pack.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PackImageFile"
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "ID of the Pack.",
    ///      "examples": [
    ///        1003
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "logoUrl": {
    ///      "description": "The link to the logo of the Pack.",
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "name": {
    ///      "description": "The name of the Pack.",
    ///      "examples": [
    ///        "Cool Geometry Formulas"
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 128
    ///    },
    ///    "privacyPolicyUrl": {
    ///      "description": "A Privacy Policy URL for the Pack.",
    ///      "type": "string",
    ///      "format": "url",
    ///      "maxLength": 512
    ///    },
    ///    "shortDescription": {
    ///      "description": "A short version of the description of the Pack.",
    ///      "examples": [
    ///        "Calculate cool geometric formulas like surface area."
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 256
    ///    },
    ///    "sourceCodeVisibility": {
    ///      "$ref": "#/components/schemas/PackSourceCodeVisibility"
    ///    },
    ///    "supportEmail": {
    ///      "description": "A contact email for the Pack.",
    ///      "examples": [
    ///        "user@email.com"
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 512
    ///    },
    ///    "termsOfServiceUrl": {
    ///      "description": "A Terms of Service URL for the Pack.",
    ///      "type": "string",
    ///      "format": "url",
    ///      "maxLength": 512
    ///    },
    ///    "workspaceId": {
    ///      "description": "The parent workspace for the Pack.",
    ///      "examples": [
    ///        "ws-asdf"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackSummary"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackSummary {
        ///A full description for the pack as an agent.
        #[serde(rename = "agentDescription", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub agent_description: ::std::option::Option<PackSummaryAgentDescription>,
        ///The agent images for the Pack.
        #[serde(rename = "agentImages", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub agent_images: ::std::vec::Vec<PackImageFile>,
        ///A short description for the pack as an agent.
        #[serde(rename = "agentShortDescription", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub agent_short_description: ::std::option::Option<PackSummaryAgentShortDescription>,
        ///Publishing categories associated with this Pack.
        pub categories: ::std::vec::Vec<PublishingCategory>,
        ///Denotes if the pack is certified by Coda.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub certified: ::std::option::Option<bool>,
        ///Denotes if the pack is certified by Grammarly to be optimized for
        /// agent usage.
        #[serde(rename = "certifiedAgent", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub certified_agent: ::std::option::Option<bool>,
        ///The link to the cover photo of the Pack.
        #[serde(rename = "coverUrl", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cover_url: ::std::option::Option<::std::string::String>,
        ///The full description of the Pack.
        pub description: PackSummaryDescription,
        ///The example images for the Pack.
        #[serde(rename = "exampleImages", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub example_images: ::std::vec::Vec<PackImageFile>,
        pub id: f64,
        ///The link to the logo of the Pack.
        #[serde(rename = "logoUrl", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub logo_url: ::std::option::Option<::std::string::String>,
        ///The name of the Pack.
        pub name: PackSummaryName,
        ///A Privacy Policy URL for the Pack.
        #[serde(rename = "privacyPolicyUrl", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub privacy_policy_url: ::std::option::Option<::std::string::String>,
        ///A short version of the description of the Pack.
        #[serde(rename = "shortDescription")]
        pub short_description: PackSummaryShortDescription,
        #[serde(rename = "sourceCodeVisibility", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub source_code_visibility: ::std::option::Option<PackSourceCodeVisibility>,
        ///A contact email for the Pack.
        #[serde(rename = "supportEmail", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub support_email: ::std::option::Option<PackSummarySupportEmail>,
        ///A Terms of Service URL for the Pack.
        #[serde(rename = "termsOfServiceUrl", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub terms_of_service_url: ::std::option::Option<::std::string::String>,
        ///The parent workspace for the Pack.
        #[serde(rename = "workspaceId")]
        pub workspace_id: ::std::string::String,
    }

    impl ::std::convert::From<&PackSummary> for PackSummary {
        fn from(value: &PackSummary) -> Self {
            value.clone()
        }
    }

    ///A full description for the pack as an agent.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A full description for the pack as an agent.",
    ///  "examples": [
    ///    "Chat with a comprehensive tool that can calculate cool geometric
    /// formulas like surface area, volume, and other mathematical operations.
    /// This agent can help with complex calculations and provide detailed
    /// explanations."
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 8192
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PackSummaryAgentDescription(::std::string::String);
    impl ::std::ops::Deref for PackSummaryAgentDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PackSummaryAgentDescription> for ::std::string::String {
        fn from(value: PackSummaryAgentDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PackSummaryAgentDescription> for PackSummaryAgentDescription {
        fn from(value: &PackSummaryAgentDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PackSummaryAgentDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 8192usize {
                return Err("longer than 8192 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PackSummaryAgentDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackSummaryAgentDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackSummaryAgentDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PackSummaryAgentDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///A short description for the pack as an agent.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A short description for the pack as an agent.",
    ///  "examples": [
    ///    "Chat with a tool that can calculate cool geometric formulas like
    /// surface area."
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 256
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PackSummaryAgentShortDescription(::std::string::String);
    impl ::std::ops::Deref for PackSummaryAgentShortDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PackSummaryAgentShortDescription> for ::std::string::String {
        fn from(value: PackSummaryAgentShortDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PackSummaryAgentShortDescription> for PackSummaryAgentShortDescription {
        fn from(value: &PackSummaryAgentShortDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PackSummaryAgentShortDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 256usize {
                return Err("longer than 256 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PackSummaryAgentShortDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackSummaryAgentShortDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackSummaryAgentShortDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PackSummaryAgentShortDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///The full description of the Pack.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The full description of the Pack.",
    ///  "examples": [
    ///    "This Pack allows users to calculate the surface area and volume of a
    /// few common 3D shapes, like cubes and pyramids."
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 8192
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PackSummaryDescription(::std::string::String);
    impl ::std::ops::Deref for PackSummaryDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PackSummaryDescription> for ::std::string::String {
        fn from(value: PackSummaryDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PackSummaryDescription> for PackSummaryDescription {
        fn from(value: &PackSummaryDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PackSummaryDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 8192usize {
                return Err("longer than 8192 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PackSummaryDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackSummaryDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackSummaryDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PackSummaryDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///List of Pack summaries.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "List of Pack summaries.",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PackSummary"
    ///      }
    ///    },
    ///    "nextPageLink": {
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/nextPageLink"
    ///        },
    ///        {
    ///          "examples": [
    ///            "https://coda.io/apis/v1/packs?pageToken=xyz"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      ]
    ///    },
    ///    "nextPageToken": {
    ///      "$ref": "#/components/schemas/nextPageToken"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackSummaryList"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackSummaryList {
        pub items: ::std::vec::Vec<PackSummary>,
        #[serde(rename = "nextPageLink", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_link: ::std::option::Option<NextPageLink>,
        #[serde(rename = "nextPageToken", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_token: ::std::option::Option<NextPageToken>,
    }

    impl ::std::convert::From<&PackSummaryList> for PackSummaryList {
        fn from(value: &PackSummaryList) -> Self {
            value.clone()
        }
    }

    ///The name of the Pack.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the Pack.",
    ///  "examples": [
    ///    "Cool Geometry Formulas"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 128
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PackSummaryName(::std::string::String);
    impl ::std::ops::Deref for PackSummaryName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PackSummaryName> for ::std::string::String {
        fn from(value: PackSummaryName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PackSummaryName> for PackSummaryName {
        fn from(value: &PackSummaryName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PackSummaryName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 128usize {
                return Err("longer than 128 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PackSummaryName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackSummaryName {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackSummaryName {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PackSummaryName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///A short version of the description of the Pack.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A short version of the description of the Pack.",
    ///  "examples": [
    ///    "Calculate cool geometric formulas like surface area."
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 256
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PackSummaryShortDescription(::std::string::String);
    impl ::std::ops::Deref for PackSummaryShortDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PackSummaryShortDescription> for ::std::string::String {
        fn from(value: PackSummaryShortDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PackSummaryShortDescription> for PackSummaryShortDescription {
        fn from(value: &PackSummaryShortDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PackSummaryShortDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 256usize {
                return Err("longer than 256 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PackSummaryShortDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackSummaryShortDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackSummaryShortDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PackSummaryShortDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///A contact email for the Pack.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A contact email for the Pack.",
    ///  "examples": [
    ///    "user@email.com"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 512
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PackSummarySupportEmail(::std::string::String);
    impl ::std::ops::Deref for PackSummarySupportEmail {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PackSummarySupportEmail> for ::std::string::String {
        fn from(value: PackSummarySupportEmail) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PackSummarySupportEmail> for PackSummarySupportEmail {
        fn from(value: &PackSummarySupportEmail) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PackSummarySupportEmail {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 512usize {
                return Err("longer than 512 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PackSummarySupportEmail {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackSummarySupportEmail {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackSummarySupportEmail {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PackSummarySupportEmail {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///A contact email for the Pack.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A contact email for the Pack.",
    ///  "examples": [
    ///    "user@email.com"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 512
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PackSupportEmail(::std::string::String);
    impl ::std::ops::Deref for PackSupportEmail {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PackSupportEmail> for ::std::string::String {
        fn from(value: PackSupportEmail) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PackSupportEmail> for PackSupportEmail {
        fn from(value: &PackSupportEmail) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PackSupportEmail {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 512usize {
                return Err("longer than 512 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PackSupportEmail {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackSupportEmail {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackSupportEmail {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PackSupportEmail {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///Credentials of a Pack connection.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Credentials of a Pack connection.",
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/PackConnectionHeaderCredentials"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PackConnectionMultiHeaderCredentials"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PackConnectionUrlParamCredentials"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PackConnectionHttpBasicCredentials"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PackConnectionCustomCredentials"
    ///    },
    ///    {
    ///      "$ref":
    /// "#/components/schemas/PackConnectionOauth2ClientCredentials"
    ///    },
    ///    {
    ///      "$ref":
    /// "#/components/schemas/PackConnectionGoogleServiceAccountCredentials"
    ///    },
    ///    {
    ///      "$ref":
    /// "#/components/schemas/PackConnectionAwsAssumeRoleCredentials"
    ///    },
    ///    {
    ///      "$ref":
    /// "#/components/schemas/PackConnectionAwsAccessKeyCredentials"
    ///    }
    ///  ],
    ///  "x-schema-name": "PackSystemConnectionCredentials"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum PackSystemConnectionCredentials {
        HeaderCredentials(PackConnectionHeaderCredentials),
        MultiHeaderCredentials(PackConnectionMultiHeaderCredentials),
        UrlParamCredentials(PackConnectionUrlParamCredentials),
        HttpBasicCredentials(PackConnectionHttpBasicCredentials),
        CustomCredentials(PackConnectionCustomCredentials),
        Oauth2ClientCredentials(PackConnectionOauth2ClientCredentials),
        GoogleServiceAccountCredentials(PackConnectionGoogleServiceAccountCredentials),
        AwsAssumeRoleCredentials(PackConnectionAwsAssumeRoleCredentials),
        AwsAccessKeyCredentials(PackConnectionAwsAccessKeyCredentials),
    }

    impl ::std::convert::From<&Self> for PackSystemConnectionCredentials {
        fn from(value: &PackSystemConnectionCredentials) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<PackConnectionHeaderCredentials> for PackSystemConnectionCredentials {
        fn from(value: PackConnectionHeaderCredentials) -> Self {
            Self::HeaderCredentials(value)
        }
    }

    impl ::std::convert::From<PackConnectionMultiHeaderCredentials> for PackSystemConnectionCredentials {
        fn from(value: PackConnectionMultiHeaderCredentials) -> Self {
            Self::MultiHeaderCredentials(value)
        }
    }

    impl ::std::convert::From<PackConnectionUrlParamCredentials> for PackSystemConnectionCredentials {
        fn from(value: PackConnectionUrlParamCredentials) -> Self {
            Self::UrlParamCredentials(value)
        }
    }

    impl ::std::convert::From<PackConnectionHttpBasicCredentials> for PackSystemConnectionCredentials {
        fn from(value: PackConnectionHttpBasicCredentials) -> Self {
            Self::HttpBasicCredentials(value)
        }
    }

    impl ::std::convert::From<PackConnectionCustomCredentials> for PackSystemConnectionCredentials {
        fn from(value: PackConnectionCustomCredentials) -> Self {
            Self::CustomCredentials(value)
        }
    }

    impl ::std::convert::From<PackConnectionOauth2ClientCredentials> for PackSystemConnectionCredentials {
        fn from(value: PackConnectionOauth2ClientCredentials) -> Self {
            Self::Oauth2ClientCredentials(value)
        }
    }

    impl ::std::convert::From<PackConnectionGoogleServiceAccountCredentials> for PackSystemConnectionCredentials {
        fn from(value: PackConnectionGoogleServiceAccountCredentials) -> Self {
            Self::GoogleServiceAccountCredentials(value)
        }
    }

    impl ::std::convert::From<PackConnectionAwsAssumeRoleCredentials> for PackSystemConnectionCredentials {
        fn from(value: PackConnectionAwsAssumeRoleCredentials) -> Self {
            Self::AwsAssumeRoleCredentials(value)
        }
    }

    impl ::std::convert::From<PackConnectionAwsAccessKeyCredentials> for PackSystemConnectionCredentials {
        fn from(value: PackConnectionAwsAccessKeyCredentials) -> Self {
            Self::AwsAccessKeyCredentials(value)
        }
    }

    ///Metadata of a Pack system connection.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Metadata of a Pack system connection.",
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/PackConnectionHeaderMetadata"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PackConnectionMultiHeaderMetadata"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PackConnectionUrlParamMetadata"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PackConnectionHttpBasicMetadata"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PackConnectionCustomMetadata"
    ///    },
    ///    {
    ///      "$ref":
    /// "#/components/schemas/PackConnectionOauth2ClientCredentialsMetadata"
    ///    },
    ///    {
    ///      "$ref":
    /// "#/components/schemas/PackConnectionGoogleServiceAccountMetadata"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PackConnectionAwsAssumeRoleMetadata"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PackConnectionAwsAccessKeyMetadata"
    ///    }
    ///  ],
    ///  "x-schema-name": "PackSystemConnectionMetadata"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum PackSystemConnectionMetadata {
        HeaderMetadata(PackConnectionHeaderMetadata),
        MultiHeaderMetadata(PackConnectionMultiHeaderMetadata),
        UrlParamMetadata(PackConnectionUrlParamMetadata),
        HttpBasicMetadata(PackConnectionHttpBasicMetadata),
        CustomMetadata(PackConnectionCustomMetadata),
        Oauth2ClientCredentialsMetadata(PackConnectionOauth2ClientCredentialsMetadata),
        GoogleServiceAccountMetadata(PackConnectionGoogleServiceAccountMetadata),
        AwsAssumeRoleMetadata(PackConnectionAwsAssumeRoleMetadata),
        AwsAccessKeyMetadata(PackConnectionAwsAccessKeyMetadata),
    }

    impl ::std::convert::From<&Self> for PackSystemConnectionMetadata {
        fn from(value: &PackSystemConnectionMetadata) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<PackConnectionHeaderMetadata> for PackSystemConnectionMetadata {
        fn from(value: PackConnectionHeaderMetadata) -> Self {
            Self::HeaderMetadata(value)
        }
    }

    impl ::std::convert::From<PackConnectionMultiHeaderMetadata> for PackSystemConnectionMetadata {
        fn from(value: PackConnectionMultiHeaderMetadata) -> Self {
            Self::MultiHeaderMetadata(value)
        }
    }

    impl ::std::convert::From<PackConnectionUrlParamMetadata> for PackSystemConnectionMetadata {
        fn from(value: PackConnectionUrlParamMetadata) -> Self {
            Self::UrlParamMetadata(value)
        }
    }

    impl ::std::convert::From<PackConnectionHttpBasicMetadata> for PackSystemConnectionMetadata {
        fn from(value: PackConnectionHttpBasicMetadata) -> Self {
            Self::HttpBasicMetadata(value)
        }
    }

    impl ::std::convert::From<PackConnectionCustomMetadata> for PackSystemConnectionMetadata {
        fn from(value: PackConnectionCustomMetadata) -> Self {
            Self::CustomMetadata(value)
        }
    }

    impl ::std::convert::From<PackConnectionOauth2ClientCredentialsMetadata> for PackSystemConnectionMetadata {
        fn from(value: PackConnectionOauth2ClientCredentialsMetadata) -> Self {
            Self::Oauth2ClientCredentialsMetadata(value)
        }
    }

    impl ::std::convert::From<PackConnectionGoogleServiceAccountMetadata> for PackSystemConnectionMetadata {
        fn from(value: PackConnectionGoogleServiceAccountMetadata) -> Self {
            Self::GoogleServiceAccountMetadata(value)
        }
    }

    impl ::std::convert::From<PackConnectionAwsAssumeRoleMetadata> for PackSystemConnectionMetadata {
        fn from(value: PackConnectionAwsAssumeRoleMetadata) -> Self {
            Self::AwsAssumeRoleMetadata(value)
        }
    }

    impl ::std::convert::From<PackConnectionAwsAccessKeyMetadata> for PackSystemConnectionMetadata {
        fn from(value: PackConnectionAwsAccessKeyMetadata) -> Self {
            Self::AwsAccessKeyMetadata(value)
        }
    }

    ///The access capabilities the current user has for this Pack.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The access capabilities the current user has for this
    /// Pack.",
    ///  "examples": [
    ///    "{\"canEdit\": false, \"canTest\": false, \"canView\": true,
    /// \"canInstall\": true}"
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "canConnectAccount",
    ///    "canEdit",
    ///    "canInstall",
    ///    "canPurchase",
    ///    "canTest",
    ///    "canView",
    ///    "requiresTrial"
    ///  ],
    ///  "properties": {
    ///    "canConnectAccount": {
    ///      "type": "boolean"
    ///    },
    ///    "canEdit": {
    ///      "type": "boolean"
    ///    },
    ///    "canInstall": {
    ///      "type": "boolean"
    ///    },
    ///    "canPurchase": {
    ///      "type": "boolean"
    ///    },
    ///    "canTest": {
    ///      "type": "boolean"
    ///    },
    ///    "canView": {
    ///      "type": "boolean"
    ///    },
    ///    "ingestionLimitSettings": {
    ///      "$ref": "#/components/schemas/IngestionLimitSettings"
    ///    },
    ///    "organization": {
    ///      "oneOf": [
    ///        {
    ///          "$ref": "#/components/schemas/PackOrganizationAccessForDocs"
    ///        },
    ///        {
    ///          "$ref":
    /// "#/components/schemas/PackOrganizationAccessForCodaBrain"
    ///        }
    ///      ]
    ///    },
    ///    "requiresTrial": {
    ///      "type": "boolean"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackUserAccess"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackUserAccess {
        #[serde(rename = "canConnectAccount")]
        pub can_connect_account: bool,
        #[serde(rename = "canEdit")]
        pub can_edit: bool,
        #[serde(rename = "canInstall")]
        pub can_install: bool,
        #[serde(rename = "canPurchase")]
        pub can_purchase: bool,
        #[serde(rename = "canTest")]
        pub can_test: bool,
        #[serde(rename = "canView")]
        pub can_view: bool,
        #[serde(rename = "ingestionLimitSettings", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub ingestion_limit_settings: ::std::option::Option<IngestionLimitSettings>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub organization: ::std::option::Option<PackUserAccessOrganization>,
        #[serde(rename = "requiresTrial")]
        pub requires_trial: bool,
    }

    impl ::std::convert::From<&PackUserAccess> for PackUserAccess {
        fn from(value: &PackUserAccess) -> Self {
            value.clone()
        }
    }

    ///`PackUserAccessOrganization`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/PackOrganizationAccessForDocs"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PackOrganizationAccessForCodaBrain"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum PackUserAccessOrganization {
        Docs(PackOrganizationAccessForDocs),
        CodaBrain(PackOrganizationAccessForCodaBrain),
    }

    impl ::std::convert::From<&Self> for PackUserAccessOrganization {
        fn from(value: &PackUserAccessOrganization) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<PackOrganizationAccessForDocs> for PackUserAccessOrganization {
        fn from(value: PackOrganizationAccessForDocs) -> Self {
            Self::Docs(value)
        }
    }

    impl ::std::convert::From<PackOrganizationAccessForCodaBrain> for PackUserAccessOrganization {
        fn from(value: PackOrganizationAccessForCodaBrain) -> Self {
            Self::CodaBrain(value)
        }
    }

    ///`PackUserPrincipal`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "email",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "email": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "user"
    ///      ],
    ///      "x-tsType": "PackPrincipalType.User"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackUserPrincipal"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackUserPrincipal {
        pub email: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: PackUserPrincipalType,
    }

    impl ::std::convert::From<&PackUserPrincipal> for PackUserPrincipal {
        fn from(value: &PackUserPrincipal) -> Self {
            value.clone()
        }
    }

    ///`PackUserPrincipalType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "user"
    ///  ],
    ///  "x-tsType": "PackPrincipalType.User"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackUserPrincipalType {
        #[serde(rename = "user")]
        User,
    }

    impl ::std::convert::From<&Self> for PackUserPrincipalType {
        fn from(value: &PackUserPrincipalType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackUserPrincipalType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::User => f.write_str("user"),
            }
        }
    }

    impl ::std::str::FromStr for PackUserPrincipalType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "user" => Ok(Self::User),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackUserPrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackUserPrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackUserPrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Details about a Pack version.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Details about a Pack version.",
    ///  "type": "object",
    ///  "required": [
    ///    "buildNotes",
    ///    "createdAt",
    ///    "creationUserLoginId",
    ///    "packId",
    ///    "packVersion"
    ///  ],
    ///  "properties": {
    ///    "buildNotes": {
    ///      "description": "Developer notes.",
    ///      "examples": [
    ///        "Adding a new formula."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "createdAt": {
    ///      "description": "Timestamp for when the version was created.",
    ///      "examples": [
    ///        "2018-04-11T00:18:57.946Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "creationUserLoginId": {
    ///      "description": "The login ID of creation user of the Pack
    /// version.",
    ///      "examples": [
    ///        "api@coda.io"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "packId": {
    ///      "description": "ID of the Pack.",
    ///      "examples": [
    ///        1003
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "packVersion": {
    ///      "description": "The semantic format of the Pack version.",
    ///      "examples": [
    ///        "1.0.3"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "releaseId": {
    ///      "description": "The release number of the Pack version if it has
    /// one.",
    ///      "examples": [
    ///        2
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "sdkVersion": {
    ///      "description": "What Packs SDK version was this version built on.",
    ///      "examples": [
    ///        "1.5.1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "source": {
    ///      "$ref": "#/components/schemas/PackSource"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackVersion"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackVersion {
        ///Developer notes.
        #[serde(rename = "buildNotes")]
        pub build_notes: ::std::string::String,
        ///Timestamp for when the version was created.
        #[serde(rename = "createdAt")]
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        ///The login ID of creation user of the Pack version.
        #[serde(rename = "creationUserLoginId")]
        pub creation_user_login_id: ::std::string::String,
        #[serde(rename = "packId")]
        pub pack_id: f64,
        ///The semantic format of the Pack version.
        #[serde(rename = "packVersion")]
        pub pack_version: ::std::string::String,
        #[serde(rename = "releaseId", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub release_id: ::std::option::Option<f64>,
        ///What Packs SDK version was this version built on.
        #[serde(rename = "sdkVersion", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sdk_version: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub source: ::std::option::Option<PackSource>,
    }

    impl ::std::convert::From<&PackVersion> for PackVersion {
        fn from(value: &PackVersion) -> Self {
            value.clone()
        }
    }

    ///Info about the diff between two Pack versions.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Info about the diff between two Pack versions.",
    ///  "type": "object",
    ///  "required": [
    ///    "findingDetails",
    ///    "findings"
    ///  ],
    ///  "properties": {
    ///    "findingDetails": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "finding",
    ///          "path"
    ///        ],
    ///        "properties": {
    ///          "finding": {
    ///            "type": "string"
    ///          },
    ///          "path": {
    ///            "type": "string"
    ///          }
    ///        },
    ///        "additionalProperties": false
    ///      }
    ///    },
    ///    "findings": {
    ///      "description": "List of changes from the previous version to the
    /// next version.",
    ///      "deprecated": true,
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackVersionDiffs"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackVersionDiffs {
        #[serde(rename = "findingDetails")]
        pub finding_details: ::std::vec::Vec<PackVersionDiffsFindingDetailsItem>,
        ///List of changes from the previous version to the next version.
        pub findings: ::std::vec::Vec<::std::string::String>,
    }

    impl ::std::convert::From<&PackVersionDiffs> for PackVersionDiffs {
        fn from(value: &PackVersionDiffs) -> Self {
            value.clone()
        }
    }

    ///`PackVersionDiffsFindingDetailsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "finding",
    ///    "path"
    ///  ],
    ///  "properties": {
    ///    "finding": {
    ///      "type": "string"
    ///    },
    ///    "path": {
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackVersionDiffsFindingDetailsItem {
        pub finding: ::std::string::String,
        pub path: ::std::string::String,
    }

    impl ::std::convert::From<&PackVersionDiffsFindingDetailsItem> for PackVersionDiffsFindingDetailsItem {
        fn from(value: &PackVersionDiffsFindingDetailsItem) -> Self {
            value.clone()
        }
    }

    ///List of Pack versions.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "List of Pack versions.",
    ///  "type": "object",
    ///  "required": [
    ///    "creationUsers",
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "creationUsers": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/UserSummary"
    ///      }
    ///    },
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PackVersion"
    ///      }
    ///    },
    ///    "nextPageLink": {
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/nextPageLink"
    ///        },
    ///        {
    ///          "examples": [
    ///            "https://coda.io/apis/v1/packs/1/versions?pageToken=xyz"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      ]
    ///    },
    ///    "nextPageToken": {
    ///      "$ref": "#/components/schemas/nextPageToken"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackVersionList"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackVersionList {
        #[serde(rename = "creationUsers")]
        pub creation_users: ::std::vec::Vec<UserSummary>,
        pub items: ::std::vec::Vec<PackVersion>,
        #[serde(rename = "nextPageLink", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_link: ::std::option::Option<NextPageLink>,
        #[serde(rename = "nextPageToken", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_token: ::std::option::Option<NextPageToken>,
    }

    impl ::std::convert::From<&PackVersionList> for PackVersionList {
        fn from(value: &PackVersionList) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "codaDetail": {
    ///      "description": "Detail about why this request was rejected.",
    ///      "type": "object",
    ///      "properties": {
    ///        "validationErrors": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/ValidationError"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    },
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackVersionUploadCompleteResponse {
        #[serde(rename = "codaDetail", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub coda_detail: ::std::option::Option<PackVersionUploadCompleteResponseCodaDetail>,
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&PackVersionUploadCompleteResponse> for PackVersionUploadCompleteResponse {
        fn from(value: &PackVersionUploadCompleteResponse) -> Self {
            value.clone()
        }
    }

    ///Detail about why this request was rejected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why this request was rejected.",
    ///  "type": "object",
    ///  "properties": {
    ///    "validationErrors": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackVersionUploadCompleteResponseCodaDetail {
        #[serde(rename = "validationErrors", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub validation_errors: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&PackVersionUploadCompleteResponseCodaDetail> for PackVersionUploadCompleteResponseCodaDetail {
        fn from(value: &PackVersionUploadCompleteResponseCodaDetail) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for PackVersionUploadCompleteResponseCodaDetail {
        fn default() -> Self {
            Self {
                validation_errors: Default::default(),
            }
        }
    }

    ///Information indicating where to upload the Pack version definition.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Information indicating where to upload the Pack version
    /// definition.",
    ///  "type": "object",
    ///  "required": [
    ///    "headers",
    ///    "uploadUrl"
    ///  ],
    ///  "properties": {
    ///    "headers": {
    ///      "description": "Key-value pairs of authorization headers to include
    /// in the upload request.",
    ///      "examples": [
    ///        "{\"header1\": \"value1\"}"
    ///      ],
    ///      "type": "object",
    ///      "additionalProperties": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "uploadUrl": {
    ///      "description": "A URL to be used for uploading a Pack version
    /// definition.",
    ///      "examples": [
    ///        "https://coda-us-west-2-prod-packs-upload.s3.amazonaws.com/packs/123/versions/1.0.0"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackVersionUploadInfo"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackVersionUploadInfo {
        ///Key-value pairs of authorization headers to include in the upload
        /// request.
        pub headers: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        ///A URL to be used for uploading a Pack version definition.
        #[serde(rename = "uploadUrl")]
        pub upload_url: ::std::string::String,
    }

    impl ::std::convert::From<&PackVersionUploadInfo> for PackVersionUploadInfo {
        fn from(value: &PackVersionUploadInfo) -> Self {
            value.clone()
        }
    }

    ///`PackWorkspacePrincipal`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "type",
    ///    "workspaceId"
    ///  ],
    ///  "properties": {
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "workspace"
    ///      ],
    ///      "x-tsType": "PackPrincipalType.Workspace"
    ///    },
    ///    "workspaceId": {
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackWorkspacePrincipal"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PackWorkspacePrincipal {
        #[serde(rename = "type")]
        pub type_: PackWorkspacePrincipalType,
        #[serde(rename = "workspaceId")]
        pub workspace_id: ::std::string::String,
    }

    impl ::std::convert::From<&PackWorkspacePrincipal> for PackWorkspacePrincipal {
        fn from(value: &PackWorkspacePrincipal) -> Self {
            value.clone()
        }
    }

    ///`PackWorkspacePrincipalType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "workspace"
    ///  ],
    ///  "x-tsType": "PackPrincipalType.Workspace"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PackWorkspacePrincipalType {
        #[serde(rename = "workspace")]
        Workspace,
    }

    impl ::std::convert::From<&Self> for PackWorkspacePrincipalType {
        fn from(value: &PackWorkspacePrincipalType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PackWorkspacePrincipalType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Workspace => f.write_str("workspace"),
            }
        }
    }

    impl ::std::str::FromStr for PackWorkspacePrincipalType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "workspace" => Ok(Self::Workspace),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PackWorkspacePrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PackWorkspacePrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PackWorkspacePrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Determines how the Packs returned are sorted.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Determines how the Packs returned are sorted.",
    ///  "type": "string",
    ///  "enum": [
    ///    "title",
    ///    "createdAt",
    ///    "updatedAt"
    ///  ],
    ///  "x-schema-name": "PacksSortBy",
    ///  "x-tsEnumNames": [
    ///    "Title",
    ///    "CreatedAt",
    ///    "UpdatedAt"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PacksSortBy {
        #[serde(rename = "title")]
        Title,
        #[serde(rename = "createdAt")]
        CreatedAt,
        #[serde(rename = "updatedAt")]
        UpdatedAt,
    }

    impl ::std::convert::From<&Self> for PacksSortBy {
        fn from(value: &PacksSortBy) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PacksSortBy {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Title => f.write_str("title"),
                Self::CreatedAt => f.write_str("createdAt"),
                Self::UpdatedAt => f.write_str("updatedAt"),
            }
        }
    }

    impl ::std::str::FromStr for PacksSortBy {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "title" => Ok(Self::Title),
                "createdAt" => Ok(Self::CreatedAt),
                "updatedAt" => Ok(Self::UpdatedAt),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PacksSortBy {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PacksSortBy {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PacksSortBy {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Metadata about a page.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Metadata about a page.",
    ///  "type": "object",
    ///  "required": [
    ///    "browserLink",
    ///    "children",
    ///    "contentType",
    ///    "href",
    ///    "id",
    ///    "isEffectivelyHidden",
    ///    "isHidden",
    ///    "name",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "authors": {
    ///      "description": "Authors of the page",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PersonValue"
    ///      }
    ///    },
    ///    "browserLink": {
    ///      "description": "Browser-friendly link to the page.",
    ///      "examples": [
    ///        "https://coda.io/d/_dAbCDeFGH/Launch-Status_sumnO"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "children": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PageReference"
    ///      }
    ///    },
    ///    "contentType": {
    ///      "$ref": "#/components/schemas/PageTypeEnum"
    ///    },
    ///    "createdAt": {
    ///      "description": "Timestamp for when the page was created.",
    ///      "examples": [
    ///        "2018-04-11T00:18:57.946Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "createdBy": {
    ///      "$ref": "#/components/schemas/PersonValue"
    ///    },
    ///    "href": {
    ///      "description": "API link to the page.",
    ///      "examples": [
    ///        "https://coda.io/apis/v1/docs/AbCDeFGH/pages/canvas-IjkLmnO"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "icon": {
    ///      "$ref": "#/components/schemas/Icon"
    ///    },
    ///    "id": {
    ///      "description": "ID of the page.",
    ///      "examples": [
    ///        "canvas-IjkLmnO"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "image": {
    ///      "$ref": "#/components/schemas/Image"
    ///    },
    ///    "isEffectivelyHidden": {
    ///      "description": "Whether the page or any of its parents is hidden in
    /// the UI.",
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "isHidden": {
    ///      "description": "Whether the page is hidden in the UI.",
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "name": {
    ///      "description": "Name of the page.",
    ///      "examples": [
    ///        "Launch Status"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "parent": {
    ///      "$ref": "#/components/schemas/PageReference"
    ///    },
    ///    "subtitle": {
    ///      "description": "Subtitle of the page.",
    ///      "examples": [
    ///        "See the status of launch-related tasks."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "description": "The type of this resource.",
    ///      "type": "string",
    ///      "enum": [
    ///        "page"
    ///      ],
    ///      "x-tsType": "Type.Page"
    ///    },
    ///    "updatedAt": {
    ///      "description": "Timestamp for when page content was last
    /// modified.",
    ///      "examples": [
    ///        "2018-04-11T00:18:57.946Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "updatedBy": {
    ///      "$ref": "#/components/schemas/PersonValue"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "Page"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct Page {
        ///Authors of the page
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub authors: ::std::vec::Vec<PersonValue>,
        ///Browser-friendly link to the page.
        #[serde(rename = "browserLink")]
        pub browser_link: ::std::string::String,
        pub children: ::std::vec::Vec<PageReference>,
        #[serde(rename = "contentType")]
        pub content_type: PageTypeEnum,
        ///Timestamp for when the page was created.
        #[serde(rename = "createdAt", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub created_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        #[serde(rename = "createdBy", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub created_by: ::std::option::Option<PersonValue>,
        ///API link to the page.
        pub href: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub icon: ::std::option::Option<Icon>,
        ///ID of the page.
        pub id: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub image: ::std::option::Option<Image>,
        ///Whether the page or any of its parents is hidden in the UI.
        #[serde(rename = "isEffectivelyHidden")]
        pub is_effectively_hidden: bool,
        ///Whether the page is hidden in the UI.
        #[serde(rename = "isHidden")]
        pub is_hidden: bool,
        ///Name of the page.
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub parent: ::std::option::Option<PageReference>,
        ///Subtitle of the page.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub subtitle: ::std::option::Option<::std::string::String>,
        ///The type of this resource.
        #[serde(rename = "type")]
        pub type_: PageType,
        ///Timestamp for when page content was last modified.
        #[serde(rename = "updatedAt", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub updated_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        #[serde(rename = "updatedBy", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub updated_by: ::std::option::Option<PersonValue>,
    }

    impl ::std::convert::From<&Page> for Page {
        fn from(value: &Page) -> Self {
            value.clone()
        }
    }

    ///List of analytics for pages within a Coda doc over a date range.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "List of analytics for pages within a Coda doc over a
    /// date range.",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PageAnalyticsItem"
    ///      }
    ///    },
    ///    "nextPageLink": {
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/nextPageLink"
    ///        },
    ///        {
    ///          "examples": [
    ///            "https://coda.io/apis/v1/analytics/docs/DOC_ID/pages?pageToken=xyz"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      ]
    ///    },
    ///    "nextPageToken": {
    ///      "$ref": "#/components/schemas/nextPageToken"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PageAnalyticsCollection"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PageAnalyticsCollection {
        pub items: ::std::vec::Vec<PageAnalyticsItem>,
        #[serde(rename = "nextPageLink", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_link: ::std::option::Option<NextPageLink>,
        #[serde(rename = "nextPageToken", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_token: ::std::option::Option<NextPageToken>,
    }

    impl ::std::convert::From<&PageAnalyticsCollection> for PageAnalyticsCollection {
        fn from(value: &PageAnalyticsCollection) -> Self {
            value.clone()
        }
    }

    ///Metadata about a page relevant to analytics.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Metadata about a page relevant to analytics.",
    ///  "required": [
    ///    "id",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "icon": {
    ///      "$ref": "#/components/schemas/Icon"
    ///    },
    ///    "id": {
    ///      "description": "ID of the page.",
    ///      "examples": [
    ///        "section-IjkLmnO"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "Name of the page.",
    ///      "examples": [
    ///        "Launch Status"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PageAnalyticsDetails"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PageAnalyticsDetails {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub icon: ::std::option::Option<Icon>,
        ///ID of the page.
        pub id: ::std::string::String,
        ///Name of the page.
        pub name: ::std::string::String,
    }

    impl ::std::convert::From<&PageAnalyticsDetails> for PageAnalyticsDetails {
        fn from(value: &PageAnalyticsDetails) -> Self {
            value.clone()
        }
    }

    ///Analytics data for a page within a Coda doc.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Analytics data for a page within a Coda doc.",
    ///  "type": "object",
    ///  "required": [
    ///    "metrics",
    ///    "page"
    ///  ],
    ///  "properties": {
    ///    "metrics": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PageAnalyticsMetrics"
    ///      }
    ///    },
    ///    "page": {
    ///      "$ref": "#/components/schemas/PageAnalyticsDetails"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PageAnalyticsItem"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PageAnalyticsItem {
        pub metrics: ::std::vec::Vec<PageAnalyticsMetrics>,
        pub page: PageAnalyticsDetails,
    }

    impl ::std::convert::From<&PageAnalyticsItem> for PageAnalyticsItem {
        fn from(value: &PageAnalyticsItem) -> Self {
            value.clone()
        }
    }

    ///Analytics metrics for a page within a Coda doc.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Analytics metrics for a page within a Coda doc.",
    ///  "type": "object",
    ///  "required": [
    ///    "averageSecondsViewed",
    ///    "date",
    ///    "medianSecondsViewed",
    ///    "sessions",
    ///    "tabs",
    ///    "users",
    ///    "views"
    ///  ],
    ///  "properties": {
    ///    "averageSecondsViewed": {
    ///      "description": "Average number of seconds that the page was viewed
    /// on the given day.",
    ///      "examples": [
    ///        42
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "date": {
    ///      "description": "Date of the analytics data.",
    ///      "examples": [
    ///        "2022-06-03"
    ///      ],
    ///      "type": "string",
    ///      "format": "date"
    ///    },
    ///    "medianSecondsViewed": {
    ///      "description": "Median number of seconds that the page was viewed
    /// on the given day.",
    ///      "examples": [
    ///        42
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "sessions": {
    ///      "description": "Number of unique browsers that viewed the page on
    /// the given day.",
    ///      "examples": [
    ///        24
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "tabs": {
    ///      "description": "Number of unique tabs that opened the doc on the
    /// given day.",
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "users": {
    ///      "description": "Number of unique Coda users that viewed the page on
    /// the given day.",
    ///      "examples": [
    ///        42
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "views": {
    ///      "description": "Number of times the page was viewed within the
    /// given day.",
    ///      "examples": [
    ///        980
    ///      ],
    ///      "type": "integer"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PageAnalyticsMetrics"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PageAnalyticsMetrics {
        ///Average number of seconds that the page was viewed on the given day.
        #[serde(rename = "averageSecondsViewed")]
        pub average_seconds_viewed: i64,
        ///Date of the analytics data.
        pub date: ::chrono::naive::NaiveDate,
        ///Median number of seconds that the page was viewed on the given day.
        #[serde(rename = "medianSecondsViewed")]
        pub median_seconds_viewed: i64,
        ///Number of unique browsers that viewed the page on the given day.
        pub sessions: i64,
        ///Number of unique tabs that opened the doc on the given day.
        pub tabs: i64,
        ///Number of unique Coda users that viewed the page on the given day.
        pub users: i64,
        ///Number of times the page was viewed within the given day.
        pub views: i64,
    }

    impl ::std::convert::From<&PageAnalyticsMetrics> for PageAnalyticsMetrics {
        fn from(value: &PageAnalyticsMetrics) -> Self {
            value.clone()
        }
    }

    ///Content for a page (canvas).
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Content for a page (canvas).",
    ///  "type": "object",
    ///  "required": [
    ///    "content",
    ///    "format"
    ///  ],
    ///  "properties": {
    ///    "content": {
    ///      "description": "The actual page content.",
    ///      "examples": [
    ///        "<p><b>This</b> is rich text</p>"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "format": {
    ///      "$ref": "#/components/schemas/PageContentFormat"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PageContent"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PageContent {
        ///The actual page content.
        pub content: ::std::string::String,
        pub format: PageContentFormat,
    }

    impl ::std::convert::From<&PageContent> for PageContent {
        fn from(value: &PageContent) -> Self {
            value.clone()
        }
    }

    ///Status of a page content export.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Status of a page content export.",
    ///  "type": "string",
    ///  "enum": [
    ///    "inProgress",
    ///    "failed",
    ///    "complete"
    ///  ],
    ///  "x-schema-name": "PageContentExportStatus",
    ///  "x-tsEnumNames": [
    ///    "InProgress",
    ///    "Failed",
    ///    "Complete"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PageContentExportStatus {
        #[serde(rename = "inProgress")]
        InProgress,
        #[serde(rename = "failed")]
        Failed,
        #[serde(rename = "complete")]
        Complete,
    }

    impl ::std::convert::From<&Self> for PageContentExportStatus {
        fn from(value: &PageContentExportStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PageContentExportStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::InProgress => f.write_str("inProgress"),
                Self::Failed => f.write_str("failed"),
                Self::Complete => f.write_str("complete"),
            }
        }
    }

    impl ::std::str::FromStr for PageContentExportStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "inProgress" => Ok(Self::InProgress),
                "failed" => Ok(Self::Failed),
                "complete" => Ok(Self::Complete),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PageContentExportStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PageContentExportStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PageContentExportStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Response when requesting the status of a page content export.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Response when requesting the status of a page content
    /// export.",
    ///  "type": "object",
    ///  "required": [
    ///    "href",
    ///    "id",
    ///    "status"
    ///  ],
    ///  "properties": {
    ///    "downloadLink": {
    ///      "description": "Once the export completes, the location where the
    /// resulting export file can be downloaded; this link typically expires
    /// after a short time.  Call this method again to get a fresh link.",
    ///      "examples": [
    ///        "https://coda.io/blobs/DOC_EXPORT_RENDERING/some-request-id"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "error": {
    ///      "description": "Message describing an error, if this export
    /// failed.",
    ///      "type": "string"
    ///    },
    ///    "href": {
    ///      "description": "The URL that reports the status of this export.",
    ///      "examples": [
    ///        "https://coda.io/apis/v1/docs/somedoc/pages/somepage/export/some-request-id"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "The identifier of this export request.",
    ///      "examples": [
    ///        "AbCDeFGH"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "description": "The status of this export.",
    ///      "examples": [
    ///        "complete"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PageContentExportStatusResponse"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PageContentExportStatusResponse {
        ///Once the export completes, the location where the resulting export
        /// file can be downloaded; this link typically expires after a short
        /// time.  Call this method again to get a fresh link.
        #[serde(rename = "downloadLink", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub download_link: ::std::option::Option<::std::string::String>,
        ///Message describing an error, if this export failed.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<::std::string::String>,
        ///The URL that reports the status of this export.
        pub href: ::std::string::String,
        ///The identifier of this export request.
        pub id: ::std::string::String,
        ///The status of this export.
        pub status: ::std::string::String,
    }

    impl ::std::convert::From<&PageContentExportStatusResponse> for PageContentExportStatusResponse {
        fn from(value: &PageContentExportStatusResponse) -> Self {
            value.clone()
        }
    }

    ///Supported content types for page (canvas) content.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Supported content types for page (canvas) content.",
    ///  "type": "string",
    ///  "enum": [
    ///    "html",
    ///    "markdown"
    ///  ],
    ///  "x-schema-name": "PageContentFormat",
    ///  "x-tsEnumNames": [
    ///    "Html",
    ///    "Markdown"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PageContentFormat {
        #[serde(rename = "html")]
        Html,
        #[serde(rename = "markdown")]
        Markdown,
    }

    impl ::std::convert::From<&Self> for PageContentFormat {
        fn from(value: &PageContentFormat) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PageContentFormat {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Html => f.write_str("html"),
                Self::Markdown => f.write_str("markdown"),
            }
        }
    }

    impl ::std::str::FromStr for PageContentFormat {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "html" => Ok(Self::Html),
                "markdown" => Ok(Self::Markdown),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PageContentFormat {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PageContentFormat {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PageContentFormat {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Mode for inserting content into an existing page.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Mode for inserting content into an existing page.",
    ///  "type": "string",
    ///  "enum": [
    ///    "append",
    ///    "replace"
    ///  ],
    ///  "x-schema-name": "PageContentInsertionMode",
    ///  "x-tsEnumNames": [
    ///    "Append",
    ///    "Replace"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PageContentInsertionMode {
        #[serde(rename = "append")]
        Append,
        #[serde(rename = "replace")]
        Replace,
    }

    impl ::std::convert::From<&Self> for PageContentInsertionMode {
        fn from(value: &PageContentInsertionMode) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PageContentInsertionMode {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Append => f.write_str("append"),
                Self::Replace => f.write_str("replace"),
            }
        }
    }

    impl ::std::str::FromStr for PageContentInsertionMode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "append" => Ok(Self::Append),
                "replace" => Ok(Self::Replace),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PageContentInsertionMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PageContentInsertionMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PageContentInsertionMode {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Supported output content formats that can be requested for getting
    /// content for an existing page.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Supported output content formats that can be requested
    /// for getting content for an existing page.",
    ///  "type": "string",
    ///  "enum": [
    ///    "html",
    ///    "markdown"
    ///  ],
    ///  "x-schema-name": "PageContentOutputFormat",
    ///  "x-tsEnumNames": [
    ///    "Html",
    ///    "Markdown"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PageContentOutputFormat {
        #[serde(rename = "html")]
        Html,
        #[serde(rename = "markdown")]
        Markdown,
    }

    impl ::std::convert::From<&Self> for PageContentOutputFormat {
        fn from(value: &PageContentOutputFormat) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PageContentOutputFormat {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Html => f.write_str("html"),
                Self::Markdown => f.write_str("markdown"),
            }
        }
    }

    impl ::std::str::FromStr for PageContentOutputFormat {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "html" => Ok(Self::Html),
                "markdown" => Ok(Self::Markdown),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PageContentOutputFormat {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PageContentOutputFormat {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PageContentOutputFormat {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Payload for updating the content of an existing page.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Payload for updating the content of an existing page.",
    ///  "type": "object",
    ///  "required": [
    ///    "canvasContent",
    ///    "insertionMode"
    ///  ],
    ///  "properties": {
    ///    "canvasContent": {
    ///      "$ref": "#/components/schemas/PageContent"
    ///    },
    ///    "insertionMode": {
    ///      "$ref": "#/components/schemas/PageContentInsertionMode"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PageContentUpdate"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PageContentUpdate {
        #[serde(rename = "canvasContent")]
        pub canvas_content: PageContent,
        #[serde(rename = "insertionMode")]
        pub insertion_mode: PageContentInsertionMode,
    }

    impl ::std::convert::From<&PageContentUpdate> for PageContentUpdate {
        fn from(value: &PageContentUpdate) -> Self {
            value.clone()
        }
    }

    ///Payload for creating a new page in a doc.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Payload for creating a new page in a doc.",
    ///  "type": "object",
    ///  "properties": {
    ///    "iconName": {
    ///      "description": "Name of the icon.",
    ///      "examples": [
    ///        "rocket"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "imageUrl": {
    ///      "description": "Url of the cover image to use.",
    ///      "examples": [
    ///        "https://example.com/image.jpg"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "Name of the page.",
    ///      "examples": [
    ///        "Launch Status"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "pageContent": {
    ///      "$ref": "#/components/schemas/PageCreateContent"
    ///    },
    ///    "parentPageId": {
    ///      "description": "The ID of this new page's parent, if creating a
    /// subpage.",
    ///      "examples": [
    ///        "canvas-tuVwxYz"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "subtitle": {
    ///      "description": "Subtitle of the page.",
    ///      "examples": [
    ///        "See the status of launch-related tasks."
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PageCreate"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PageCreate {
        ///Name of the icon.
        #[serde(rename = "iconName", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub icon_name: ::std::option::Option<::std::string::String>,
        ///Url of the cover image to use.
        #[serde(rename = "imageUrl", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub image_url: ::std::option::Option<::std::string::String>,
        ///Name of the page.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        #[serde(rename = "pageContent", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub page_content: ::std::option::Option<PageCreateContent>,
        ///The ID of this new page's parent, if creating a subpage.
        #[serde(rename = "parentPageId", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub parent_page_id: ::std::option::Option<::std::string::String>,
        ///Subtitle of the page.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub subtitle: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&PageCreate> for PageCreate {
        fn from(value: &PageCreate) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for PageCreate {
        fn default() -> Self {
            Self {
                icon_name: Default::default(),
                image_url: Default::default(),
                name: Default::default(),
                page_content: Default::default(),
                parent_page_id: Default::default(),
                subtitle: Default::default(),
            }
        }
    }

    ///Content that can be added to a page at creation time, either text (or
    /// rich text) or a URL to create a full-page embed.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Content that can be added to a page at creation time,
    /// either text (or rich text) or a URL to create a full-page embed.",
    ///  "oneOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "canvasContent",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "canvasContent": {
    ///          "$ref": "#/components/schemas/PageContent"
    ///        },
    ///        "type": {
    ///          "description": "Indicates a page containing canvas content.",
    ///          "type": "string",
    ///          "enum": [
    ///            "canvas"
    ///          ],
    ///          "x-tsType": "PageTypeEnum.Canvas"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "url"
    ///      ],
    ///      "properties": {
    ///        "renderMethod": {
    ///          "$ref": "#/components/schemas/PageEmbedRenderMethod"
    ///        },
    ///        "type": {
    ///          "description": "Indicates a page that embeds other content.",
    ///          "type": "string",
    ///          "enum": [
    ///            "embed"
    ///          ],
    ///          "x-tsType": "PageTypeEnum.Embed"
    ///        },
    ///        "url": {
    ///          "description": "The URL of the content to embed.",
    ///          "examples": [
    ///            "https://example.com"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "includeSubpages",
    ///        "mode",
    ///        "sourceDocId",
    ///        "sourcePageId",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "includeSubpages": {
    ///          "description": "Include subpages in the sync page.",
    ///          "type": "boolean"
    ///        },
    ///        "mode": {
    ///          "description": "Indicates a single-page sync page.",
    ///          "type": "string",
    ///          "enum": [
    ///            "page"
    ///          ],
    ///          "x-tsType": "SyncPageTypeEnum.Page"
    ///        },
    ///        "sourceDocId": {
    ///          "description": "The id of the document to insert as a sync
    /// page.",
    ///          "examples": [
    ///            "sHbI4uIwiK"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "sourcePageId": {
    ///          "description": "The page id to insert as a sync page.",
    ///          "examples": [
    ///            "canvas-IjkLmnO"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "type": {
    ///          "description": "Indicates a page that embeds other Coda
    /// content.",
    ///          "type": "string",
    ///          "enum": [
    ///            "syncPage"
    ///          ],
    ///          "x-tsType": "PageTypeEnum.SyncPage"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "mode",
    ///        "sourceDocId",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "mode": {
    ///          "description": "Indicates a full doc sync page.",
    ///          "type": "string",
    ///          "enum": [
    ///            "document"
    ///          ],
    ///          "x-tsType": "SyncPageTypeEnum.Document"
    ///        },
    ///        "sourceDocId": {
    ///          "description": "The id of the document to insert as a sync
    /// page.",
    ///          "examples": [
    ///            "sHbI4uIwiK"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "type": {
    ///          "description": "Indicates a page that embeds other content.",
    ///          "type": "string",
    ///          "enum": [
    ///            "syncPage"
    ///          ],
    ///          "x-tsType": "PageTypeEnum.SyncPage"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  ],
    ///  "x-schema-name": "PageCreateContent"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged, deny_unknown_fields)]
    pub enum PageCreateContent {
        Variant0 {
            #[serde(rename = "canvasContent")]
            canvas_content: PageContent,
            ///Indicates a page containing canvas content.
            #[serde(rename = "type")]
            type_: PageCreateContentVariant0Type,
        },
        Variant1 {
            #[serde(rename = "renderMethod", default, skip_serializing_if = "::std::option::Option::is_none")]
            render_method: ::std::option::Option<PageEmbedRenderMethod>,
            ///Indicates a page that embeds other content.
            #[serde(rename = "type")]
            type_: PageCreateContentVariant1Type,
            ///The URL of the content to embed.
            url: ::std::string::String,
        },
        Variant2 {
            ///Include subpages in the sync page.
            #[serde(rename = "includeSubpages")]
            include_subpages: bool,
            ///Indicates a single-page sync page.
            mode: PageCreateContentVariant2Mode,
            ///The id of the document to insert as a sync page.
            #[serde(rename = "sourceDocId")]
            source_doc_id: ::std::string::String,
            ///The page id to insert as a sync page.
            #[serde(rename = "sourcePageId")]
            source_page_id: ::std::string::String,
            ///Indicates a page that embeds other Coda content.
            #[serde(rename = "type")]
            type_: PageCreateContentVariant2Type,
        },
        Variant3 {
            ///Indicates a full doc sync page.
            mode: PageCreateContentVariant3Mode,
            ///The id of the document to insert as a sync page.
            #[serde(rename = "sourceDocId")]
            source_doc_id: ::std::string::String,
            ///Indicates a page that embeds other content.
            #[serde(rename = "type")]
            type_: PageCreateContentVariant3Type,
        },
    }

    impl ::std::convert::From<&Self> for PageCreateContent {
        fn from(value: &PageCreateContent) -> Self {
            value.clone()
        }
    }

    ///Indicates a page containing canvas content.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates a page containing canvas content.",
    ///  "type": "string",
    ///  "enum": [
    ///    "canvas"
    ///  ],
    ///  "x-tsType": "PageTypeEnum.Canvas"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PageCreateContentVariant0Type {
        #[serde(rename = "canvas")]
        Canvas,
    }

    impl ::std::convert::From<&Self> for PageCreateContentVariant0Type {
        fn from(value: &PageCreateContentVariant0Type) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PageCreateContentVariant0Type {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Canvas => f.write_str("canvas"),
            }
        }
    }

    impl ::std::str::FromStr for PageCreateContentVariant0Type {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "canvas" => Ok(Self::Canvas),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PageCreateContentVariant0Type {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PageCreateContentVariant0Type {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PageCreateContentVariant0Type {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Indicates a page that embeds other content.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates a page that embeds other content.",
    ///  "type": "string",
    ///  "enum": [
    ///    "embed"
    ///  ],
    ///  "x-tsType": "PageTypeEnum.Embed"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PageCreateContentVariant1Type {
        #[serde(rename = "embed")]
        Embed,
    }

    impl ::std::convert::From<&Self> for PageCreateContentVariant1Type {
        fn from(value: &PageCreateContentVariant1Type) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PageCreateContentVariant1Type {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Embed => f.write_str("embed"),
            }
        }
    }

    impl ::std::str::FromStr for PageCreateContentVariant1Type {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "embed" => Ok(Self::Embed),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PageCreateContentVariant1Type {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PageCreateContentVariant1Type {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PageCreateContentVariant1Type {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Indicates a single-page sync page.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates a single-page sync page.",
    ///  "type": "string",
    ///  "enum": [
    ///    "page"
    ///  ],
    ///  "x-tsType": "SyncPageTypeEnum.Page"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PageCreateContentVariant2Mode {
        #[serde(rename = "page")]
        Page,
    }

    impl ::std::convert::From<&Self> for PageCreateContentVariant2Mode {
        fn from(value: &PageCreateContentVariant2Mode) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PageCreateContentVariant2Mode {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Page => f.write_str("page"),
            }
        }
    }

    impl ::std::str::FromStr for PageCreateContentVariant2Mode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "page" => Ok(Self::Page),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PageCreateContentVariant2Mode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PageCreateContentVariant2Mode {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PageCreateContentVariant2Mode {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Indicates a page that embeds other Coda content.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates a page that embeds other Coda content.",
    ///  "type": "string",
    ///  "enum": [
    ///    "syncPage"
    ///  ],
    ///  "x-tsType": "PageTypeEnum.SyncPage"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PageCreateContentVariant2Type {
        #[serde(rename = "syncPage")]
        SyncPage,
    }

    impl ::std::convert::From<&Self> for PageCreateContentVariant2Type {
        fn from(value: &PageCreateContentVariant2Type) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PageCreateContentVariant2Type {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SyncPage => f.write_str("syncPage"),
            }
        }
    }

    impl ::std::str::FromStr for PageCreateContentVariant2Type {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "syncPage" => Ok(Self::SyncPage),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PageCreateContentVariant2Type {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PageCreateContentVariant2Type {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PageCreateContentVariant2Type {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Indicates a full doc sync page.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates a full doc sync page.",
    ///  "type": "string",
    ///  "enum": [
    ///    "document"
    ///  ],
    ///  "x-tsType": "SyncPageTypeEnum.Document"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PageCreateContentVariant3Mode {
        #[serde(rename = "document")]
        Document,
    }

    impl ::std::convert::From<&Self> for PageCreateContentVariant3Mode {
        fn from(value: &PageCreateContentVariant3Mode) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PageCreateContentVariant3Mode {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Document => f.write_str("document"),
            }
        }
    }

    impl ::std::str::FromStr for PageCreateContentVariant3Mode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "document" => Ok(Self::Document),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PageCreateContentVariant3Mode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PageCreateContentVariant3Mode {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PageCreateContentVariant3Mode {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Indicates a page that embeds other content.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates a page that embeds other content.",
    ///  "type": "string",
    ///  "enum": [
    ///    "syncPage"
    ///  ],
    ///  "x-tsType": "PageTypeEnum.SyncPage"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PageCreateContentVariant3Type {
        #[serde(rename = "syncPage")]
        SyncPage,
    }

    impl ::std::convert::From<&Self> for PageCreateContentVariant3Type {
        fn from(value: &PageCreateContentVariant3Type) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PageCreateContentVariant3Type {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SyncPage => f.write_str("syncPage"),
            }
        }
    }

    impl ::std::str::FromStr for PageCreateContentVariant3Type {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "syncPage" => Ok(Self::SyncPage),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PageCreateContentVariant3Type {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PageCreateContentVariant3Type {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PageCreateContentVariant3Type {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PageCreateResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The result of a page creation.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/DocumentMutateResponse"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "id"
    ///      ],
    ///      "properties": {
    ///        "id": {
    ///          "description": "ID of the created page.",
    ///          "examples": [
    ///            "canvas-tuVwxYz"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  ],
    ///  "x-schema-name": "PageCreateResult"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(deny_unknown_fields)]
    pub enum PageCreateResult {}
    impl ::std::convert::From<&Self> for PageCreateResult {
        fn from(value: &PageCreateResult) -> Self {
            value.clone()
        }
    }

    ///`PageDeleteResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The result of a page deletion.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/DocumentMutateResponse"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "id"
    ///      ],
    ///      "properties": {
    ///        "id": {
    ///          "description": "ID of the page to be deleted.",
    ///          "examples": [
    ///            "canvas-tuVwxYz"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  ],
    ///  "x-schema-name": "PageDeleteResult"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(deny_unknown_fields)]
    pub enum PageDeleteResult {}
    impl ::std::convert::From<&Self> for PageDeleteResult {
        fn from(value: &PageDeleteResult) -> Self {
            value.clone()
        }
    }

    ///Render mode for a page using the Embed page type.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Render mode for a page using the Embed page type.",
    ///  "type": "string",
    ///  "enum": [
    ///    "compatibility",
    ///    "standard"
    ///  ],
    ///  "x-schema-name": "PageEmbedRenderMethod",
    ///  "x-tsEnumNames": [
    ///    "Compatibility",
    ///    "Standard"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PageEmbedRenderMethod {
        #[serde(rename = "compatibility")]
        Compatibility,
        #[serde(rename = "standard")]
        Standard,
    }

    impl ::std::convert::From<&Self> for PageEmbedRenderMethod {
        fn from(value: &PageEmbedRenderMethod) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PageEmbedRenderMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Compatibility => f.write_str("compatibility"),
                Self::Standard => f.write_str("standard"),
            }
        }
    }

    impl ::std::str::FromStr for PageEmbedRenderMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "compatibility" => Ok(Self::Compatibility),
                "standard" => Ok(Self::Standard),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PageEmbedRenderMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PageEmbedRenderMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PageEmbedRenderMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///List of pages.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "List of pages.",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "href": {
    ///      "description": "API link to these results",
    ///      "examples": [
    ///        "https://coda.io/apis/v1/docs/AbCDeFGH/pages?limit=20"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Page"
    ///      }
    ///    },
    ///    "nextPageLink": {
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/nextPageLink"
    ///        },
    ///        {
    ///          "examples": [
    ///            "https://coda.io/apis/v1/docs/AbCDeFGH/pages?pageToken=eyJsaW1pd"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      ]
    ///    },
    ///    "nextPageToken": {
    ///      "$ref": "#/components/schemas/nextPageToken"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PageList"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PageList {
        ///API link to these results
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub href: ::std::option::Option<::std::string::String>,
        pub items: ::std::vec::Vec<Page>,
        #[serde(rename = "nextPageLink", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_link: ::std::option::Option<NextPageLink>,
        #[serde(rename = "nextPageToken", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_token: ::std::option::Option<NextPageToken>,
    }

    impl ::std::convert::From<&PageList> for PageList {
        fn from(value: &PageList) -> Self {
            value.clone()
        }
    }

    ///Reference to a page.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Reference to a page.",
    ///  "type": "object",
    ///  "required": [
    ///    "browserLink",
    ///    "href",
    ///    "id",
    ///    "name",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "browserLink": {
    ///      "description": "Browser-friendly link to the page.",
    ///      "examples": [
    ///        "https://coda.io/d/_dAbCDeFGH/Launch-Status_sumnO"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "href": {
    ///      "description": "API link to the page.",
    ///      "examples": [
    ///        "https://coda.io/apis/v1/docs/AbCDeFGH/pages/canvas-IjkLmnO"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "id": {
    ///      "description": "ID of the page.",
    ///      "examples": [
    ///        "canvas-IjkLmnO"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "Name of the page.",
    ///      "examples": [
    ///        "Launch Status"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "description": "The type of this resource.",
    ///      "type": "string",
    ///      "enum": [
    ///        "page"
    ///      ],
    ///      "x-tsType": "Type.Page"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PageReference"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PageReference {
        ///Browser-friendly link to the page.
        #[serde(rename = "browserLink")]
        pub browser_link: ::std::string::String,
        ///API link to the page.
        pub href: ::std::string::String,
        ///ID of the page.
        pub id: ::std::string::String,
        ///Name of the page.
        pub name: ::std::string::String,
        ///The type of this resource.
        #[serde(rename = "type")]
        pub type_: PageReferenceType,
    }

    impl ::std::convert::From<&PageReference> for PageReference {
        fn from(value: &PageReference) -> Self {
            value.clone()
        }
    }

    ///The type of this resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of this resource.",
    ///  "type": "string",
    ///  "enum": [
    ///    "page"
    ///  ],
    ///  "x-tsType": "Type.Page"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PageReferenceType {
        #[serde(rename = "page")]
        Page,
    }

    impl ::std::convert::From<&Self> for PageReferenceType {
        fn from(value: &PageReferenceType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PageReferenceType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Page => f.write_str("page"),
            }
        }
    }

    impl ::std::str::FromStr for PageReferenceType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "page" => Ok(Self::Page),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PageReferenceType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PageReferenceType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PageReferenceType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The type of this resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of this resource.",
    ///  "type": "string",
    ///  "enum": [
    ///    "page"
    ///  ],
    ///  "x-tsType": "Type.Page"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PageType {
        #[serde(rename = "page")]
        Page,
    }

    impl ::std::convert::From<&Self> for PageType {
        fn from(value: &PageType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PageType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Page => f.write_str("page"),
            }
        }
    }

    impl ::std::str::FromStr for PageType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "page" => Ok(Self::Page),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PageType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PageType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PageType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The type of a page in a doc.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of a page in a doc.",
    ///  "type": "string",
    ///  "enum": [
    ///    "canvas",
    ///    "embed",
    ///    "syncPage"
    ///  ],
    ///  "x-schema-name": "PageTypeEnum",
    ///  "x-tsEnumNames": [
    ///    "Canvas",
    ///    "Embed",
    ///    "SyncPage"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PageTypeEnum {
        #[serde(rename = "canvas")]
        Canvas,
        #[serde(rename = "embed")]
        Embed,
        #[serde(rename = "syncPage")]
        SyncPage,
    }

    impl ::std::convert::From<&Self> for PageTypeEnum {
        fn from(value: &PageTypeEnum) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PageTypeEnum {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Canvas => f.write_str("canvas"),
                Self::Embed => f.write_str("embed"),
                Self::SyncPage => f.write_str("syncPage"),
            }
        }
    }

    impl ::std::str::FromStr for PageTypeEnum {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "canvas" => Ok(Self::Canvas),
                "embed" => Ok(Self::Embed),
                "syncPage" => Ok(Self::SyncPage),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PageTypeEnum {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PageTypeEnum {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PageTypeEnum {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Payload for updating a page.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Payload for updating a page.",
    ///  "type": "object",
    ///  "properties": {
    ///    "contentUpdate": {
    ///      "allOf": [
    ///        {
    ///          "description": "Content with which to update an existing
    /// page.",
    ///          "type": "object",
    ///          "additionalProperties": false
    ///        },
    ///        {
    ///          "$ref": "#/components/schemas/PageContentUpdate"
    ///        }
    ///      ]
    ///    },
    ///    "iconName": {
    ///      "description": "Name of the icon.",
    ///      "examples": [
    ///        "rocket"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "imageUrl": {
    ///      "description": "Url of the cover image to use.",
    ///      "examples": [
    ///        "https://example.com/image.jpg"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "isHidden": {
    ///      "description": "Whether the page is hidden or not. Note that for
    /// pages that cannot be hidden, like the sole top-level page in a doc, this
    /// will be ignored.",
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "name": {
    ///      "description": "Name of the page.",
    ///      "examples": [
    ///        "Launch Status"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "subtitle": {
    ///      "description": "Subtitle of the page.",
    ///      "examples": [
    ///        "See the status of launch-related tasks."
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PageUpdate"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PageUpdate {
        #[serde(rename = "contentUpdate", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub content_update: ::std::option::Option<PageUpdateContentUpdate>,
        ///Name of the icon.
        #[serde(rename = "iconName", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub icon_name: ::std::option::Option<::std::string::String>,
        ///Url of the cover image to use.
        #[serde(rename = "imageUrl", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub image_url: ::std::option::Option<::std::string::String>,
        ///Whether the page is hidden or not. Note that for pages that cannot
        /// be hidden, like the sole top-level page in a doc, this will be
        /// ignored.
        #[serde(rename = "isHidden", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_hidden: ::std::option::Option<bool>,
        ///Name of the page.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        ///Subtitle of the page.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub subtitle: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&PageUpdate> for PageUpdate {
        fn from(value: &PageUpdate) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for PageUpdate {
        fn default() -> Self {
            Self {
                content_update: Default::default(),
                icon_name: Default::default(),
                image_url: Default::default(),
                is_hidden: Default::default(),
                name: Default::default(),
                subtitle: Default::default(),
            }
        }
    }

    ///`PageUpdateContentUpdate`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "description": "Content with which to update an existing page.",
    ///      "type": "object",
    ///      "additionalProperties": false
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PageContentUpdate"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(deny_unknown_fields)]
    pub enum PageUpdateContentUpdate {}
    impl ::std::convert::From<&Self> for PageUpdateContentUpdate {
        fn from(value: &PageUpdateContentUpdate) -> Self {
            value.clone()
        }
    }

    ///`PageUpdateResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The result of a page update.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/DocumentMutateResponse"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "id"
    ///      ],
    ///      "properties": {
    ///        "id": {
    ///          "description": "ID of the updated page.",
    ///          "examples": [
    ///            "canvas-tuVwxYz"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  ],
    ///  "x-schema-name": "PageUpdateResult"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(deny_unknown_fields)]
    pub enum PageUpdateResult {}
    impl ::std::convert::From<&Self> for PageUpdateResult {
        fn from(value: &PageUpdateResult) -> Self {
            value.clone()
        }
    }

    ///Workspace feature set excluding free.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Workspace feature set excluding free.",
    ///  "type": "string",
    ///  "enum": [
    ///    "Pro",
    ///    "Team",
    ///    "Enterprise"
    ///  ],
    ///  "x-schema-name": "PaidFeatureSet",
    ///  "x-tsEnumNames": [
    ///    "Pro",
    ///    "Team",
    ///    "Enterprise"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PaidFeatureSet {
        Pro,
        Team,
        Enterprise,
    }

    impl ::std::convert::From<&Self> for PaidFeatureSet {
        fn from(value: &PaidFeatureSet) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PaidFeatureSet {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Pro => f.write_str("Pro"),
                Self::Team => f.write_str("Team"),
                Self::Enterprise => f.write_str("Enterprise"),
            }
        }
    }

    impl ::std::str::FromStr for PaidFeatureSet {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "Pro" => Ok(Self::Pro),
                "Team" => Ok(Self::Team),
                "Enterprise" => Ok(Self::Enterprise),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PaidFeatureSet {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PaidFeatureSet {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PaidFeatureSet {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Setting for a specific parameter
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Setting for a specific parameter",
    ///  "type": "object",
    ///  "required": [
    ///    "allowed",
    ///    "default"
    ///  ],
    ///  "properties": {
    ///    "allowed": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "default": {
    ///      "description": "Default value for the parameter",
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "ParameterSetting"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ParameterSetting {
        pub allowed: ::std::vec::Vec<::std::string::String>,
        ///Default value for the parameter
        pub default: ::std::string::String,
    }

    impl ::std::convert::From<&ParameterSetting> for ParameterSetting {
        fn from(value: &ParameterSetting) -> Self {
            value.clone()
        }
    }

    ///The request to patch pack system connection credentials.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The request to patch pack system connection
    /// credentials.",
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/PackConnectionHeaderPatch"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PackConnectionMultiHeaderPatch"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PackConnectionUrlParamPatch"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PackConnectionHttpBasicPatch"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PackConnectionCustomPatch"
    ///    },
    ///    {
    ///      "$ref":
    /// "#/components/schemas/PackConnectionOauth2ClientCredentialsPatch"
    ///    },
    ///    {
    ///      "$ref":
    /// "#/components/schemas/PackConnectionGoogleServiceAccountPatch"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PackConnectionAwsAssumeRolePatch"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PackConnectionAwsAccessKeyPatch"
    ///    }
    ///  ],
    ///  "x-schema-name": "PatchPackSystemConnectionRequest"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum PatchPackSystemConnectionRequest {
        HeaderPatch(PackConnectionHeaderPatch),
        MultiHeaderPatch(PackConnectionMultiHeaderPatch),
        UrlParamPatch(PackConnectionUrlParamPatch),
        HttpBasicPatch(PackConnectionHttpBasicPatch),
        CustomPatch(PackConnectionCustomPatch),
        Oauth2ClientCredentialsPatch(PackConnectionOauth2ClientCredentialsPatch),
        GoogleServiceAccountPatch(PackConnectionGoogleServiceAccountPatch),
        AwsAssumeRolePatch(PackConnectionAwsAssumeRolePatch),
        AwsAccessKeyPatch(PackConnectionAwsAccessKeyPatch),
    }

    impl ::std::convert::From<&Self> for PatchPackSystemConnectionRequest {
        fn from(value: &PatchPackSystemConnectionRequest) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<PackConnectionHeaderPatch> for PatchPackSystemConnectionRequest {
        fn from(value: PackConnectionHeaderPatch) -> Self {
            Self::HeaderPatch(value)
        }
    }

    impl ::std::convert::From<PackConnectionMultiHeaderPatch> for PatchPackSystemConnectionRequest {
        fn from(value: PackConnectionMultiHeaderPatch) -> Self {
            Self::MultiHeaderPatch(value)
        }
    }

    impl ::std::convert::From<PackConnectionUrlParamPatch> for PatchPackSystemConnectionRequest {
        fn from(value: PackConnectionUrlParamPatch) -> Self {
            Self::UrlParamPatch(value)
        }
    }

    impl ::std::convert::From<PackConnectionHttpBasicPatch> for PatchPackSystemConnectionRequest {
        fn from(value: PackConnectionHttpBasicPatch) -> Self {
            Self::HttpBasicPatch(value)
        }
    }

    impl ::std::convert::From<PackConnectionCustomPatch> for PatchPackSystemConnectionRequest {
        fn from(value: PackConnectionCustomPatch) -> Self {
            Self::CustomPatch(value)
        }
    }

    impl ::std::convert::From<PackConnectionOauth2ClientCredentialsPatch> for PatchPackSystemConnectionRequest {
        fn from(value: PackConnectionOauth2ClientCredentialsPatch) -> Self {
            Self::Oauth2ClientCredentialsPatch(value)
        }
    }

    impl ::std::convert::From<PackConnectionGoogleServiceAccountPatch> for PatchPackSystemConnectionRequest {
        fn from(value: PackConnectionGoogleServiceAccountPatch) -> Self {
            Self::GoogleServiceAccountPatch(value)
        }
    }

    impl ::std::convert::From<PackConnectionAwsAssumeRolePatch> for PatchPackSystemConnectionRequest {
        fn from(value: PackConnectionAwsAssumeRolePatch) -> Self {
            Self::AwsAssumeRolePatch(value)
        }
    }

    impl ::std::convert::From<PackConnectionAwsAccessKeyPatch> for PatchPackSystemConnectionRequest {
        fn from(value: PackConnectionAwsAccessKeyPatch) -> Self {
            Self::AwsAccessKeyPatch(value)
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "codaDetail": {
    ///      "description": "Detail about why this request was rejected.",
    ///      "type": "object",
    ///      "properties": {
    ///        "validationErrors": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/ValidationError"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    },
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PatchPackSystemConnectionResponse {
        #[serde(rename = "codaDetail", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub coda_detail: ::std::option::Option<PatchPackSystemConnectionResponseCodaDetail>,
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&PatchPackSystemConnectionResponse> for PatchPackSystemConnectionResponse {
        fn from(value: &PatchPackSystemConnectionResponse) -> Self {
            value.clone()
        }
    }

    ///Detail about why this request was rejected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why this request was rejected.",
    ///  "type": "object",
    ///  "properties": {
    ///    "validationErrors": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PatchPackSystemConnectionResponseCodaDetail {
        #[serde(rename = "validationErrors", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub validation_errors: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&PatchPackSystemConnectionResponseCodaDetail> for PatchPackSystemConnectionResponseCodaDetail {
        fn from(value: &PatchPackSystemConnectionResponseCodaDetail) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for PatchPackSystemConnectionResponseCodaDetail {
        fn default() -> Self {
            Self {
                validation_errors: Default::default(),
            }
        }
    }

    ///A specific permission granted to a principal.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A specific permission granted to a principal.",
    ///  "type": "object",
    ///  "required": [
    ///    "access",
    ///    "id",
    ///    "principal"
    ///  ],
    ///  "properties": {
    ///    "access": {
    ///      "$ref": "#/components/schemas/AccessType"
    ///    },
    ///    "id": {
    ///      "description": "Id for the Permission",
    ///      "type": "string"
    ///    },
    ///    "principal": {
    ///      "$ref": "#/components/schemas/Principal"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "Permission"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct Permission {
        pub access: AccessType,
        ///Id for the Permission
        pub id: ::std::string::String,
        pub principal: Principal,
    }

    impl ::std::convert::From<&Permission> for Permission {
        fn from(value: &Permission) -> Self {
            value.clone()
        }
    }

    ///`PersonValue`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A named reference to a person, where the person is
    /// identified by email address.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/LinkedDataObject"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "@type",
    ///        "name"
    ///      ],
    ///      "properties": {
    ///        "@type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "Person"
    ///          ],
    ///          "x-tsType": "LinkedDataType.Person"
    ///        },
    ///        "email": {
    ///          "description": "The email address of the person.",
    ///          "examples": [
    ///            "alice@atkins.com"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "name": {
    ///          "description": "The full name of the person.",
    ///          "examples": [
    ///            "Alice Atkins"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  ],
    ///  "x-schema-name": "PersonValue"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(deny_unknown_fields)]
    pub enum PersonValue {}
    impl ::std::convert::From<&Self> for PersonValue {
        fn from(value: &PersonValue) -> Self {
            value.clone()
        }
    }

    ///Metadata about a principal.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Metadata about a principal.",
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/EmailPrincipal"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/GroupPrincipal"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/DomainPrincipal"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/WorkspacePrincipal"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/AnyonePrincipal"
    ///    }
    ///  ],
    ///  "x-schema-name": "Principal"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum Principal {
        EmailPrincipal(EmailPrincipal),
        GroupPrincipal(GroupPrincipal),
        DomainPrincipal(DomainPrincipal),
        WorkspacePrincipal(WorkspacePrincipal),
        AnyonePrincipal(AnyonePrincipal),
    }

    impl ::std::convert::From<&Self> for Principal {
        fn from(value: &Principal) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<EmailPrincipal> for Principal {
        fn from(value: EmailPrincipal) -> Self {
            Self::EmailPrincipal(value)
        }
    }

    impl ::std::convert::From<GroupPrincipal> for Principal {
        fn from(value: GroupPrincipal) -> Self {
            Self::GroupPrincipal(value)
        }
    }

    impl ::std::convert::From<DomainPrincipal> for Principal {
        fn from(value: DomainPrincipal) -> Self {
            Self::DomainPrincipal(value)
        }
    }

    impl ::std::convert::From<WorkspacePrincipal> for Principal {
        fn from(value: WorkspacePrincipal) -> Self {
            Self::WorkspacePrincipal(value)
        }
    }

    impl ::std::convert::From<AnyonePrincipal> for Principal {
        fn from(value: AnyonePrincipal) -> Self {
            Self::AnyonePrincipal(value)
        }
    }

    ///Type of principal.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Type of principal.",
    ///  "type": "string",
    ///  "enum": [
    ///    "email",
    ///    "group",
    ///    "domain",
    ///    "workspace",
    ///    "anyone"
    ///  ],
    ///  "x-schema-name": "PrincipalType",
    ///  "x-tsEnumNames": [
    ///    "Email",
    ///    "Group",
    ///    "Domain",
    ///    "Workspace",
    ///    "Anyone"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum PrincipalType {
        #[serde(rename = "email")]
        Email,
        #[serde(rename = "group")]
        Group,
        #[serde(rename = "domain")]
        Domain,
        #[serde(rename = "workspace")]
        Workspace,
        #[serde(rename = "anyone")]
        Anyone,
    }

    impl ::std::convert::From<&Self> for PrincipalType {
        fn from(value: &PrincipalType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PrincipalType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Email => f.write_str("email"),
                Self::Group => f.write_str("group"),
                Self::Domain => f.write_str("domain"),
                Self::Workspace => f.write_str("workspace"),
                Self::Anyone => f.write_str("anyone"),
            }
        }
    }

    impl ::std::str::FromStr for PrincipalType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "email" => Ok(Self::Email),
                "group" => Ok(Self::Group),
                "domain" => Ok(Self::Domain),
                "workspace" => Ok(Self::Workspace),
                "anyone" => Ok(Self::Anyone),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PublishDocResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&PublishDocResponse> for PublishDocResponse {
        fn from(value: &PublishDocResponse) -> Self {
            value.clone()
        }
    }

    ///`PublishResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The result of publishing a doc.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/DocumentMutateResponse"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "additionalProperties": false
    ///    }
    ///  ],
    ///  "x-schema-name": "PublishResult"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(deny_unknown_fields)]
    pub enum PublishResult {}
    impl ::std::convert::From<&Self> for PublishResult {
        fn from(value: &PublishResult) -> Self {
            value.clone()
        }
    }

    ///Info about a publishing category
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Info about a publishing category",
    ///  "type": "object",
    ///  "required": [
    ///    "categoryId",
    ///    "categoryName"
    ///  ],
    ///  "properties": {
    ///    "categoryId": {
    ///      "description": "The ID for this category.",
    ///      "examples": [
    ///        "aBCdEFg"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "categoryName": {
    ///      "description": "The name of the category.",
    ///      "examples": [
    ///        "Project management"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "categorySlug": {
    ///      "description": "The URL identifier of the category.",
    ///      "examples": [
    ///        "project-management"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PublishingCategory"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PublishingCategory {
        ///The ID for this category.
        #[serde(rename = "categoryId")]
        pub category_id: ::std::string::String,
        ///The name of the category.
        #[serde(rename = "categoryName")]
        pub category_name: ::std::string::String,
        ///The URL identifier of the category.
        #[serde(rename = "categorySlug", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub category_slug: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&PublishingCategory> for PublishingCategory {
        fn from(value: &PublishingCategory) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PushButtonResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&PushButtonResponse> for PushButtonResponse {
        fn from(value: &PushButtonResponse) -> Self {
            value.clone()
        }
    }

    ///`PushButtonResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The result of a push button.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/DocumentMutateResponse"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "columnId",
    ///        "rowId"
    ///      ],
    ///      "properties": {
    ///        "columnId": {
    ///          "description": "ID of the column where the button exists.",
    ///          "examples": [
    ///            "i-tuVwxYz"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "rowId": {
    ///          "description": "ID of the row where the button exists.",
    ///          "examples": [
    ///            "i-tuVwxYz"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  ],
    ///  "x-schema-name": "PushButtonResult"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(deny_unknown_fields)]
    pub enum PushButtonResult {}
    impl ::std::convert::From<&Self> for PushButtonResult {
        fn from(value: &PushButtonResult) -> Self {
            value.clone()
        }
    }

    ///`ReferenceColumnFormat`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Format of a column that refers to another table.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/SimpleColumnFormat"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "table"
    ///      ],
    ///      "properties": {
    ///        "table": {
    ///          "allOf": [
    ///            {
    ///              "description": "Reference to the table this column refers
    /// to, if applicable.",
    ///              "additionalProperties": false
    ///            },
    ///            {
    ///              "$ref": "#/components/schemas/TableReference"
    ///            }
    ///          ]
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  ],
    ///  "x-schema-name": "ReferenceColumnFormat"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(deny_unknown_fields)]
    pub enum ReferenceColumnFormat {}
    impl ::std::convert::From<&Self> for ReferenceColumnFormat {
        fn from(value: &ReferenceColumnFormat) -> Self {
            value.clone()
        }
    }

    ///Payload for registering a Pack version.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Payload for registering a Pack version.",
    ///  "type": "object",
    ///  "required": [
    ///    "bundleHash"
    ///  ],
    ///  "properties": {
    ///    "bundleHash": {
    ///      "description": "The SHA-256 hash of the file to be uploaded.",
    ///      "examples": [
    ///        "f0e4c2f76c58916ec258f246851bea091d14d4247a2fc3e18694461b1816e13b"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "RegisterPackVersionRequest"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct RegisterPackVersionRequest {
        ///The SHA-256 hash of the file to be uploaded.
        #[serde(rename = "bundleHash")]
        pub bundle_hash: ::std::string::String,
    }

    impl ::std::convert::From<&RegisterPackVersionRequest> for RegisterPackVersionRequest {
        fn from(value: &RegisterPackVersionRequest) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct RegisterPackVersionResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&RegisterPackVersionResponse> for RegisterPackVersionResponse {
        fn from(value: &RegisterPackVersionResponse) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ResolveBrowserLinkResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&ResolveBrowserLinkResponse> for ResolveBrowserLinkResponse {
        fn from(value: &ResolveBrowserLinkResponse) -> Self {
            value.clone()
        }
    }

    ///A value that contains rich structured data. Cell values are composed of
    /// these values or arrays of these values.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A value that contains rich structured data. Cell values
    /// are composed of these values or arrays of these values.\n",
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ScalarValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/CurrencyValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ImageUrlValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PersonValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/UrlValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/RowValue"
    ///    }
    ///  ],
    ///  "x-schema-name": "RichSingleValue"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum RichSingleValue {
        ScalarValue(ScalarValue),
        CurrencyValue(CurrencyValue),
        ImageUrlValue(ImageUrlValue),
        PersonValue(PersonValue),
        UrlValue(UrlValue),
        RowValue(RowValue),
    }

    impl ::std::convert::From<&Self> for RichSingleValue {
        fn from(value: &RichSingleValue) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<ScalarValue> for RichSingleValue {
        fn from(value: ScalarValue) -> Self {
            Self::ScalarValue(value)
        }
    }

    impl ::std::convert::From<CurrencyValue> for RichSingleValue {
        fn from(value: CurrencyValue) -> Self {
            Self::CurrencyValue(value)
        }
    }

    impl ::std::convert::From<ImageUrlValue> for RichSingleValue {
        fn from(value: ImageUrlValue) -> Self {
            Self::ImageUrlValue(value)
        }
    }

    impl ::std::convert::From<PersonValue> for RichSingleValue {
        fn from(value: PersonValue) -> Self {
            Self::PersonValue(value)
        }
    }

    impl ::std::convert::From<UrlValue> for RichSingleValue {
        fn from(value: UrlValue) -> Self {
            Self::UrlValue(value)
        }
    }

    impl ::std::convert::From<RowValue> for RichSingleValue {
        fn from(value: RowValue) -> Self {
            Self::RowValue(value)
        }
    }

    ///A cell value that contains rich structured data.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A cell value that contains rich structured data.",
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/RichSingleValue"
    ///    },
    ///    {
    ///      "type": "array",
    ///      "items": {
    ///        "oneOf": [
    ///          {
    ///            "$ref": "#/components/schemas/RichSingleValue"
    ///          },
    ///          {
    ///            "type": "array",
    ///            "items": {
    ///              "$ref": "#/components/schemas/RichSingleValue"
    ///            }
    ///          }
    ///        ]
    ///      }
    ///    }
    ///  ],
    ///  "x-schema-name": "RichValue"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum RichValue {
        Variant0(RichSingleValue),
        Variant1(::std::vec::Vec<RichValueVariant1Item>),
    }

    impl ::std::convert::From<&Self> for RichValue {
        fn from(value: &RichValue) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<RichSingleValue> for RichValue {
        fn from(value: RichSingleValue) -> Self {
            Self::Variant0(value)
        }
    }

    impl ::std::convert::From<::std::vec::Vec<RichValueVariant1Item>> for RichValue {
        fn from(value: ::std::vec::Vec<RichValueVariant1Item>) -> Self {
            Self::Variant1(value)
        }
    }

    ///`RichValueVariant1Item`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/RichSingleValue"
    ///    },
    ///    {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/RichSingleValue"
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum RichValueVariant1Item {
        Variant0(RichSingleValue),
        Variant1(::std::vec::Vec<RichSingleValue>),
    }

    impl ::std::convert::From<&Self> for RichValueVariant1Item {
        fn from(value: &RichValueVariant1Item) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<RichSingleValue> for RichValueVariant1Item {
        fn from(value: RichSingleValue) -> Self {
            Self::Variant0(value)
        }
    }

    impl ::std::convert::From<::std::vec::Vec<RichSingleValue>> for RichValueVariant1Item {
        fn from(value: ::std::vec::Vec<RichSingleValue>) -> Self {
            Self::Variant1(value)
        }
    }

    ///Info about a row.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Info about a row.",
    ///  "type": "object",
    ///  "required": [
    ///    "browserLink",
    ///    "createdAt",
    ///    "href",
    ///    "id",
    ///    "index",
    ///    "name",
    ///    "type",
    ///    "updatedAt",
    ///    "values"
    ///  ],
    ///  "properties": {
    ///    "browserLink": {
    ///      "description": "Browser-friendly link to the row.",
    ///      "examples": [
    ///        "https://coda.io/d/_dAbCDeFGH#Teams-and-Tasks_tpqRst-U/_rui-tuVwxYz"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "createdAt": {
    ///      "description": "Timestamp for when the row was created.",
    ///      "examples": [
    ///        "2018-04-11T00:18:57.946Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "href": {
    ///      "description": "API link to the row.",
    ///      "examples": [
    ///        "https://coda.io/apis/v1/docs/AbCDeFGH/tables/grid-pqRst-U/rows/i-RstUv-W"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "id": {
    ///      "description": "ID of the row.",
    ///      "examples": [
    ///        "i-tuVwxYz"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "index": {
    ///      "description": "Index of the row within the table.",
    ///      "examples": [
    ///        7
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "name": {
    ///      "description": "The display name of the row, based on its
    /// identifying column.",
    ///      "examples": [
    ///        "Apple"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "description": "The type of this resource.",
    ///      "type": "string",
    ///      "enum": [
    ///        "row"
    ///      ],
    ///      "x-tsType": "Type.Row"
    ///    },
    ///    "updatedAt": {
    ///      "description": "Timestamp for when the row was last modified.",
    ///      "examples": [
    ///        "2018-04-11T00:18:57.946Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "values": {
    ///      "description": "Values for a specific row, represented as a hash of
    /// column IDs (or names with `useColumnNames`) to values.\n",
    ///      "examples": [
    ///        {
    ///          "c-bCdeFgh": [
    ///            "$12.34",
    ///            "$56.78"
    ///          ],
    ///          "c-tuVwxYz": "Apple"
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "additionalProperties": {
    ///        "$ref": "#/components/schemas/CellValue"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "Row"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct Row {
        ///Browser-friendly link to the row.
        #[serde(rename = "browserLink")]
        pub browser_link: ::std::string::String,
        ///Timestamp for when the row was created.
        #[serde(rename = "createdAt")]
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        ///API link to the row.
        pub href: ::std::string::String,
        ///ID of the row.
        pub id: ::std::string::String,
        ///Index of the row within the table.
        pub index: i64,
        ///The display name of the row, based on its identifying column.
        pub name: ::std::string::String,
        ///The type of this resource.
        #[serde(rename = "type")]
        pub type_: RowType,
        ///Timestamp for when the row was last modified.
        #[serde(rename = "updatedAt")]
        pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
        ///Values for a specific row, represented as a hash of column IDs (or
        /// names with `useColumnNames`) to values.
        pub values: ::std::collections::HashMap<::std::string::String, CellValue>,
    }

    impl ::std::convert::From<&Row> for Row {
        fn from(value: &Row) -> Self {
            value.clone()
        }
    }

    ///`RowDeleteResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The result of a row deletion.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/DocumentMutateResponse"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "id"
    ///      ],
    ///      "properties": {
    ///        "id": {
    ///          "description": "ID of the row to be deleted.",
    ///          "examples": [
    ///            "i-tuVwxYz"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  ],
    ///  "x-schema-name": "RowDeleteResult"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(deny_unknown_fields)]
    pub enum RowDeleteResult {}
    impl ::std::convert::From<&Self> for RowDeleteResult {
        fn from(value: &RowDeleteResult) -> Self {
            value.clone()
        }
    }

    ///Details about a row.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Details about a row.",
    ///  "type": "object",
    ///  "required": [
    ///    "browserLink",
    ///    "createdAt",
    ///    "href",
    ///    "id",
    ///    "index",
    ///    "name",
    ///    "parent",
    ///    "type",
    ///    "updatedAt",
    ///    "values"
    ///  ],
    ///  "properties": {
    ///    "browserLink": {
    ///      "description": "Browser-friendly link to the row.",
    ///      "examples": [
    ///        "https://coda.io/d/_dAbCDeFGH#Teams-and-Tasks_tpqRst-U/_rui-tuVwxYz"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "createdAt": {
    ///      "description": "Timestamp for when the row was created.",
    ///      "examples": [
    ///        "2018-04-11T00:18:57.946Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "href": {
    ///      "description": "API link to the row.",
    ///      "examples": [
    ///        "https://coda.io/apis/v1/docs/AbCDeFGH/tables/grid-pqRst-U/rows/i-RstUv-W"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "id": {
    ///      "description": "ID of the row.",
    ///      "examples": [
    ///        "i-tuVwxYz"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "index": {
    ///      "description": "Index of the row within the table.",
    ///      "examples": [
    ///        7
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "name": {
    ///      "description": "The display name of the row, based on its
    /// identifying column.",
    ///      "examples": [
    ///        "Apple"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "parent": {
    ///      "$ref": "#/components/schemas/TableReference"
    ///    },
    ///    "type": {
    ///      "description": "The type of this resource.",
    ///      "type": "string",
    ///      "enum": [
    ///        "row"
    ///      ],
    ///      "x-tsType": "Type.Row"
    ///    },
    ///    "updatedAt": {
    ///      "description": "Timestamp for when the row was last modified.",
    ///      "examples": [
    ///        "2018-04-11T00:18:57.946Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "values": {
    ///      "description": "Values for a specific row, represented as a hash of
    /// column IDs (or names with `useColumnNames`) to values.\n",
    ///      "examples": [
    ///        {
    ///          "c-bCdeFgh": [
    ///            "$12.34",
    ///            "$56.78"
    ///          ],
    ///          "c-tuVwxYz": "Apple"
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "additionalProperties": {
    ///        "$ref": "#/components/schemas/CellValue"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "RowDetail"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct RowDetail {
        ///Browser-friendly link to the row.
        #[serde(rename = "browserLink")]
        pub browser_link: ::std::string::String,
        ///Timestamp for when the row was created.
        #[serde(rename = "createdAt")]
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        ///API link to the row.
        pub href: ::std::string::String,
        ///ID of the row.
        pub id: ::std::string::String,
        ///Index of the row within the table.
        pub index: i64,
        ///The display name of the row, based on its identifying column.
        pub name: ::std::string::String,
        pub parent: TableReference,
        ///The type of this resource.
        #[serde(rename = "type")]
        pub type_: RowDetailType,
        ///Timestamp for when the row was last modified.
        #[serde(rename = "updatedAt")]
        pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
        ///Values for a specific row, represented as a hash of column IDs (or
        /// names with `useColumnNames`) to values.
        pub values: ::std::collections::HashMap<::std::string::String, CellValue>,
    }

    impl ::std::convert::From<&RowDetail> for RowDetail {
        fn from(value: &RowDetail) -> Self {
            value.clone()
        }
    }

    ///The type of this resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of this resource.",
    ///  "type": "string",
    ///  "enum": [
    ///    "row"
    ///  ],
    ///  "x-tsType": "Type.Row"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum RowDetailType {
        #[serde(rename = "row")]
        Row,
    }

    impl ::std::convert::From<&Self> for RowDetailType {
        fn from(value: &RowDetailType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for RowDetailType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Row => f.write_str("row"),
            }
        }
    }

    impl ::std::str::FromStr for RowDetailType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "row" => Ok(Self::Row),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for RowDetailType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for RowDetailType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for RowDetailType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///An edit made to a particular row.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An edit made to a particular row.",
    ///  "type": "object",
    ///  "required": [
    ///    "cells"
    ///  ],
    ///  "properties": {
    ///    "cells": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/CellEdit"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "RowEdit"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct RowEdit {
        pub cells: ::std::vec::Vec<CellEdit>,
    }

    impl ::std::convert::From<&RowEdit> for RowEdit {
        fn from(value: &RowEdit) -> Self {
            value.clone()
        }
    }

    ///List of rows.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "List of rows.",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "href": {
    ///      "description": "API link to these results",
    ///      "examples": [
    ///        "https://coda.io/apis/v1/docs/AbCDeFGH/tables/grid-pqRst-U/rows?limit=20"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Row"
    ///      }
    ///    },
    ///    "nextPageLink": {
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/nextPageLink"
    ///        },
    ///        {
    ///          "examples": [
    ///            "https://coda.io/apis/v1/docs/AbCDeFGH/tables/grid-pqRst-U/rows?pageToken=eyJsaW1pd"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      ]
    ///    },
    ///    "nextPageToken": {
    ///      "$ref": "#/components/schemas/nextPageToken"
    ///    },
    ///    "nextSyncToken": {
    ///      "$ref": "#/components/schemas/nextSyncToken"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "RowList"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct RowList {
        ///API link to these results
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub href: ::std::option::Option<::std::string::String>,
        pub items: ::std::vec::Vec<Row>,
        #[serde(rename = "nextPageLink", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_link: ::std::option::Option<NextPageLink>,
        #[serde(rename = "nextPageToken", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_token: ::std::option::Option<NextPageToken>,
        #[serde(rename = "nextSyncToken", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_sync_token: ::std::option::Option<NextSyncToken>,
    }

    impl ::std::convert::From<&RowList> for RowList {
        fn from(value: &RowList) -> Self {
            value.clone()
        }
    }

    ///The type of this resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of this resource.",
    ///  "type": "string",
    ///  "enum": [
    ///    "row"
    ///  ],
    ///  "x-tsType": "Type.Row"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum RowType {
        #[serde(rename = "row")]
        Row,
    }

    impl ::std::convert::From<&Self> for RowType {
        fn from(value: &RowType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for RowType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Row => f.write_str("row"),
            }
        }
    }

    impl ::std::str::FromStr for RowType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "row" => Ok(Self::Row),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for RowType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for RowType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for RowType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Payload for updating a row in a table.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Payload for updating a row in a table.",
    ///  "type": "object",
    ///  "required": [
    ///    "row"
    ///  ],
    ///  "properties": {
    ///    "row": {
    ///      "$ref": "#/components/schemas/RowEdit"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "RowUpdate"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct RowUpdate {
        pub row: RowEdit,
    }

    impl ::std::convert::From<&RowUpdate> for RowUpdate {
        fn from(value: &RowUpdate) -> Self {
            value.clone()
        }
    }

    ///`RowUpdateResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The result of a row update.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/DocumentMutateResponse"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "id"
    ///      ],
    ///      "properties": {
    ///        "id": {
    ///          "description": "ID of the updated row.",
    ///          "examples": [
    ///            "i-tuVwxYz"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  ],
    ///  "x-schema-name": "RowUpdateResult"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(deny_unknown_fields)]
    pub enum RowUpdateResult {}
    impl ::std::convert::From<&Self> for RowUpdateResult {
        fn from(value: &RowUpdateResult) -> Self {
            value.clone()
        }
    }

    ///`RowValue`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A value representing a Coda row.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/LinkedDataObject"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "@type",
    ///        "additionalType",
    ///        "name",
    ///        "rowId",
    ///        "tableId",
    ///        "tableUrl",
    ///        "url"
    ///      ],
    ///      "properties": {
    ///        "@type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "StructuredValue"
    ///          ],
    ///          "x-tsType": "LinkedDataType.StructuredValue"
    ///        },
    ///        "additionalType": {
    ///          "description": "The type of this resource.",
    ///          "type": "string",
    ///          "enum": [
    ///            "row"
    ///          ],
    ///          "x-tsType": "Type.Row"
    ///        },
    ///        "name": {
    ///          "description": "The display name of the row, based on its
    /// identifying column.",
    ///          "examples": [
    ///            "Apple"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "rowId": {
    ///          "description": "The ID of the table",
    ///          "examples": [
    ///            "i-tuVwxYz"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "tableId": {
    ///          "description": "The ID of the table",
    ///          "examples": [
    ///            "grid-pqRst-U"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "tableUrl": {
    ///          "description": "The url of the table.",
    ///          "examples": [
    ///            "https://coda.io/d/_dAbCDeFGH#Teams-and-Tasks_tpqRst-U"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "url": {
    ///          "description": "The url of the row.",
    ///          "examples": [
    ///            "https://coda.io/d/_dAbCDeFGH#Teams-and-Tasks_tpqRst-U/_rui-tuVwxYz"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  ],
    ///  "x-schema-name": "RowValue"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(deny_unknown_fields)]
    pub enum RowValue {}
    impl ::std::convert::From<&Self> for RowValue {
        fn from(value: &RowValue) -> Self {
            value.clone()
        }
    }

    ///Payload for deleting rows from a table.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Payload for deleting rows from a table.",
    ///  "type": "object",
    ///  "required": [
    ///    "rowIds"
    ///  ],
    ///  "properties": {
    ///    "rowIds": {
    ///      "description": "Row IDs to delete.\n",
    ///      "examples": [
    ///        [
    ///          "i-bCdeFgh",
    ///          "i-CdEfgHi"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "RowsDelete"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct RowsDelete {
        ///Row IDs to delete.
        #[serde(rename = "rowIds")]
        pub row_ids: ::std::vec::Vec<::std::string::String>,
    }

    impl ::std::convert::From<&RowsDelete> for RowsDelete {
        fn from(value: &RowsDelete) -> Self {
            value.clone()
        }
    }

    ///`RowsDeleteResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The result of a rows delete operation.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/DocumentMutateResponse"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "rowIds"
    ///      ],
    ///      "properties": {
    ///        "rowIds": {
    ///          "description": "Row IDs to delete.",
    ///          "examples": [
    ///            [
    ///              "i-bCdeFgh",
    ///              "i-CdEfgHi"
    ///            ]
    ///          ],
    ///          "type": "array",
    ///          "items": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  ],
    ///  "x-schema-name": "RowsDeleteResult"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(deny_unknown_fields)]
    pub enum RowsDeleteResult {}
    impl ::std::convert::From<&Self> for RowsDeleteResult {
        fn from(value: &RowsDeleteResult) -> Self {
            value.clone()
        }
    }

    ///Determines how the rows returned are sorted
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Determines how the rows returned are sorted",
    ///  "type": "string",
    ///  "enum": [
    ///    "createdAt",
    ///    "natural",
    ///    "updatedAt"
    ///  ],
    ///  "x-schema-name": "RowsSortBy",
    ///  "x-tsEnumNames": [
    ///    "CreatedAt",
    ///    "Natural",
    ///    "UpdatedAt"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum RowsSortBy {
        #[serde(rename = "createdAt")]
        CreatedAt,
        #[serde(rename = "natural")]
        Natural,
        #[serde(rename = "updatedAt")]
        UpdatedAt,
    }

    impl ::std::convert::From<&Self> for RowsSortBy {
        fn from(value: &RowsSortBy) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for RowsSortBy {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::CreatedAt => f.write_str("createdAt"),
                Self::Natural => f.write_str("natural"),
                Self::UpdatedAt => f.write_str("updatedAt"),
            }
        }
    }

    impl ::std::str::FromStr for RowsSortBy {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "createdAt" => Ok(Self::CreatedAt),
                "natural" => Ok(Self::Natural),
                "updatedAt" => Ok(Self::UpdatedAt),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for RowsSortBy {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for RowsSortBy {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for RowsSortBy {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Payload for upserting rows in a table.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Payload for upserting rows in a table.",
    ///  "type": "object",
    ///  "required": [
    ///    "rows"
    ///  ],
    ///  "properties": {
    ///    "keyColumns": {
    ///      "description": "Optional column IDs, URLs, or names (fragile and
    /// discouraged), specifying columns to be used as upsert keys.",
    ///      "examples": [
    ///        [
    ///          "c-bCdeFgh"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "rows": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/RowEdit"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "RowsUpsert"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct RowsUpsert {
        ///Optional column IDs, URLs, or names (fragile and discouraged),
        /// specifying columns to be used as upsert keys.
        #[serde(rename = "keyColumns", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub key_columns: ::std::vec::Vec<::std::string::String>,
        pub rows: ::std::vec::Vec<RowEdit>,
    }

    impl ::std::convert::From<&RowsUpsert> for RowsUpsert {
        fn from(value: &RowsUpsert) -> Self {
            value.clone()
        }
    }

    ///`RowsUpsertResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The result of a rows insert/upsert operation.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/DocumentMutateResponse"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "addedRowIds": {
    ///          "description": "Row IDs for rows that will be added. Only
    /// applicable when keyColumns is not set or empty.",
    ///          "examples": [
    ///            [
    ///              "i-bCdeFgh",
    ///              "i-CdEfgHi"
    ///            ]
    ///          ],
    ///          "type": "array",
    ///          "items": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  ],
    ///  "x-schema-name": "RowsUpsertResult"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(deny_unknown_fields)]
    pub enum RowsUpsertResult {}
    impl ::std::convert::From<&Self> for RowsUpsertResult {
        fn from(value: &RowsUpsertResult) -> Self {
            value.clone()
        }
    }

    ///A Coda result or entity expressed as a primitive type.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A Coda result or entity expressed as a primitive
    /// type.",
    ///  "oneOf": [
    ///    {
    ///      "examples": [
    ///        "$12.34"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    {
    ///      "examples": [
    ///        12.34
    ///      ],
    ///      "type": "number"
    ///    },
    ///    {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    }
    ///  ],
    ///  "x-schema-name": "ScalarValue"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum ScalarValue {
        Variant0(::std::string::String),
        Variant1(f64),
        Variant2(bool),
    }

    impl ::std::convert::From<&Self> for ScalarValue {
        fn from(value: &ScalarValue) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ScalarValue {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
                Self::Variant2(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<f64> for ScalarValue {
        fn from(value: f64) -> Self {
            Self::Variant1(value)
        }
    }

    impl ::std::convert::From<bool> for ScalarValue {
        fn from(value: bool) -> Self {
            Self::Variant2(value)
        }
    }

    ///`ScaleColumnFormat`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Format of a numeric column that renders as a scale,
    /// like star ratings.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/SimpleColumnFormat"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "icon",
    ///        "maximum"
    ///      ],
    ///      "properties": {
    ///        "icon": {
    ///          "allOf": [
    ///            {
    ///              "description": "The icon set to use when rendering the
    /// scale, e.g. render a 5 star scale.",
    ///              "additionalProperties": false
    ///            },
    ///            {
    ///              "$ref": "#/components/schemas/IconSet"
    ///            }
    ///          ]
    ///        },
    ///        "maximum": {
    ///          "description": "The maximum number allowed for this scale.",
    ///          "examples": [
    ///            5
    ///          ],
    ///          "type": "number"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  ],
    ///  "x-schema-name": "ScaleColumnFormat"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(deny_unknown_fields)]
    pub enum ScaleColumnFormat {}
    impl ::std::convert::From<&Self> for ScaleColumnFormat {
        fn from(value: &ScaleColumnFormat) -> Self {
            value.clone()
        }
    }

    ///Metadata about the principals that match the given query.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Metadata about the principals that match the given
    /// query.",
    ///  "type": "object",
    ///  "required": [
    ///    "groups",
    ///    "users"
    ///  ],
    ///  "properties": {
    ///    "groups": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/GroupPrincipal"
    ///      }
    ///    },
    ///    "users": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/UserSummary"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "SearchPrincipalsResponse"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct SearchPrincipalsResponse {
        pub groups: ::std::vec::Vec<GroupPrincipal>,
        pub users: ::std::vec::Vec<UserSummary>,
    }

    impl ::std::convert::From<&SearchPrincipalsResponse> for SearchPrincipalsResponse {
        fn from(value: &SearchPrincipalsResponse) -> Self {
            value.clone()
        }
    }

    ///`SelectColumnFormat`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Format of a select column.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/SimpleColumnFormat"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "options": {
    ///          "description": "For select format columns, the list of
    /// available options. Only returned for select lists that used a fixed set
    /// of options. Returns the first 5000 options.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/SelectOption"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  ],
    ///  "x-schema-name": "SelectColumnFormat"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(deny_unknown_fields)]
    pub enum SelectColumnFormat {}
    impl ::std::convert::From<&Self> for SelectColumnFormat {
        fn from(value: &SelectColumnFormat) -> Self {
            value.clone()
        }
    }

    ///An option for a select column.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An option for a select column.",
    ///  "type": "object",
    ///  "required": [
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "backgroundColor": {
    ///      "description": "The background color of the option.",
    ///      "examples": [
    ///        "#ff0000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "foregroundColor": {
    ///      "description": "The foreground color of the option.",
    ///      "examples": [
    ///        "#ffffff"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "The name of the option.",
    ///      "examples": [
    ///        "Option 1"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "SelectOption"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct SelectOption {
        ///The background color of the option.
        #[serde(rename = "backgroundColor", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub background_color: ::std::option::Option<::std::string::String>,
        ///The foreground color of the option.
        #[serde(rename = "foregroundColor", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub foreground_color: ::std::option::Option<::std::string::String>,
        ///The name of the option.
        pub name: ::std::string::String,
    }

    impl ::std::convert::From<&SelectOption> for SelectOption {
        fn from(value: &SelectOption) -> Self {
            value.clone()
        }
    }

    ///Request to set the Pack OAuth configuration.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Request to set the Pack OAuth configuration.",
    ///  "type": "object",
    ///  "properties": {
    ///    "clientId": {
    ///      "type": "string"
    ///    },
    ///    "clientSecret": {
    ///      "type": "string"
    ///    },
    ///    "redirectUri": {
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "SetPackOauthConfigRequest"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct SetPackOauthConfigRequest {
        #[serde(rename = "clientId", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub client_id: ::std::option::Option<::std::string::String>,
        #[serde(rename = "clientSecret", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub client_secret: ::std::option::Option<::std::string::String>,
        #[serde(rename = "redirectUri", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub redirect_uri: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&SetPackOauthConfigRequest> for SetPackOauthConfigRequest {
        fn from(value: &SetPackOauthConfigRequest) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for SetPackOauthConfigRequest {
        fn default() -> Self {
            Self {
                client_id: Default::default(),
                client_secret: Default::default(),
                redirect_uri: Default::default(),
            }
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "codaDetail": {
    ///      "description": "Detail about why this request was rejected.",
    ///      "type": "object",
    ///      "properties": {
    ///        "validationErrors": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/ValidationError"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    },
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct SetPackOauthConfigResponse {
        #[serde(rename = "codaDetail", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub coda_detail: ::std::option::Option<SetPackOauthConfigResponseCodaDetail>,
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&SetPackOauthConfigResponse> for SetPackOauthConfigResponse {
        fn from(value: &SetPackOauthConfigResponse) -> Self {
            value.clone()
        }
    }

    ///Detail about why this request was rejected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why this request was rejected.",
    ///  "type": "object",
    ///  "properties": {
    ///    "validationErrors": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct SetPackOauthConfigResponseCodaDetail {
        #[serde(rename = "validationErrors", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub validation_errors: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&SetPackOauthConfigResponseCodaDetail> for SetPackOauthConfigResponseCodaDetail {
        fn from(value: &SetPackOauthConfigResponseCodaDetail) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for SetPackOauthConfigResponseCodaDetail {
        fn default() -> Self {
            Self {
                validation_errors: Default::default(),
            }
        }
    }

    ///The request to set pack system connection credentials.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The request to set pack system connection
    /// credentials.",
    ///  "type": "object",
    ///  "required": [
    ///    "credentials"
    ///  ],
    ///  "properties": {
    ///    "credentials": {
    ///      "$ref": "#/components/schemas/PackSystemConnectionCredentials"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "SetPackSystemConnectionRequest"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct SetPackSystemConnectionRequest {
        pub credentials: PackSystemConnectionCredentials,
    }

    impl ::std::convert::From<&SetPackSystemConnectionRequest> for SetPackSystemConnectionRequest {
        fn from(value: &SetPackSystemConnectionRequest) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "codaDetail": {
    ///      "description": "Detail about why this request was rejected.",
    ///      "type": "object",
    ///      "properties": {
    ///        "validationErrors": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/ValidationError"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    },
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct SetPackSystemConnectionResponse {
        #[serde(rename = "codaDetail", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub coda_detail: ::std::option::Option<SetPackSystemConnectionResponseCodaDetail>,
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&SetPackSystemConnectionResponse> for SetPackSystemConnectionResponse {
        fn from(value: &SetPackSystemConnectionResponse) -> Self {
            value.clone()
        }
    }

    ///Detail about why this request was rejected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why this request was rejected.",
    ///  "type": "object",
    ///  "properties": {
    ///    "validationErrors": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct SetPackSystemConnectionResponseCodaDetail {
        #[serde(rename = "validationErrors", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub validation_errors: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&SetPackSystemConnectionResponseCodaDetail> for SetPackSystemConnectionResponseCodaDetail {
        fn from(value: &SetPackSystemConnectionResponseCodaDetail) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for SetPackSystemConnectionResponseCodaDetail {
        fn default() -> Self {
            Self {
                validation_errors: Default::default(),
            }
        }
    }

    ///Format of a simple column.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Format of a simple column.",
    ///  "type": "object",
    ///  "required": [
    ///    "isArray",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "isArray": {
    ///      "description": "Whether or not this column is an array.",
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "type": {
    ///      "$ref": "#/components/schemas/ColumnFormatType"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "SimpleColumnFormat"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct SimpleColumnFormat {
        ///Whether or not this column is an array.
        #[serde(rename = "isArray")]
        pub is_array: bool,
        #[serde(rename = "type")]
        pub type_: ColumnFormatType,
    }

    impl ::std::convert::From<&SimpleColumnFormat> for SimpleColumnFormat {
        fn from(value: &SimpleColumnFormat) -> Self {
            value.clone()
        }
    }

    ///`SliderColumnFormat`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Format of a numeric column that renders as a slider.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/SimpleColumnFormat"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "displayType": {
    ///          "$ref": "#/components/schemas/SliderDisplayType"
    ///        },
    ///        "maximum": {
    ///          "allOf": [
    ///            {
    ///              "description": "The maximum allowed value for this
    /// slider.",
    ///              "additionalProperties": false
    ///            },
    ///            {
    ///              "$ref": "#/components/schemas/NumberOrNumberFormula"
    ///            }
    ///          ]
    ///        },
    ///        "minimum": {
    ///          "allOf": [
    ///            {
    ///              "description": "The minimum allowed value for this
    /// slider.",
    ///              "additionalProperties": false
    ///            },
    ///            {
    ///              "$ref": "#/components/schemas/NumberOrNumberFormula"
    ///            }
    ///          ]
    ///        },
    ///        "showValue": {
    ///          "description": "Whether the underyling numeric value is also
    /// displayed.",
    ///          "examples": [
    ///            true
    ///          ],
    ///          "type": "boolean"
    ///        },
    ///        "step": {
    ///          "allOf": [
    ///            {
    ///              "description": "The step size (numeric increment) for this
    /// slider.",
    ///              "additionalProperties": false
    ///            },
    ///            {
    ///              "$ref": "#/components/schemas/NumberOrNumberFormula"
    ///            }
    ///          ]
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  ],
    ///  "x-schema-name": "SliderColumnFormat"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(deny_unknown_fields)]
    pub enum SliderColumnFormat {}
    impl ::std::convert::From<&Self> for SliderColumnFormat {
        fn from(value: &SliderColumnFormat) -> Self {
            value.clone()
        }
    }

    ///How the slider should be rendered.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "How the slider should be rendered.",
    ///  "type": "string",
    ///  "enum": [
    ///    "slider",
    ///    "progress"
    ///  ],
    ///  "x-schema-name": "SliderDisplayType",
    ///  "x-tsEnumNames": [
    ///    "Slider",
    ///    "Progress"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum SliderDisplayType {
        #[serde(rename = "slider")]
        Slider,
        #[serde(rename = "progress")]
        Progress,
    }

    impl ::std::convert::From<&Self> for SliderDisplayType {
        fn from(value: &SliderDisplayType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SliderDisplayType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Slider => f.write_str("slider"),
                Self::Progress => f.write_str("progress"),
            }
        }
    }

    impl ::std::str::FromStr for SliderDisplayType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "slider" => Ok(Self::Slider),
                "progress" => Ok(Self::Progress),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SliderDisplayType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SliderDisplayType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SliderDisplayType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///A sort applied to a table or view.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A sort applied to a table or view.",
    ///  "type": "object",
    ///  "required": [
    ///    "column",
    ///    "direction"
    ///  ],
    ///  "properties": {
    ///    "column": {
    ///      "$ref": "#/components/schemas/ColumnReference"
    ///    },
    ///    "direction": {
    ///      "$ref": "#/components/schemas/SortDirection"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "Sort"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct Sort {
        pub column: ColumnReference,
        pub direction: SortDirection,
    }

    impl ::std::convert::From<&Sort> for Sort {
        fn from(value: &Sort) -> Self {
            value.clone()
        }
    }

    ///Determines how the objects returned are sorted
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Determines how the objects returned are sorted",
    ///  "type": "string",
    ///  "enum": [
    ///    "name"
    ///  ],
    ///  "x-schema-name": "SortBy",
    ///  "x-tsEnumNames": [
    ///    "Name"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum SortBy {
        #[serde(rename = "name")]
        Name,
    }

    impl ::std::convert::From<&Self> for SortBy {
        fn from(value: &SortBy) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SortBy {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Name => f.write_str("name"),
            }
        }
    }

    impl ::std::str::FromStr for SortBy {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "name" => Ok(Self::Name),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SortBy {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SortBy {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SortBy {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Direction of a sort for a table or view.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Direction of a sort for a table or view.",
    ///  "type": "string",
    ///  "enum": [
    ///    "ascending",
    ///    "descending"
    ///  ],
    ///  "x-schema-name": "SortDirection",
    ///  "x-tsEnumNames": [
    ///    "Ascending",
    ///    "Descending"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum SortDirection {
        #[serde(rename = "ascending")]
        Ascending,
        #[serde(rename = "descending")]
        Descending,
    }

    impl ::std::convert::From<&Self> for SortDirection {
        fn from(value: &SortDirection) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SortDirection {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ascending => f.write_str("ascending"),
                Self::Descending => f.write_str("descending"),
            }
        }
    }

    impl ::std::str::FromStr for SortDirection {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ascending" => Ok(Self::Ascending),
                "descending" => Ok(Self::Descending),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SortDirection {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SortDirection {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SortDirection {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The Pack plan to show the Pack can be subscribed to at a monthly cost
    /// per Doc Maker or for free.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The Pack plan to show the Pack can be subscribed to at
    /// a monthly cost per Doc Maker or for free.",
    ///  "type": "object",
    ///  "required": [
    ///    "createdAt",
    ///    "packId",
    ///    "packPlanId",
    ///    "pricing"
    ///  ],
    ///  "properties": {
    ///    "createdAt": {
    ///      "description": "Timestamp for when the Pack plan was created.",
    ///      "examples": [
    ///        "2018-04-11T00:18:57.946Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "packId": {
    ///      "type": "number"
    ///    },
    ///    "packPlanId": {
    ///      "type": "string"
    ///    },
    ///    "pricing": {
    ///      "description": "Pricing to show how workspaces can subscribe to the
    /// Pack.",
    ///      "oneOf": [
    ///        {
    ///          "$ref": "#/components/schemas/FreePackPlanPricing"
    ///        },
    ///        {
    ///          "$ref": "#/components/schemas/MonthlyDocMakerPackPlanPricing"
    ///        }
    ///      ]
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "StandardPackPlan"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct StandardPackPlan {
        ///Timestamp for when the Pack plan was created.
        #[serde(rename = "createdAt")]
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        #[serde(rename = "packId")]
        pub pack_id: f64,
        #[serde(rename = "packPlanId")]
        pub pack_plan_id: ::std::string::String,
        ///Pricing to show how workspaces can subscribe to the Pack.
        pub pricing: StandardPackPlanPricing,
    }

    impl ::std::convert::From<&StandardPackPlan> for StandardPackPlan {
        fn from(value: &StandardPackPlan) -> Self {
            value.clone()
        }
    }

    ///Pricing to show how workspaces can subscribe to the Pack.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Pricing to show how workspaces can subscribe to the
    /// Pack.",
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/FreePackPlanPricing"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/MonthlyDocMakerPackPlanPricing"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum StandardPackPlanPricing {
        FreePackPlanPricing(FreePackPlanPricing),
        MonthlyDocMakerPackPlanPricing(MonthlyDocMakerPackPlanPricing),
    }

    impl ::std::convert::From<&Self> for StandardPackPlanPricing {
        fn from(value: &StandardPackPlanPricing) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<FreePackPlanPricing> for StandardPackPlanPricing {
        fn from(value: FreePackPlanPricing) -> Self {
            Self::FreePackPlanPricing(value)
        }
    }

    impl ::std::convert::From<MonthlyDocMakerPackPlanPricing> for StandardPackPlanPricing {
        fn from(value: MonthlyDocMakerPackPlanPricing) -> Self {
            Self::MonthlyDocMakerPackPlanPricing(value)
        }
    }

    ///The type of sync page in a doc
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of sync page in a doc",
    ///  "type": "string",
    ///  "enum": [
    ///    "page",
    ///    "document"
    ///  ],
    ///  "x-schema-name": "SyncPageTypeEnum",
    ///  "x-tsEnumNames": [
    ///    "Page",
    ///    "Document"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum SyncPageTypeEnum {
        #[serde(rename = "page")]
        Page,
        #[serde(rename = "document")]
        Document,
    }

    impl ::std::convert::From<&Self> for SyncPageTypeEnum {
        fn from(value: &SyncPageTypeEnum) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SyncPageTypeEnum {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Page => f.write_str("page"),
                Self::Document => f.write_str("document"),
            }
        }
    }

    impl ::std::str::FromStr for SyncPageTypeEnum {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "page" => Ok(Self::Page),
                "document" => Ok(Self::Document),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SyncPageTypeEnum {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SyncPageTypeEnum {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SyncPageTypeEnum {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Metadata about a table.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Metadata about a table.",
    ///  "type": "object",
    ///  "required": [
    ///    "browserLink",
    ///    "createdAt",
    ///    "displayColumn",
    ///    "href",
    ///    "id",
    ///    "layout",
    ///    "name",
    ///    "parent",
    ///    "rowCount",
    ///    "sorts",
    ///    "tableType",
    ///    "type",
    ///    "updatedAt",
    ///    "viewId"
    ///  ],
    ///  "properties": {
    ///    "browserLink": {
    ///      "description": "Browser-friendly link to the table.",
    ///      "examples": [
    ///        "https://coda.io/d/_dAbCDeFGH/#Teams-and-Tasks_tpqRst-U"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "createdAt": {
    ///      "description": "Timestamp for when the table was created.",
    ///      "examples": [
    ///        "2018-04-11T00:18:57.946Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "displayColumn": {
    ///      "$ref": "#/components/schemas/ColumnReference"
    ///    },
    ///    "filter": {
    ///      "allOf": [
    ///        {
    ///          "description": "Detailed information about the filter formula
    /// for the table, if applicable.",
    ///          "additionalProperties": false
    ///        },
    ///        {
    ///          "$ref": "#/components/schemas/FormulaDetail"
    ///        }
    ///      ]
    ///    },
    ///    "href": {
    ///      "description": "API link to the table.",
    ///      "examples": [
    ///        "https://coda.io/apis/v1/docs/AbCDeFGH/tables/grid-pqRst-U"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "id": {
    ///      "description": "ID of the table.",
    ///      "examples": [
    ///        "grid-pqRst-U"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "layout": {
    ///      "$ref": "#/components/schemas/Layout"
    ///    },
    ///    "name": {
    ///      "description": "Name of the table.",
    ///      "examples": [
    ///        "Tasks"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "parent": {
    ///      "$ref": "#/components/schemas/PageReference"
    ///    },
    ///    "parentTable": {
    ///      "$ref": "#/components/schemas/TableReference"
    ///    },
    ///    "rowCount": {
    ///      "description": "Total number of rows in the table.",
    ///      "examples": [
    ///        130
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "sorts": {
    ///      "description": "Any sorts applied to the table.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Sort"
    ///      }
    ///    },
    ///    "tableType": {
    ///      "$ref": "#/components/schemas/TableTypeEnum"
    ///    },
    ///    "type": {
    ///      "description": "The type of this resource.",
    ///      "type": "string",
    ///      "enum": [
    ///        "table"
    ///      ],
    ///      "x-tsType": "Type.Table"
    ///    },
    ///    "updatedAt": {
    ///      "description": "Timestamp for when the table was last modified.",
    ///      "examples": [
    ///        "2018-04-11T00:18:57.946Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "Table"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct Table {
        ///Browser-friendly link to the table.
        #[serde(rename = "browserLink")]
        pub browser_link: ::std::string::String,
        ///Timestamp for when the table was created.
        #[serde(rename = "createdAt")]
        pub created_at: ::chrono::DateTime<::chrono::offset::Utc>,
        #[serde(rename = "displayColumn")]
        pub display_column: ColumnReference,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub filter: ::std::option::Option<TableFilter>,
        ///API link to the table.
        pub href: ::std::string::String,
        ///ID of the table.
        pub id: ::std::string::String,
        pub layout: Layout,
        ///Name of the table.
        pub name: ::std::string::String,
        pub parent: PageReference,
        #[serde(rename = "parentTable", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub parent_table: ::std::option::Option<TableReference>,
        ///Total number of rows in the table.
        #[serde(rename = "rowCount")]
        pub row_count: i64,
        ///Any sorts applied to the table.
        pub sorts: ::std::vec::Vec<Sort>,
        #[serde(rename = "tableType")]
        pub table_type: TableTypeEnum,
        ///The type of this resource.
        #[serde(rename = "type")]
        pub type_: TableType,
        ///Timestamp for when the table was last modified.
        #[serde(rename = "updatedAt")]
        pub updated_at: ::chrono::DateTime<::chrono::offset::Utc>,
        #[serde(rename = "viewId")]
        pub view_id: ::serde_json::Value,
    }

    impl ::std::convert::From<&Table> for Table {
        fn from(value: &Table) -> Self {
            value.clone()
        }
    }

    ///`TableFilter`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "description": "Detailed information about the filter formula for
    /// the table, if applicable.",
    ///      "additionalProperties": false
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/FormulaDetail"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(deny_unknown_fields)]
    pub enum TableFilter {}
    impl ::std::convert::From<&Self> for TableFilter {
        fn from(value: &TableFilter) -> Self {
            value.clone()
        }
    }

    ///List of tables.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "List of tables.",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "href": {
    ///      "description": "API link to these results",
    ///      "examples": [
    ///        "https://coda.io/apis/v1/docs/AbCDeFGH/tables?limit=20"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TableReference"
    ///      }
    ///    },
    ///    "nextPageLink": {
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/nextPageLink"
    ///        },
    ///        {
    ///          "examples": [
    ///            "https://coda.io/apis/v1/docs/AbCDeFGH/tables?pageToken=eyJsaW1pd"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      ]
    ///    },
    ///    "nextPageToken": {
    ///      "$ref": "#/components/schemas/nextPageToken"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "TableList"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct TableList {
        ///API link to these results
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub href: ::std::option::Option<::std::string::String>,
        pub items: ::std::vec::Vec<TableReference>,
        #[serde(rename = "nextPageLink", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_link: ::std::option::Option<NextPageLink>,
        #[serde(rename = "nextPageToken", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_token: ::std::option::Option<NextPageToken>,
    }

    impl ::std::convert::From<&TableList> for TableList {
        fn from(value: &TableList) -> Self {
            value.clone()
        }
    }

    ///Reference to a table or view.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Reference to a table or view.",
    ///  "type": "object",
    ///  "required": [
    ///    "browserLink",
    ///    "href",
    ///    "id",
    ///    "name",
    ///    "tableType",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "browserLink": {
    ///      "description": "Browser-friendly link to the table.",
    ///      "examples": [
    ///        "https://coda.io/d/_dAbCDeFGH/#Teams-and-Tasks_tpqRst-U"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "href": {
    ///      "description": "API link to the table.",
    ///      "examples": [
    ///        "https://coda.io/apis/v1/docs/AbCDeFGH/tables/grid-pqRst-U"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "id": {
    ///      "description": "ID of the table.",
    ///      "examples": [
    ///        "grid-pqRst-U"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "Name of the table.",
    ///      "examples": [
    ///        "Tasks"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "parent": {
    ///      "$ref": "#/components/schemas/PageReference"
    ///    },
    ///    "tableType": {
    ///      "$ref": "#/components/schemas/TableTypeEnum"
    ///    },
    ///    "type": {
    ///      "description": "The type of this resource.",
    ///      "type": "string",
    ///      "enum": [
    ///        "table"
    ///      ],
    ///      "x-tsType": "Type.Table"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "TableReference"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct TableReference {
        ///Browser-friendly link to the table.
        #[serde(rename = "browserLink")]
        pub browser_link: ::std::string::String,
        ///API link to the table.
        pub href: ::std::string::String,
        ///ID of the table.
        pub id: ::std::string::String,
        ///Name of the table.
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub parent: ::std::option::Option<PageReference>,
        #[serde(rename = "tableType")]
        pub table_type: TableTypeEnum,
        ///The type of this resource.
        #[serde(rename = "type")]
        pub type_: TableReferenceType,
    }

    impl ::std::convert::From<&TableReference> for TableReference {
        fn from(value: &TableReference) -> Self {
            value.clone()
        }
    }

    ///The type of this resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of this resource.",
    ///  "type": "string",
    ///  "enum": [
    ///    "table"
    ///  ],
    ///  "x-tsType": "Type.Table"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum TableReferenceType {
        #[serde(rename = "table")]
        Table,
    }

    impl ::std::convert::From<&Self> for TableReferenceType {
        fn from(value: &TableReferenceType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for TableReferenceType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Table => f.write_str("table"),
            }
        }
    }

    impl ::std::str::FromStr for TableReferenceType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "table" => Ok(Self::Table),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for TableReferenceType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for TableReferenceType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for TableReferenceType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The type of this resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of this resource.",
    ///  "type": "string",
    ///  "enum": [
    ///    "table"
    ///  ],
    ///  "x-tsType": "Type.Table"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum TableType {
        #[serde(rename = "table")]
        Table,
    }

    impl ::std::convert::From<&Self> for TableType {
        fn from(value: &TableType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for TableType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Table => f.write_str("table"),
            }
        }
    }

    impl ::std::str::FromStr for TableType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "table" => Ok(Self::Table),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for TableType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for TableType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for TableType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`TableTypeEnum`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "table",
    ///    "view"
    ///  ],
    ///  "x-schema-name": "TableTypeEnum",
    ///  "x-tsEnumNames": [
    ///    "Table",
    ///    "View"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum TableTypeEnum {
        #[serde(rename = "table")]
        Table,
        #[serde(rename = "view")]
        View,
    }

    impl ::std::convert::From<&Self> for TableTypeEnum {
        fn from(value: &TableTypeEnum) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for TableTypeEnum {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Table => f.write_str("table"),
                Self::View => f.write_str("view"),
            }
        }
    }

    impl ::std::str::FromStr for TableTypeEnum {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "table" => Ok(Self::Table),
                "view" => Ok(Self::View),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for TableTypeEnum {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for TableTypeEnum {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for TableTypeEnum {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`TimeColumnFormat`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Format of a time column.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/SimpleColumnFormat"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "format": {
    ///          "description": "A format string using Moment syntax: https://momentjs.com/docs/#/displaying/",
    ///          "examples": [
    ///            "h:mm:ss A"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  ],
    ///  "x-schema-name": "TimeColumnFormat"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(deny_unknown_fields)]
    pub enum TimeColumnFormat {}
    impl ::std::convert::From<&Self> for TimeColumnFormat {
        fn from(value: &TimeColumnFormat) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct TriggerWebhookAutomationResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&TriggerWebhookAutomationResponse> for TriggerWebhookAutomationResponse {
        fn from(value: &TriggerWebhookAutomationResponse) -> Self {
            value.clone()
        }
    }

    ///A constant identifying the type of the resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A constant identifying the type of the resource.",
    ///  "type": "string",
    ///  "enum": [
    ///    "aclMetadata",
    ///    "aclPermissions",
    ///    "aclSettings",
    ///    "analyticsLastUpdated",
    ///    "apiLink",
    ///    "automation",
    ///    "column",
    ///    "control",
    ///    "doc",
    ///    "customDocDomain",
    ///    "customDocDomainProvider",
    ///    "docAnalytics",
    ///    "docAnalyticsSummary",
    ///    "docAnalyticsV2",
    ///    "folder",
    ///    "formula",
    ///    "goLink",
    ///    "ingestionBatchExecution",
    ///    "ingestionExecution",
    ///    "ingestionExecutionAttempt",
    ///    "ingestionPackLog",
    ///    "ingestionParentItem",
    ///    "mutationStatus",
    ///    "pack",
    ///    "packAclPermissions",
    ///    "packAnalytics",
    ///    "packAnalyticsSummary",
    ///    "packAsset",
    ///    "packCategory",
    ///    "packConfigurationSchema",
    ///    "packFeaturedDocs",
    ///    "packFormulaAnalytics",
    ///    "packLog",
    ///    "packMaker",
    ///    "packOauthConfig",
    ///    "packRelease",
    ///    "packSourceCode",
    ///    "packSystemConnection",
    ///    "packVersion",
    ///    "page",
    ///    "pageContentExport",
    ///    "pageContentExportStatus",
    ///    "principal",
    ///    "row",
    ///    "table",
    ///    "user",
    ///    "workspace"
    ///  ],
    ///  "x-schema-name": "Type",
    ///  "x-tsEnumNames": [
    ///    "AclMetadata",
    ///    "AclPermissions",
    ///    "AclSettings",
    ///    "AnalyticsLastUpdated",
    ///    "ApiLink",
    ///    "Automation",
    ///    "Column",
    ///    "Control",
    ///    "Doc",
    ///    "CustomDocDomain",
    ///    "CustomDocDomainProvider",
    ///    "DocAnalytics",
    ///    "DocAnalyticsSummary",
    ///    "DocAnalyticsV2",
    ///    "Folder",
    ///    "Formula",
    ///    "GoLink",
    ///    "IngestionBatchExecution",
    ///    "IngestionExecution",
    ///    "IngestionExecutionAttempt",
    ///    "IngestionPackLog",
    ///    "IngestionParentItem",
    ///    "MutationStatus",
    ///    "Pack",
    ///    "PackAclPermissions",
    ///    "PackAnalytics",
    ///    "PackAnalyticsSummary",
    ///    "PackAsset",
    ///    "PackCategory",
    ///    "PackConfigurationSchema",
    ///    "PackFeaturedDocs",
    ///    "PackFormulaAnalytics",
    ///    "PackLog",
    ///    "PackMaker",
    ///    "PackOauthConfig",
    ///    "PackRelease",
    ///    "PackSourceCode",
    ///    "PackSystemConnection",
    ///    "PackVersion",
    ///    "Page",
    ///    "PageContentExport",
    ///    "PageContentExportStatus",
    ///    "Principal",
    ///    "Row",
    ///    "Table",
    ///    "User",
    ///    "Workspace"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum Type {
        #[serde(rename = "aclMetadata")]
        AclMetadata,
        #[serde(rename = "aclPermissions")]
        AclPermissions,
        #[serde(rename = "aclSettings")]
        AclSettings,
        #[serde(rename = "analyticsLastUpdated")]
        AnalyticsLastUpdated,
        #[serde(rename = "apiLink")]
        ApiLink,
        #[serde(rename = "automation")]
        Automation,
        #[serde(rename = "column")]
        Column,
        #[serde(rename = "control")]
        Control,
        #[serde(rename = "doc")]
        Doc,
        #[serde(rename = "customDocDomain")]
        CustomDocDomain,
        #[serde(rename = "customDocDomainProvider")]
        CustomDocDomainProvider,
        #[serde(rename = "docAnalytics")]
        DocAnalytics,
        #[serde(rename = "docAnalyticsSummary")]
        DocAnalyticsSummary,
        #[serde(rename = "docAnalyticsV2")]
        DocAnalyticsV2,
        #[serde(rename = "folder")]
        Folder,
        #[serde(rename = "formula")]
        Formula,
        #[serde(rename = "goLink")]
        GoLink,
        #[serde(rename = "ingestionBatchExecution")]
        IngestionBatchExecution,
        #[serde(rename = "ingestionExecution")]
        IngestionExecution,
        #[serde(rename = "ingestionExecutionAttempt")]
        IngestionExecutionAttempt,
        #[serde(rename = "ingestionPackLog")]
        IngestionPackLog,
        #[serde(rename = "ingestionParentItem")]
        IngestionParentItem,
        #[serde(rename = "mutationStatus")]
        MutationStatus,
        #[serde(rename = "pack")]
        Pack,
        #[serde(rename = "packAclPermissions")]
        PackAclPermissions,
        #[serde(rename = "packAnalytics")]
        PackAnalytics,
        #[serde(rename = "packAnalyticsSummary")]
        PackAnalyticsSummary,
        #[serde(rename = "packAsset")]
        PackAsset,
        #[serde(rename = "packCategory")]
        PackCategory,
        #[serde(rename = "packConfigurationSchema")]
        PackConfigurationSchema,
        #[serde(rename = "packFeaturedDocs")]
        PackFeaturedDocs,
        #[serde(rename = "packFormulaAnalytics")]
        PackFormulaAnalytics,
        #[serde(rename = "packLog")]
        PackLog,
        #[serde(rename = "packMaker")]
        PackMaker,
        #[serde(rename = "packOauthConfig")]
        PackOauthConfig,
        #[serde(rename = "packRelease")]
        PackRelease,
        #[serde(rename = "packSourceCode")]
        PackSourceCode,
        #[serde(rename = "packSystemConnection")]
        PackSystemConnection,
        #[serde(rename = "packVersion")]
        PackVersion,
        #[serde(rename = "page")]
        Page,
        #[serde(rename = "pageContentExport")]
        PageContentExport,
        #[serde(rename = "pageContentExportStatus")]
        PageContentExportStatus,
        #[serde(rename = "principal")]
        Principal,
        #[serde(rename = "row")]
        Row,
        #[serde(rename = "table")]
        Table,
        #[serde(rename = "user")]
        User,
        #[serde(rename = "workspace")]
        Workspace,
    }

    impl ::std::convert::From<&Self> for Type {
        fn from(value: &Type) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for Type {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AclMetadata => f.write_str("aclMetadata"),
                Self::AclPermissions => f.write_str("aclPermissions"),
                Self::AclSettings => f.write_str("aclSettings"),
                Self::AnalyticsLastUpdated => f.write_str("analyticsLastUpdated"),
                Self::ApiLink => f.write_str("apiLink"),
                Self::Automation => f.write_str("automation"),
                Self::Column => f.write_str("column"),
                Self::Control => f.write_str("control"),
                Self::Doc => f.write_str("doc"),
                Self::CustomDocDomain => f.write_str("customDocDomain"),
                Self::CustomDocDomainProvider => f.write_str("customDocDomainProvider"),
                Self::DocAnalytics => f.write_str("docAnalytics"),
                Self::DocAnalyticsSummary => f.write_str("docAnalyticsSummary"),
                Self::DocAnalyticsV2 => f.write_str("docAnalyticsV2"),
                Self::Folder => f.write_str("folder"),
                Self::Formula => f.write_str("formula"),
                Self::GoLink => f.write_str("goLink"),
                Self::IngestionBatchExecution => f.write_str("ingestionBatchExecution"),
                Self::IngestionExecution => f.write_str("ingestionExecution"),
                Self::IngestionExecutionAttempt => f.write_str("ingestionExecutionAttempt"),
                Self::IngestionPackLog => f.write_str("ingestionPackLog"),
                Self::IngestionParentItem => f.write_str("ingestionParentItem"),
                Self::MutationStatus => f.write_str("mutationStatus"),
                Self::Pack => f.write_str("pack"),
                Self::PackAclPermissions => f.write_str("packAclPermissions"),
                Self::PackAnalytics => f.write_str("packAnalytics"),
                Self::PackAnalyticsSummary => f.write_str("packAnalyticsSummary"),
                Self::PackAsset => f.write_str("packAsset"),
                Self::PackCategory => f.write_str("packCategory"),
                Self::PackConfigurationSchema => f.write_str("packConfigurationSchema"),
                Self::PackFeaturedDocs => f.write_str("packFeaturedDocs"),
                Self::PackFormulaAnalytics => f.write_str("packFormulaAnalytics"),
                Self::PackLog => f.write_str("packLog"),
                Self::PackMaker => f.write_str("packMaker"),
                Self::PackOauthConfig => f.write_str("packOauthConfig"),
                Self::PackRelease => f.write_str("packRelease"),
                Self::PackSourceCode => f.write_str("packSourceCode"),
                Self::PackSystemConnection => f.write_str("packSystemConnection"),
                Self::PackVersion => f.write_str("packVersion"),
                Self::Page => f.write_str("page"),
                Self::PageContentExport => f.write_str("pageContentExport"),
                Self::PageContentExportStatus => f.write_str("pageContentExportStatus"),
                Self::Principal => f.write_str("principal"),
                Self::Row => f.write_str("row"),
                Self::Table => f.write_str("table"),
                Self::User => f.write_str("user"),
                Self::Workspace => f.write_str("workspace"),
            }
        }
    }

    impl ::std::str::FromStr for Type {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "aclMetadata" => Ok(Self::AclMetadata),
                "aclPermissions" => Ok(Self::AclPermissions),
                "aclSettings" => Ok(Self::AclSettings),
                "analyticsLastUpdated" => Ok(Self::AnalyticsLastUpdated),
                "apiLink" => Ok(Self::ApiLink),
                "automation" => Ok(Self::Automation),
                "column" => Ok(Self::Column),
                "control" => Ok(Self::Control),
                "doc" => Ok(Self::Doc),
                "customDocDomain" => Ok(Self::CustomDocDomain),
                "customDocDomainProvider" => Ok(Self::CustomDocDomainProvider),
                "docAnalytics" => Ok(Self::DocAnalytics),
                "docAnalyticsSummary" => Ok(Self::DocAnalyticsSummary),
                "docAnalyticsV2" => Ok(Self::DocAnalyticsV2),
                "folder" => Ok(Self::Folder),
                "formula" => Ok(Self::Formula),
                "goLink" => Ok(Self::GoLink),
                "ingestionBatchExecution" => Ok(Self::IngestionBatchExecution),
                "ingestionExecution" => Ok(Self::IngestionExecution),
                "ingestionExecutionAttempt" => Ok(Self::IngestionExecutionAttempt),
                "ingestionPackLog" => Ok(Self::IngestionPackLog),
                "ingestionParentItem" => Ok(Self::IngestionParentItem),
                "mutationStatus" => Ok(Self::MutationStatus),
                "pack" => Ok(Self::Pack),
                "packAclPermissions" => Ok(Self::PackAclPermissions),
                "packAnalytics" => Ok(Self::PackAnalytics),
                "packAnalyticsSummary" => Ok(Self::PackAnalyticsSummary),
                "packAsset" => Ok(Self::PackAsset),
                "packCategory" => Ok(Self::PackCategory),
                "packConfigurationSchema" => Ok(Self::PackConfigurationSchema),
                "packFeaturedDocs" => Ok(Self::PackFeaturedDocs),
                "packFormulaAnalytics" => Ok(Self::PackFormulaAnalytics),
                "packLog" => Ok(Self::PackLog),
                "packMaker" => Ok(Self::PackMaker),
                "packOauthConfig" => Ok(Self::PackOauthConfig),
                "packRelease" => Ok(Self::PackRelease),
                "packSourceCode" => Ok(Self::PackSourceCode),
                "packSystemConnection" => Ok(Self::PackSystemConnection),
                "packVersion" => Ok(Self::PackVersion),
                "page" => Ok(Self::Page),
                "pageContentExport" => Ok(Self::PageContentExport),
                "pageContentExportStatus" => Ok(Self::PageContentExportStatus),
                "principal" => Ok(Self::Principal),
                "row" => Ok(Self::Row),
                "table" => Ok(Self::Table),
                "user" => Ok(Self::User),
                "workspace" => Ok(Self::Workspace),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for Type {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for Type {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for Type {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        401
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct UnpublishDocResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&UnpublishDocResponse> for UnpublishDocResponse {
        fn from(value: &UnpublishDocResponse) -> Self {
            value.clone()
        }
    }

    ///The result of unpublishing a doc.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The result of unpublishing a doc.",
    ///  "type": "object",
    ///  "additionalProperties": false,
    ///  "x-schema-name": "UnpublishResult"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct UnpublishResult {}
    impl ::std::convert::From<&UnpublishResult> for UnpublishResult {
        fn from(value: &UnpublishResult) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for UnpublishResult {
        fn default() -> Self {
            Self {}
        }
    }

    ///Request to update ACL settings for a doc.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Request to update ACL settings for a doc.",
    ///  "type": "object",
    ///  "properties": {
    ///    "allowCopying": {
    ///      "description": "When true, allows doc viewers to copy the doc.",
    ///      "type": "boolean"
    ///    },
    ///    "allowEditorsToChangePermissions": {
    ///      "description": "When true, allows editors to change doc permissions. When false, only doc owner can change doc permissions.\n",
    ///      "type": "boolean"
    ///    },
    ///    "allowViewersToRequestEditing": {
    ///      "description": "When true, allows doc viewers to request editing
    /// permissions.",
    ///      "type": "boolean"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "UpdateAclSettingsRequest"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct UpdateAclSettingsRequest {
        ///When true, allows doc viewers to copy the doc.
        #[serde(rename = "allowCopying", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub allow_copying: ::std::option::Option<bool>,
        ///When true, allows editors to change doc permissions. When false,
        /// only doc owner can change doc permissions.
        #[serde(rename = "allowEditorsToChangePermissions", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub allow_editors_to_change_permissions: ::std::option::Option<bool>,
        ///When true, allows doc viewers to request editing permissions.
        #[serde(rename = "allowViewersToRequestEditing", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub allow_viewers_to_request_editing: ::std::option::Option<bool>,
    }

    impl ::std::convert::From<&UpdateAclSettingsRequest> for UpdateAclSettingsRequest {
        fn from(value: &UpdateAclSettingsRequest) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for UpdateAclSettingsRequest {
        fn default() -> Self {
            Self {
                allow_copying: Default::default(),
                allow_editors_to_change_permissions: Default::default(),
                allow_viewers_to_request_editing: Default::default(),
            }
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        401
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct UpdateAclSettingsResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&UpdateAclSettingsResponse> for UpdateAclSettingsResponse {
        fn from(value: &UpdateAclSettingsResponse) -> Self {
            value.clone()
        }
    }

    ///Payload for updating the properties of a custom published doc domain.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Payload for updating the properties of a custom
    /// published doc domain.",
    ///  "type": "object",
    ///  "additionalProperties": false,
    ///  "x-schema-name": "UpdateCustomDocDomainRequest"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct UpdateCustomDocDomainRequest {}
    impl ::std::convert::From<&UpdateCustomDocDomainRequest> for UpdateCustomDocDomainRequest {
        fn from(value: &UpdateCustomDocDomainRequest) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for UpdateCustomDocDomainRequest {
        fn default() -> Self {
            Self {}
        }
    }

    ///The result of updating a custom domain for a published doc.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The result of updating a custom domain for a published
    /// doc.",
    ///  "type": "object",
    ///  "additionalProperties": false,
    ///  "x-schema-name": "UpdateCustomDocDomainResponse"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct UpdateCustomDocDomainResponse {}
    impl ::std::convert::From<&UpdateCustomDocDomainResponse> for UpdateCustomDocDomainResponse {
        fn from(value: &UpdateCustomDocDomainResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for UpdateCustomDocDomainResponse {
        fn default() -> Self {
            Self {}
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct UpdateDocResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&UpdateDocResponse> for UpdateDocResponse {
        fn from(value: &UpdateDocResponse) -> Self {
            value.clone()
        }
    }

    ///Payload for updating featured docs for a Pack.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Payload for updating featured docs for a Pack.",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "A list of docs to set as the featured docs for a
    /// Pack.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PackFeaturedDocRequestItem"
    ///      },
    ///      "maxItems": 5,
    ///      "uniqueItems": true
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "UpdatePackFeaturedDocsRequest"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct UpdatePackFeaturedDocsRequest {
        ///A list of docs to set as the featured docs for a Pack.
        pub items: Vec<PackFeaturedDocRequestItem>,
    }

    impl ::std::convert::From<&UpdatePackFeaturedDocsRequest> for UpdatePackFeaturedDocsRequest {
        fn from(value: &UpdatePackFeaturedDocsRequest) -> Self {
            value.clone()
        }
    }

    ///Confirmation of successful Pack featured docs update.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Confirmation of successful Pack featured docs update.",
    ///  "type": "object",
    ///  "additionalProperties": false,
    ///  "x-schema-name": "UpdatePackFeaturedDocsResponse"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct UpdatePackFeaturedDocsResponse {}
    impl ::std::convert::From<&UpdatePackFeaturedDocsResponse> for UpdatePackFeaturedDocsResponse {
        fn from(value: &UpdatePackFeaturedDocsResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for UpdatePackFeaturedDocsResponse {
        fn default() -> Self {
            Self {}
        }
    }

    ///Payload for updating a new Pack release.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Payload for updating a new Pack release.",
    ///  "type": "object",
    ///  "properties": {
    ///    "releaseNotes": {
    ///      "description": "Notes about key features or changes in this release
    /// that the Pack maker wants to communicate to users.",
    ///      "examples": [
    ///        "The first release."
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "UpdatePackReleaseRequest"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct UpdatePackReleaseRequest {
        ///Notes about key features or changes in this release that the Pack
        /// maker wants to communicate to users.
        #[serde(rename = "releaseNotes", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub release_notes: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&UpdatePackReleaseRequest> for UpdatePackReleaseRequest {
        fn from(value: &UpdatePackReleaseRequest) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for UpdatePackReleaseRequest {
        fn default() -> Self {
            Self {
                release_notes: Default::default(),
            }
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "codaDetail": {
    ///      "description": "Detail about why this request was rejected.",
    ///      "type": "object",
    ///      "properties": {
    ///        "validationErrors": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/ValidationError"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    },
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct UpdatePackReleaseResponse {
        #[serde(rename = "codaDetail", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub coda_detail: ::std::option::Option<UpdatePackReleaseResponseCodaDetail>,
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&UpdatePackReleaseResponse> for UpdatePackReleaseResponse {
        fn from(value: &UpdatePackReleaseResponse) -> Self {
            value.clone()
        }
    }

    ///Detail about why this request was rejected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why this request was rejected.",
    ///  "type": "object",
    ///  "properties": {
    ///    "validationErrors": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct UpdatePackReleaseResponseCodaDetail {
        #[serde(rename = "validationErrors", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub validation_errors: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&UpdatePackReleaseResponseCodaDetail> for UpdatePackReleaseResponseCodaDetail {
        fn from(value: &UpdatePackReleaseResponseCodaDetail) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for UpdatePackReleaseResponseCodaDetail {
        fn default() -> Self {
            Self {
                validation_errors: Default::default(),
            }
        }
    }

    ///Payload for updating a Pack.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Payload for updating a Pack.",
    ///  "type": "object",
    ///  "properties": {
    ///    "agentDescription": {
    ///      "description": "A full description for the pack as an agent.",
    ///      "examples": [
    ///        "Chat with a comprehensive tool that can calculate cool geometric
    /// formulas like surface area, volume, and other mathematical operations.
    /// This agent can help with complex calculations and provide detailed
    /// explanations."
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 8192
    ///    },
    ///    "agentImages": {
    ///      "description": "The agent images for the Pack.",
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "assetId",
    ///          "filename"
    ///        ],
    ///        "properties": {
    ///          "assetId": {
    ///            "description": "The asset id of the Pack's agent image,
    /// returned by
    /// [`#PackAssetUploadComplete`](#operation/packAssetUploadComplete)
    /// endpoint.",
    ///            "type": "string"
    ///          },
    ///          "filename": {
    ///            "description": "The filename for the image.",
    ///            "type": "string"
    ///          },
    ///          "mimeType": {
    ///            "description": "The media type of the image being sent.",
    ///            "examples": [
    ///              "image/jpeg"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        },
    ///        "additionalProperties": false
    ///      }
    ///    },
    ///    "agentShortDescription": {
    ///      "description": "A short description for the pack as an agent.",
    ///      "examples": [
    ///        "Chat with a tool that can calculate cool geometric formulas like
    /// surface area."
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 256
    ///    },
    ///    "coverAssetId": {
    ///      "description": "The asset id of the Pack's cover image, returned by
    /// [`#PackAssetUploadComplete`](#operation/packAssetUploadComplete)
    /// endpoint.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "description": {
    ///      "description": "The full description of the Pack.",
    ///      "examples": [
    ///        "This Pack allows users to calculate the surface area and volume
    /// of a few common 3D shapes, like cubes and pyramids."
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 8192
    ///    },
    ///    "exampleImages": {
    ///      "description": "The example images for the Pack.",
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "assetId",
    ///          "filename"
    ///        ],
    ///        "properties": {
    ///          "assetId": {
    ///            "description": "The asset id of the Pack's example image,
    /// returned by
    /// [`#PackAssetUploadComplete`](#operation/packAssetUploadComplete)
    /// endpoint.",
    ///            "type": "string"
    ///          },
    ///          "filename": {
    ///            "description": "The filename for the image.",
    ///            "type": "string"
    ///          },
    ///          "mimeType": {
    ///            "description": "The media type of the image being sent.",
    ///            "examples": [
    ///              "image/jpeg"
    ///            ],
    ///            "type": "string"
    ///          }
    ///        },
    ///        "additionalProperties": false
    ///      }
    ///    },
    ///    "logoAssetId": {
    ///      "description": "The asset id of the Pack's logo, returned by
    /// [`#PackAssetUploadComplete`](#operation/packAssetUploadComplete)
    /// endpoint.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "name": {
    ///      "description": "The name of the Pack.",
    ///      "examples": [
    ///        "Cool Geometry Formulas"
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 128
    ///    },
    ///    "overallRateLimit": {
    ///      "description": "Rate limit in Pack settings.",
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "required": [
    ///        "intervalSeconds",
    ///        "operationsPerInterval"
    ///      ],
    ///      "properties": {
    ///        "intervalSeconds": {
    ///          "description": "The rate limit interval in seconds.",
    ///          "examples": [
    ///            3600
    ///          ],
    ///          "type": "integer",
    ///          "maximum": 86400.0,
    ///          "minimum": 1.0
    ///        },
    ///        "operationsPerInterval": {
    ///          "description": "The maximum number of Pack operations that can
    /// be performed in a given interval.",
    ///          "examples": [
    ///            20
    ///          ],
    ///          "type": "integer",
    ///          "minimum": 0.0
    ///        }
    ///      },
    ///      "additionalProperties": false,
    ///      "x-schema-name": "PackRateLimit"
    ///    },
    ///    "perConnectionRateLimit": {
    ///      "description": "Rate limit in Pack settings.",
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "required": [
    ///        "intervalSeconds",
    ///        "operationsPerInterval"
    ///      ],
    ///      "properties": {
    ///        "intervalSeconds": {
    ///          "description": "The rate limit interval in seconds.",
    ///          "examples": [
    ///            3600
    ///          ],
    ///          "type": "integer",
    ///          "maximum": 86400.0,
    ///          "minimum": 1.0
    ///        },
    ///        "operationsPerInterval": {
    ///          "description": "The maximum number of Pack operations that can
    /// be performed in a given interval.",
    ///          "examples": [
    ///            20
    ///          ],
    ///          "type": "integer",
    ///          "minimum": 0.0
    ///        }
    ///      },
    ///      "additionalProperties": false,
    ///      "x-schema-name": "PackRateLimit"
    ///    },
    ///    "privacyPolicyUrl": {
    ///      "description": "A Privacy Policy URL for the Pack.",
    ///      "type": "string",
    ///      "format": "url",
    ///      "maxLength": 512
    ///    },
    ///    "shortDescription": {
    ///      "description": "A short version of the description of the Pack.",
    ///      "examples": [
    ///        "Calculate cool geometric formulas like surface area."
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 256
    ///    },
    ///    "sourceCodeVisibility": {
    ///      "$ref": "#/components/schemas/PackSourceCodeVisibility"
    ///    },
    ///    "supportEmail": {
    ///      "description": "A contact email for the Pack.",
    ///      "examples": [
    ///        "user@email.com"
    ///      ],
    ///      "type": "string",
    ///      "maxLength": 512
    ///    },
    ///    "termsOfServiceUrl": {
    ///      "description": "A Terms of Service URL for the Pack.",
    ///      "type": "string",
    ///      "format": "url",
    ///      "maxLength": 512
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "UpdatePackRequest"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct UpdatePackRequest {
        ///A full description for the pack as an agent.
        #[serde(rename = "agentDescription", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub agent_description: ::std::option::Option<UpdatePackRequestAgentDescription>,
        ///The agent images for the Pack.
        #[serde(rename = "agentImages", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub agent_images: ::std::option::Option<::std::vec::Vec<UpdatePackRequestAgentImagesItem>>,
        ///A short description for the pack as an agent.
        #[serde(rename = "agentShortDescription", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub agent_short_description: ::std::option::Option<UpdatePackRequestAgentShortDescription>,
        ///The asset id of the Pack's cover image, returned by
        /// [`#PackAssetUploadComplete`](#operation/packAssetUploadComplete)
        /// endpoint.
        #[serde(rename = "coverAssetId", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cover_asset_id: ::std::option::Option<::std::string::String>,
        ///The full description of the Pack.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<UpdatePackRequestDescription>,
        ///The example images for the Pack.
        #[serde(rename = "exampleImages", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub example_images: ::std::option::Option<::std::vec::Vec<UpdatePackRequestExampleImagesItem>>,
        ///The asset id of the Pack's logo, returned by
        /// [`#PackAssetUploadComplete`](#operation/packAssetUploadComplete)
        /// endpoint.
        #[serde(rename = "logoAssetId", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub logo_asset_id: ::std::option::Option<::std::string::String>,
        ///The name of the Pack.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<UpdatePackRequestName>,
        ///Rate limit in Pack settings.
        #[serde(rename = "overallRateLimit", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub overall_rate_limit: ::std::option::Option<UpdatePackRequestOverallRateLimit>,
        ///Rate limit in Pack settings.
        #[serde(rename = "perConnectionRateLimit", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub per_connection_rate_limit: ::std::option::Option<UpdatePackRequestPerConnectionRateLimit>,
        ///A Privacy Policy URL for the Pack.
        #[serde(rename = "privacyPolicyUrl", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub privacy_policy_url: ::std::option::Option<::std::string::String>,
        ///A short version of the description of the Pack.
        #[serde(rename = "shortDescription", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub short_description: ::std::option::Option<UpdatePackRequestShortDescription>,
        #[serde(rename = "sourceCodeVisibility", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub source_code_visibility: ::std::option::Option<PackSourceCodeVisibility>,
        ///A contact email for the Pack.
        #[serde(rename = "supportEmail", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub support_email: ::std::option::Option<UpdatePackRequestSupportEmail>,
        ///A Terms of Service URL for the Pack.
        #[serde(rename = "termsOfServiceUrl", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub terms_of_service_url: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&UpdatePackRequest> for UpdatePackRequest {
        fn from(value: &UpdatePackRequest) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for UpdatePackRequest {
        fn default() -> Self {
            Self {
                agent_description: Default::default(),
                agent_images: Default::default(),
                agent_short_description: Default::default(),
                cover_asset_id: Default::default(),
                description: Default::default(),
                example_images: Default::default(),
                logo_asset_id: Default::default(),
                name: Default::default(),
                overall_rate_limit: Default::default(),
                per_connection_rate_limit: Default::default(),
                privacy_policy_url: Default::default(),
                short_description: Default::default(),
                source_code_visibility: Default::default(),
                support_email: Default::default(),
                terms_of_service_url: Default::default(),
            }
        }
    }

    ///A full description for the pack as an agent.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A full description for the pack as an agent.",
    ///  "examples": [
    ///    "Chat with a comprehensive tool that can calculate cool geometric
    /// formulas like surface area, volume, and other mathematical operations.
    /// This agent can help with complex calculations and provide detailed
    /// explanations."
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 8192
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdatePackRequestAgentDescription(::std::string::String);
    impl ::std::ops::Deref for UpdatePackRequestAgentDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdatePackRequestAgentDescription> for ::std::string::String {
        fn from(value: UpdatePackRequestAgentDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdatePackRequestAgentDescription> for UpdatePackRequestAgentDescription {
        fn from(value: &UpdatePackRequestAgentDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdatePackRequestAgentDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 8192usize {
                return Err("longer than 8192 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdatePackRequestAgentDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for UpdatePackRequestAgentDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for UpdatePackRequestAgentDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdatePackRequestAgentDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///`UpdatePackRequestAgentImagesItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "assetId",
    ///    "filename"
    ///  ],
    ///  "properties": {
    ///    "assetId": {
    ///      "description": "The asset id of the Pack's agent image, returned by
    /// [`#PackAssetUploadComplete`](#operation/packAssetUploadComplete)
    /// endpoint.",
    ///      "type": "string"
    ///    },
    ///    "filename": {
    ///      "description": "The filename for the image.",
    ///      "type": "string"
    ///    },
    ///    "mimeType": {
    ///      "description": "The media type of the image being sent.",
    ///      "examples": [
    ///        "image/jpeg"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct UpdatePackRequestAgentImagesItem {
        ///The asset id of the Pack's agent image, returned by
        /// [`#PackAssetUploadComplete`](#operation/packAssetUploadComplete)
        /// endpoint.
        #[serde(rename = "assetId")]
        pub asset_id: ::std::string::String,
        ///The filename for the image.
        pub filename: ::std::string::String,
        ///The media type of the image being sent.
        #[serde(rename = "mimeType", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mime_type: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&UpdatePackRequestAgentImagesItem> for UpdatePackRequestAgentImagesItem {
        fn from(value: &UpdatePackRequestAgentImagesItem) -> Self {
            value.clone()
        }
    }

    ///A short description for the pack as an agent.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A short description for the pack as an agent.",
    ///  "examples": [
    ///    "Chat with a tool that can calculate cool geometric formulas like
    /// surface area."
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 256
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdatePackRequestAgentShortDescription(::std::string::String);
    impl ::std::ops::Deref for UpdatePackRequestAgentShortDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdatePackRequestAgentShortDescription> for ::std::string::String {
        fn from(value: UpdatePackRequestAgentShortDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdatePackRequestAgentShortDescription> for UpdatePackRequestAgentShortDescription {
        fn from(value: &UpdatePackRequestAgentShortDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdatePackRequestAgentShortDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 256usize {
                return Err("longer than 256 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdatePackRequestAgentShortDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for UpdatePackRequestAgentShortDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for UpdatePackRequestAgentShortDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdatePackRequestAgentShortDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///The full description of the Pack.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The full description of the Pack.",
    ///  "examples": [
    ///    "This Pack allows users to calculate the surface area and volume of a
    /// few common 3D shapes, like cubes and pyramids."
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 8192
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdatePackRequestDescription(::std::string::String);
    impl ::std::ops::Deref for UpdatePackRequestDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdatePackRequestDescription> for ::std::string::String {
        fn from(value: UpdatePackRequestDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdatePackRequestDescription> for UpdatePackRequestDescription {
        fn from(value: &UpdatePackRequestDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdatePackRequestDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 8192usize {
                return Err("longer than 8192 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdatePackRequestDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for UpdatePackRequestDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for UpdatePackRequestDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdatePackRequestDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///`UpdatePackRequestExampleImagesItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "assetId",
    ///    "filename"
    ///  ],
    ///  "properties": {
    ///    "assetId": {
    ///      "description": "The asset id of the Pack's example image, returned
    /// by [`#PackAssetUploadComplete`](#operation/packAssetUploadComplete)
    /// endpoint.",
    ///      "type": "string"
    ///    },
    ///    "filename": {
    ///      "description": "The filename for the image.",
    ///      "type": "string"
    ///    },
    ///    "mimeType": {
    ///      "description": "The media type of the image being sent.",
    ///      "examples": [
    ///        "image/jpeg"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct UpdatePackRequestExampleImagesItem {
        ///The asset id of the Pack's example image, returned by
        /// [`#PackAssetUploadComplete`](#operation/packAssetUploadComplete)
        /// endpoint.
        #[serde(rename = "assetId")]
        pub asset_id: ::std::string::String,
        ///The filename for the image.
        pub filename: ::std::string::String,
        ///The media type of the image being sent.
        #[serde(rename = "mimeType", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mime_type: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&UpdatePackRequestExampleImagesItem> for UpdatePackRequestExampleImagesItem {
        fn from(value: &UpdatePackRequestExampleImagesItem) -> Self {
            value.clone()
        }
    }

    ///The name of the Pack.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the Pack.",
    ///  "examples": [
    ///    "Cool Geometry Formulas"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 128
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdatePackRequestName(::std::string::String);
    impl ::std::ops::Deref for UpdatePackRequestName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdatePackRequestName> for ::std::string::String {
        fn from(value: UpdatePackRequestName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdatePackRequestName> for UpdatePackRequestName {
        fn from(value: &UpdatePackRequestName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdatePackRequestName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 128usize {
                return Err("longer than 128 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdatePackRequestName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for UpdatePackRequestName {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for UpdatePackRequestName {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdatePackRequestName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///Rate limit in Pack settings.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Rate limit in Pack settings.",
    ///  "type": "object",
    ///  "required": [
    ///    "intervalSeconds",
    ///    "operationsPerInterval"
    ///  ],
    ///  "properties": {
    ///    "intervalSeconds": {
    ///      "description": "The rate limit interval in seconds.",
    ///      "examples": [
    ///        3600
    ///      ],
    ///      "type": "integer",
    ///      "maximum": 86400.0,
    ///      "minimum": 1.0
    ///    },
    ///    "operationsPerInterval": {
    ///      "description": "The maximum number of Pack operations that can be
    /// performed in a given interval.",
    ///      "examples": [
    ///        20
    ///      ],
    ///      "type": "integer",
    ///      "minimum": 0.0
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackRateLimit"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct UpdatePackRequestOverallRateLimit {
        ///The rate limit interval in seconds.
        #[serde(rename = "intervalSeconds")]
        pub interval_seconds: ::std::num::NonZeroU64,
        ///The maximum number of Pack operations that can be performed in a
        /// given interval.
        #[serde(rename = "operationsPerInterval")]
        pub operations_per_interval: u64,
    }

    impl ::std::convert::From<&UpdatePackRequestOverallRateLimit> for UpdatePackRequestOverallRateLimit {
        fn from(value: &UpdatePackRequestOverallRateLimit) -> Self {
            value.clone()
        }
    }

    ///Rate limit in Pack settings.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Rate limit in Pack settings.",
    ///  "type": "object",
    ///  "required": [
    ///    "intervalSeconds",
    ///    "operationsPerInterval"
    ///  ],
    ///  "properties": {
    ///    "intervalSeconds": {
    ///      "description": "The rate limit interval in seconds.",
    ///      "examples": [
    ///        3600
    ///      ],
    ///      "type": "integer",
    ///      "maximum": 86400.0,
    ///      "minimum": 1.0
    ///    },
    ///    "operationsPerInterval": {
    ///      "description": "The maximum number of Pack operations that can be
    /// performed in a given interval.",
    ///      "examples": [
    ///        20
    ///      ],
    ///      "type": "integer",
    ///      "minimum": 0.0
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "PackRateLimit"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct UpdatePackRequestPerConnectionRateLimit {
        ///The rate limit interval in seconds.
        #[serde(rename = "intervalSeconds")]
        pub interval_seconds: ::std::num::NonZeroU64,
        ///The maximum number of Pack operations that can be performed in a
        /// given interval.
        #[serde(rename = "operationsPerInterval")]
        pub operations_per_interval: u64,
    }

    impl ::std::convert::From<&UpdatePackRequestPerConnectionRateLimit> for UpdatePackRequestPerConnectionRateLimit {
        fn from(value: &UpdatePackRequestPerConnectionRateLimit) -> Self {
            value.clone()
        }
    }

    ///A short version of the description of the Pack.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A short version of the description of the Pack.",
    ///  "examples": [
    ///    "Calculate cool geometric formulas like surface area."
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 256
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdatePackRequestShortDescription(::std::string::String);
    impl ::std::ops::Deref for UpdatePackRequestShortDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdatePackRequestShortDescription> for ::std::string::String {
        fn from(value: UpdatePackRequestShortDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdatePackRequestShortDescription> for UpdatePackRequestShortDescription {
        fn from(value: &UpdatePackRequestShortDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdatePackRequestShortDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 256usize {
                return Err("longer than 256 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdatePackRequestShortDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for UpdatePackRequestShortDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for UpdatePackRequestShortDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdatePackRequestShortDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///A contact email for the Pack.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A contact email for the Pack.",
    ///  "examples": [
    ///    "user@email.com"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 512
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdatePackRequestSupportEmail(::std::string::String);
    impl ::std::ops::Deref for UpdatePackRequestSupportEmail {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdatePackRequestSupportEmail> for ::std::string::String {
        fn from(value: UpdatePackRequestSupportEmail) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdatePackRequestSupportEmail> for UpdatePackRequestSupportEmail {
        fn from(value: &UpdatePackRequestSupportEmail) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdatePackRequestSupportEmail {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 512usize {
                return Err("longer than 512 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdatePackRequestSupportEmail {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for UpdatePackRequestSupportEmail {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for UpdatePackRequestSupportEmail {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdatePackRequestSupportEmail {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct UpdatePackResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&UpdatePackResponse> for UpdatePackResponse {
        fn from(value: &UpdatePackResponse) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct UpdatePageResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&UpdatePageResponse> for UpdatePageResponse {
        fn from(value: &UpdatePageResponse) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct UpdateRowResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&UpdateRowResponse> for UpdateRowResponse {
        fn from(value: &UpdateRowResponse) -> Self {
            value.clone()
        }
    }

    ///Payload for a Pack asset upload.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Payload for a Pack asset upload.",
    ///  "type": "object",
    ///  "required": [
    ///    "filename",
    ///    "imageHash",
    ///    "mimeType",
    ///    "packAssetType"
    ///  ],
    ///  "properties": {
    ///    "filename": {
    ///      "examples": [
    ///        "image.jpg"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "imageHash": {
    ///      "description": "The SHA-256 hash of the image to be uploaded.",
    ///      "examples": [
    ///        "f0e4c2f76c58916ec258f246851bea091d14d4247a2fc3e18694461b1816e13b"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "mimeType": {
    ///      "description": "The media type of the image being sent.",
    ///      "examples": [
    ///        "image/jpeg"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "packAssetType": {
    ///      "$ref": "#/components/schemas/PackAssetType"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "UploadPackAssetRequest"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct UploadPackAssetRequest {
        pub filename: ::std::string::String,
        ///The SHA-256 hash of the image to be uploaded.
        #[serde(rename = "imageHash")]
        pub image_hash: ::std::string::String,
        ///The media type of the image being sent.
        #[serde(rename = "mimeType")]
        pub mime_type: ::std::string::String,
        #[serde(rename = "packAssetType")]
        pub pack_asset_type: PackAssetType,
    }

    impl ::std::convert::From<&UploadPackAssetRequest> for UploadPackAssetRequest {
        fn from(value: &UploadPackAssetRequest) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "codaDetail": {
    ///      "description": "Detail about why this request was rejected.",
    ///      "type": "object",
    ///      "properties": {
    ///        "validationErrors": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/ValidationError"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    },
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct UploadPackAssetResponse {
        #[serde(rename = "codaDetail", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub coda_detail: ::std::option::Option<UploadPackAssetResponseCodaDetail>,
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&UploadPackAssetResponse> for UploadPackAssetResponse {
        fn from(value: &UploadPackAssetResponse) -> Self {
            value.clone()
        }
    }

    ///Detail about why this request was rejected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why this request was rejected.",
    ///  "type": "object",
    ///  "properties": {
    ///    "validationErrors": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct UploadPackAssetResponseCodaDetail {
        #[serde(rename = "validationErrors", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub validation_errors: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&UploadPackAssetResponseCodaDetail> for UploadPackAssetResponseCodaDetail {
        fn from(value: &UploadPackAssetResponseCodaDetail) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for UploadPackAssetResponseCodaDetail {
        fn default() -> Self {
            Self {
                validation_errors: Default::default(),
            }
        }
    }

    ///Payload for a Pack asset upload.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Payload for a Pack asset upload.",
    ///  "type": "object",
    ///  "required": [
    ///    "filename",
    ///    "payloadHash"
    ///  ],
    ///  "properties": {
    ///    "filename": {
    ///      "examples": [
    ///        "main.ts"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "packVersion": {
    ///      "examples": [
    ///        "1.0.0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "payloadHash": {
    ///      "description": "The SHA-256 hash of the image to be uploaded.",
    ///      "examples": [
    ///        "f0e4c2f76c58916ec258f246851bea091d14d4247a2fc3e18694461b1816e13b"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "UploadPackSourceCodeRequest"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct UploadPackSourceCodeRequest {
        pub filename: ::std::string::String,
        #[serde(rename = "packVersion", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pack_version: ::std::option::Option<::std::string::String>,
        ///The SHA-256 hash of the image to be uploaded.
        #[serde(rename = "payloadHash")]
        pub payload_hash: ::std::string::String,
    }

    impl ::std::convert::From<&UploadPackSourceCodeRequest> for UploadPackSourceCodeRequest {
        fn from(value: &UploadPackSourceCodeRequest) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "codaDetail": {
    ///      "description": "Detail about why this request was rejected.",
    ///      "type": "object",
    ///      "properties": {
    ///        "validationErrors": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/ValidationError"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    },
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct UploadPackSourceCodeResponse {
        #[serde(rename = "codaDetail", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub coda_detail: ::std::option::Option<UploadPackSourceCodeResponseCodaDetail>,
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&UploadPackSourceCodeResponse> for UploadPackSourceCodeResponse {
        fn from(value: &UploadPackSourceCodeResponse) -> Self {
            value.clone()
        }
    }

    ///Detail about why this request was rejected.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why this request was rejected.",
    ///  "type": "object",
    ///  "properties": {
    ///    "validationErrors": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidationError"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct UploadPackSourceCodeResponseCodaDetail {
        #[serde(rename = "validationErrors", default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub validation_errors: ::std::vec::Vec<ValidationError>,
    }

    impl ::std::convert::From<&UploadPackSourceCodeResponseCodaDetail> for UploadPackSourceCodeResponseCodaDetail {
        fn from(value: &UploadPackSourceCodeResponseCodaDetail) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for UploadPackSourceCodeResponseCodaDetail {
        fn default() -> Self {
            Self {
                validation_errors: Default::default(),
            }
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        400
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Bad Request"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct UpsertRowsResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&UpsertRowsResponse> for UpsertRowsResponse {
        fn from(value: &UpsertRowsResponse) -> Self {
            value.clone()
        }
    }

    ///`UrlValue`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A named hyperlink to an arbitrary url.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/LinkedDataObject"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "@type",
    ///        "url"
    ///      ],
    ///      "properties": {
    ///        "@type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "WebPage"
    ///          ],
    ///          "x-tsType": "LinkedDataType.WebPage"
    ///        },
    ///        "name": {
    ///          "description": "The user-visible text of the hyperlink.",
    ///          "examples": [
    ///            "Click me"
    ///          ],
    ///          "type": "string"
    ///        },
    ///        "url": {
    ///          "description": "The url of the hyperlink.",
    ///          "examples": [
    ///            "https://coda.io"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  ],
    ///  "x-schema-name": "UrlValue"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(deny_unknown_fields)]
    pub enum UrlValue {}
    impl ::std::convert::From<&Self> for UrlValue {
        fn from(value: &UrlValue) -> Self {
            value.clone()
        }
    }

    ///Info about the user.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Info about the user.",
    ///  "type": "object",
    ///  "required": [
    ///    "href",
    ///    "loginId",
    ///    "name",
    ///    "scoped",
    ///    "tokenName",
    ///    "type",
    ///    "workspace"
    ///  ],
    ///  "properties": {
    ///    "href": {
    ///      "description": "API link to the user.",
    ///      "examples": [
    ///        "https://coda.io/apis/v1beta/whoami"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "loginId": {
    ///      "description": "Email address of the user.",
    ///      "examples": [
    ///        "user@example.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "Name of the user.",
    ///      "examples": [
    ///        "John Doe"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "pictureLink": {
    ///      "description": "Browser-friendly link to the user's avatar image.",
    ///      "examples": [
    ///        "https://cdn.coda.io/avatars/default_avatar.png"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "scoped": {
    ///      "description": "True if the token used to make this request has
    /// restricted/scoped access to the API.",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "tokenName": {
    ///      "description": "Returns the name of the token used for this
    /// request.",
    ///      "examples": [
    ///        "My API token"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "description": "The type of this resource.",
    ///      "type": "string",
    ///      "enum": [
    ///        "user"
    ///      ],
    ///      "x-tsType": "Type.User"
    ///    },
    ///    "workspace": {
    ///      "$ref": "#/components/schemas/WorkspaceReference"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "User"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct User {
        ///API link to the user.
        pub href: ::std::string::String,
        ///Email address of the user.
        #[serde(rename = "loginId")]
        pub login_id: ::std::string::String,
        ///Name of the user.
        pub name: ::std::string::String,
        ///Browser-friendly link to the user's avatar image.
        #[serde(rename = "pictureLink", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub picture_link: ::std::option::Option<::std::string::String>,
        ///True if the token used to make this request has restricted/scoped
        /// access to the API.
        pub scoped: bool,
        ///Returns the name of the token used for this request.
        #[serde(rename = "tokenName")]
        pub token_name: ::std::string::String,
        ///The type of this resource.
        #[serde(rename = "type")]
        pub type_: UserType,
        pub workspace: WorkspaceReference,
    }

    impl ::std::convert::From<&User> for User {
        fn from(value: &User) -> Self {
            value.clone()
        }
    }

    ///Summary about the user.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Summary about the user.",
    ///  "type": "object",
    ///  "required": [
    ///    "loginId",
    ///    "name",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "loginId": {
    ///      "description": "Email address of the user.",
    ///      "examples": [
    ///        "user@example.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "Name of the user.",
    ///      "examples": [
    ///        "John Doe"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "pictureLink": {
    ///      "description": "Browser-friendly link to the user's avatar image.",
    ///      "examples": [
    ///        "https://cdn.coda.io/avatars/default_avatar.png"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "type": {
    ///      "description": "The type of this resource.",
    ///      "type": "string",
    ///      "enum": [
    ///        "user"
    ///      ],
    ///      "x-tsType": "Type.User"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "UserSummary"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct UserSummary {
        ///Email address of the user.
        #[serde(rename = "loginId")]
        pub login_id: ::std::string::String,
        ///Name of the user.
        pub name: ::std::string::String,
        ///Browser-friendly link to the user's avatar image.
        #[serde(rename = "pictureLink", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub picture_link: ::std::option::Option<::std::string::String>,
        ///The type of this resource.
        #[serde(rename = "type")]
        pub type_: UserSummaryType,
    }

    impl ::std::convert::From<&UserSummary> for UserSummary {
        fn from(value: &UserSummary) -> Self {
            value.clone()
        }
    }

    ///The type of this resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of this resource.",
    ///  "type": "string",
    ///  "enum": [
    ///    "user"
    ///  ],
    ///  "x-tsType": "Type.User"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum UserSummaryType {
        #[serde(rename = "user")]
        User,
    }

    impl ::std::convert::From<&Self> for UserSummaryType {
        fn from(value: &UserSummaryType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for UserSummaryType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::User => f.write_str("user"),
            }
        }
    }

    impl ::std::str::FromStr for UserSummaryType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "user" => Ok(Self::User),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for UserSummaryType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for UserSummaryType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for UserSummaryType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The type of this resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of this resource.",
    ///  "type": "string",
    ///  "enum": [
    ///    "user"
    ///  ],
    ///  "x-tsType": "Type.User"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum UserType {
        #[serde(rename = "user")]
        User,
    }

    impl ::std::convert::From<&Self> for UserType {
        fn from(value: &UserType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for UserType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::User => f.write_str("user"),
            }
        }
    }

    impl ::std::str::FromStr for UserType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "user" => Ok(Self::User),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for UserType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for UserType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for UserType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Detail about why a particular field failed request validation.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Detail about why a particular field failed request
    /// validation.",
    ///  "type": "object",
    ///  "required": [
    ///    "message",
    ///    "path"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "An error message.",
    ///      "examples": [
    ///        "Expected a string but got a number"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "path": {
    ///      "description": "A path indicating the affected field, in OGNL
    /// notation.",
    ///      "examples": [
    ///        "parent.child[0]"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "ValidationError"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ValidationError {
        ///An error message.
        pub message: ::std::string::String,
        ///A path indicating the affected field, in OGNL notation.
        pub path: ::std::string::String,
    }

    impl ::std::convert::From<&ValidationError> for ValidationError {
        fn from(value: &ValidationError) -> Self {
            value.clone()
        }
    }

    ///A Coda result or entity expressed as a primitive type, or array of
    /// primitive types.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A Coda result or entity expressed as a primitive type,
    /// or array of primitive types.",
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ScalarValue"
    ///    },
    ///    {
    ///      "type": "array",
    ///      "items": {
    ///        "oneOf": [
    ///          {
    ///            "$ref": "#/components/schemas/ScalarValue"
    ///          },
    ///          {
    ///            "type": "array",
    ///            "items": {
    ///              "$ref": "#/components/schemas/ScalarValue"
    ///            }
    ///          }
    ///        ]
    ///      }
    ///    }
    ///  ],
    ///  "additionalProperties": false,
    ///  "x-schema-name": "Value"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum Value {
        Variant0(ValueVariant0),
        Variant1(::std::vec::Vec<ValueVariant1Item>),
    }

    impl ::std::convert::From<&Self> for Value {
        fn from(value: &Value) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<ValueVariant0> for Value {
        fn from(value: ValueVariant0) -> Self {
            Self::Variant0(value)
        }
    }

    impl ::std::convert::From<::std::vec::Vec<ValueVariant1Item>> for Value {
        fn from(value: ::std::vec::Vec<ValueVariant1Item>) -> Self {
            Self::Variant1(value)
        }
    }

    ///The format that cell values are returned as.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The format that cell values are returned as.",
    ///  "type": "string",
    ///  "enum": [
    ///    "simple",
    ///    "simpleWithArrays",
    ///    "rich"
    ///  ],
    ///  "x-schema-name": "ValueFormat",
    ///  "x-tsEnumNames": [
    ///    "Simple",
    ///    "SimpleWithArrays",
    ///    "Rich"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum ValueFormat {
        #[serde(rename = "simple")]
        Simple,
        #[serde(rename = "simpleWithArrays")]
        SimpleWithArrays,
        #[serde(rename = "rich")]
        Rich,
    }

    impl ::std::convert::From<&Self> for ValueFormat {
        fn from(value: &ValueFormat) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ValueFormat {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Simple => f.write_str("simple"),
                Self::SimpleWithArrays => f.write_str("simpleWithArrays"),
                Self::Rich => f.write_str("rich"),
            }
        }
    }

    impl ::std::str::FromStr for ValueFormat {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "simple" => Ok(Self::Simple),
                "simpleWithArrays" => Ok(Self::SimpleWithArrays),
                "rich" => Ok(Self::Rich),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ValueFormat {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ValueFormat {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ValueFormat {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`ValueVariant0`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "additionalProperties": false,
    ///      "x-schema-name": "Value"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ScalarValue"
    ///    },
    ///    {
    ///      "not": {
    ///        "type": "array",
    ///        "items": {
    ///          "oneOf": [
    ///            {
    ///              "$ref": "#/components/schemas/ScalarValue"
    ///            },
    ///            {
    ///              "type": "array",
    ///              "items": {
    ///                "$ref": "#/components/schemas/ScalarValue"
    ///              }
    ///            }
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum ValueVariant0 {
        Variant0(::std::string::String),
        Variant1(f64),
        Variant2(bool),
    }

    impl ::std::convert::From<&Self> for ValueVariant0 {
        fn from(value: &ValueVariant0) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ValueVariant0 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
                Self::Variant2(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<f64> for ValueVariant0 {
        fn from(value: f64) -> Self {
            Self::Variant1(value)
        }
    }

    impl ::std::convert::From<bool> for ValueVariant0 {
        fn from(value: bool) -> Self {
            Self::Variant2(value)
        }
    }

    ///`ValueVariant1Item`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ScalarValue"
    ///    },
    ///    {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ScalarValue"
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum ValueVariant1Item {
        Variant0(ScalarValue),
        Variant1(::std::vec::Vec<ScalarValue>),
    }

    impl ::std::convert::From<&Self> for ValueVariant1Item {
        fn from(value: &ValueVariant1Item) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<ScalarValue> for ValueVariant1Item {
        fn from(value: ScalarValue) -> Self {
            Self::Variant0(value)
        }
    }

    impl ::std::convert::From<::std::vec::Vec<ScalarValue>> for ValueVariant1Item {
        fn from(value: ::std::vec::Vec<ScalarValue>) -> Self {
            Self::Variant1(value)
        }
    }

    ///Payload for webhook trigger
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Payload for webhook trigger",
    ///  "examples": [
    ///    {
    ///      "message": "The doc that brings words, data, & teams together."
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "additionalProperties": true,
    ///  "x-schema-name": "WebhookTriggerPayload"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct WebhookTriggerPayload(pub ::serde_json::Map<::std::string::String, ::serde_json::Value>);
    impl ::std::ops::Deref for WebhookTriggerPayload {
        type Target = ::serde_json::Map<::std::string::String, ::serde_json::Value>;
        fn deref(&self) -> &::serde_json::Map<::std::string::String, ::serde_json::Value> {
            &self.0
        }
    }

    impl ::std::convert::From<WebhookTriggerPayload> for ::serde_json::Map<::std::string::String, ::serde_json::Value> {
        fn from(value: WebhookTriggerPayload) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&WebhookTriggerPayload> for WebhookTriggerPayload {
        fn from(value: &WebhookTriggerPayload) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::serde_json::Map<::std::string::String, ::serde_json::Value>> for WebhookTriggerPayload {
        fn from(value: ::serde_json::Map<::std::string::String, ::serde_json::Value>) -> Self {
            Self(value)
        }
    }

    ///`WebhookTriggerResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The result of triggering a webhook",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/DocumentMutateResponse"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "additionalProperties": false
    ///    }
    ///  ],
    ///  "x-schema-name": "WebhookTriggerResult"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(deny_unknown_fields)]
    pub enum WebhookTriggerResult {}
    impl ::std::convert::From<&Self> for WebhookTriggerResult {
        fn from(value: &WebhookTriggerResult) -> Self {
            value.clone()
        }
    }

    ///An HTTP error resulting from an unsuccessful request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An HTTP error resulting from an unsuccessful request.",
    ///  "required": [
    ///    "message",
    ///    "statusCode",
    ///    "statusMessage"
    ///  ],
    ///  "properties": {
    ///    "message": {
    ///      "description": "Any additional context on the error, or the same as
    /// `statusMessage` otherwise.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "statusCode": {
    ///      "description": "HTTP status code of the error.",
    ///      "examples": [
    ///        401
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "statusMessage": {
    ///      "description": "HTTP status message of the error.",
    ///      "examples": [
    ///        "Unauthorized"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct WhoamiResponse {
        ///Any additional context on the error, or the same as `statusMessage`
        /// otherwise.
        pub message: ::std::string::String,
        #[serde(rename = "statusCode")]
        pub status_code: f64,
        ///HTTP status message of the error.
        #[serde(rename = "statusMessage")]
        pub status_message: ::std::string::String,
    }

    impl ::std::convert::From<&WhoamiResponse> for WhoamiResponse {
        fn from(value: &WhoamiResponse) -> Self {
            value.clone()
        }
    }

    ///Metadata about a Coda workspace.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Metadata about a Coda workspace.",
    ///  "type": "object",
    ///  "required": [
    ///    "browserLink",
    ///    "id",
    ///    "name",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "browserLink": {
    ///      "description": "Browser-friendly link to the Coda workspace.",
    ///      "examples": [
    ///        "https://coda.io/docs?workspaceId=ws-1Ab234"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "description": {
    ///      "description": "Description of the workspace.",
    ///      "examples": [
    ///        "The central place for our team's knowledge."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "ID of the Coda workspace.",
    ///      "examples": [
    ///        "ws-1Ab234"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "Name of the workspace.",
    ///      "examples": [
    ///        "coda.io"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "organizationId": {
    ///      "description": "ID of the organization bound to this workspace, if
    /// any.",
    ///      "examples": [
    ///        "org-2Bc456"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "description": "The type of this resource.",
    ///      "type": "string",
    ///      "enum": [
    ///        "workspace"
    ///      ],
    ///      "x-tsType": "Type.Workspace"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "Workspace"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct Workspace {
        ///Browser-friendly link to the Coda workspace.
        #[serde(rename = "browserLink")]
        pub browser_link: ::std::string::String,
        ///Description of the workspace.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        ///ID of the Coda workspace.
        pub id: ::std::string::String,
        ///Name of the workspace.
        pub name: ::std::string::String,
        ///ID of the organization bound to this workspace, if any.
        #[serde(rename = "organizationId", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub organization_id: ::std::option::Option<::std::string::String>,
        ///The type of this resource.
        #[serde(rename = "type")]
        pub type_: WorkspaceType,
    }

    impl ::std::convert::From<&Workspace> for Workspace {
        fn from(value: &Workspace) -> Self {
            value.clone()
        }
    }

    ///Response for listing workspace users.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Response for listing workspace users.",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/WorkspaceUser"
    ///      }
    ///    },
    ///    "nextPageLink": {
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/nextPageLink"
    ///        },
    ///        {
    ///          "examples": [
    ///            "https://coda.io/apis/v1/workspaces/{workspaceId}/users?pageToken=xyz"
    ///          ],
    ///          "type": "string"
    ///        }
    ///      ]
    ///    },
    ///    "nextPageToken": {
    ///      "$ref": "#/components/schemas/nextPageToken"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "WorkspaceMembersList"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct WorkspaceMembersList {
        pub items: ::std::vec::Vec<WorkspaceUser>,
        #[serde(rename = "nextPageLink", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_link: ::std::option::Option<NextPageLink>,
        #[serde(rename = "nextPageToken", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page_token: ::std::option::Option<NextPageToken>,
    }

    impl ::std::convert::From<&WorkspaceMembersList> for WorkspaceMembersList {
        fn from(value: &WorkspaceMembersList) -> Self {
            value.clone()
        }
    }

    ///`WorkspacePrincipal`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "type",
    ///    "workspaceId"
    ///  ],
    ///  "properties": {
    ///    "type": {
    ///      "description": "The type of this principal.",
    ///      "type": "string",
    ///      "enum": [
    ///        "workspace"
    ///      ],
    ///      "x-tsType": "PrincipalType.Workspace"
    ///    },
    ///    "workspaceId": {
    ///      "description": "WorkspaceId for the principal.",
    ///      "examples": [
    ///        "ws-sdfmsdf9"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct WorkspacePrincipal {
        ///The type of this principal.
        #[serde(rename = "type")]
        pub type_: WorkspacePrincipalType,
        ///WorkspaceId for the principal.
        #[serde(rename = "workspaceId")]
        pub workspace_id: ::std::string::String,
    }

    impl ::std::convert::From<&WorkspacePrincipal> for WorkspacePrincipal {
        fn from(value: &WorkspacePrincipal) -> Self {
            value.clone()
        }
    }

    ///The type of this principal.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of this principal.",
    ///  "type": "string",
    ///  "enum": [
    ///    "workspace"
    ///  ],
    ///  "x-tsType": "PrincipalType.Workspace"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum WorkspacePrincipalType {
        #[serde(rename = "workspace")]
        Workspace,
    }

    impl ::std::convert::From<&Self> for WorkspacePrincipalType {
        fn from(value: &WorkspacePrincipalType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for WorkspacePrincipalType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Workspace => f.write_str("workspace"),
            }
        }
    }

    impl ::std::str::FromStr for WorkspacePrincipalType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "workspace" => Ok(Self::Workspace),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for WorkspacePrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for WorkspacePrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for WorkspacePrincipalType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Reference to a Coda workspace.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Reference to a Coda workspace.",
    ///  "type": "object",
    ///  "required": [
    ///    "browserLink",
    ///    "id",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "browserLink": {
    ///      "description": "Browser-friendly link to the Coda workspace.",
    ///      "examples": [
    ///        "https://coda.io/docs?workspaceId=ws-1Ab234"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "id": {
    ///      "description": "ID of the Coda workspace.",
    ///      "examples": [
    ///        "ws-1Ab234"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "Name of the workspace; included if the user has
    /// access to the workspace.",
    ///      "examples": [
    ///        "My workspace"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "organizationId": {
    ///      "description": "ID of the organization bound to this workspace, if
    /// any.",
    ///      "examples": [
    ///        "org-2Bc456"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "description": "The type of this resource.",
    ///      "type": "string",
    ///      "enum": [
    ///        "workspace"
    ///      ],
    ///      "x-tsType": "Type.Workspace"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "WorkspaceReference"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct WorkspaceReference {
        ///Browser-friendly link to the Coda workspace.
        #[serde(rename = "browserLink")]
        pub browser_link: ::std::string::String,
        ///ID of the Coda workspace.
        pub id: ::std::string::String,
        ///Name of the workspace; included if the user has access to the
        /// workspace.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        ///ID of the organization bound to this workspace, if any.
        #[serde(rename = "organizationId", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub organization_id: ::std::option::Option<::std::string::String>,
        ///The type of this resource.
        #[serde(rename = "type")]
        pub type_: WorkspaceReferenceType,
    }

    impl ::std::convert::From<&WorkspaceReference> for WorkspaceReference {
        fn from(value: &WorkspaceReference) -> Self {
            value.clone()
        }
    }

    ///The type of this resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of this resource.",
    ///  "type": "string",
    ///  "enum": [
    ///    "workspace"
    ///  ],
    ///  "x-tsType": "Type.Workspace"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum WorkspaceReferenceType {
        #[serde(rename = "workspace")]
        Workspace,
    }

    impl ::std::convert::From<&Self> for WorkspaceReferenceType {
        fn from(value: &WorkspaceReferenceType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for WorkspaceReferenceType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Workspace => f.write_str("workspace"),
            }
        }
    }

    impl ::std::str::FromStr for WorkspaceReferenceType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "workspace" => Ok(Self::Workspace),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for WorkspaceReferenceType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for WorkspaceReferenceType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for WorkspaceReferenceType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Metadata for workspace role activity.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Metadata for workspace role activity.",
    ///  "type": "object",
    ///  "required": [
    ///    "activeAdminCount",
    ///    "activeDocMakerCount",
    ///    "activeEditorCount",
    ///    "inactiveAdminCount",
    ///    "inactiveDocMakerCount",
    ///    "inactiveEditorCount",
    ///    "month"
    ///  ],
    ///  "properties": {
    ///    "activeAdminCount": {
    ///      "description": "Number of active Admins.",
    ///      "examples": [
    ///        2
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "activeDocMakerCount": {
    ///      "description": "Number of active Doc Makers.",
    ///      "examples": [
    ///        2
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "activeEditorCount": {
    ///      "description": "Number of active Editors.",
    ///      "examples": [
    ///        2
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "inactiveAdminCount": {
    ///      "description": "Number of inactive Admins.",
    ///      "examples": [
    ///        2
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "inactiveDocMakerCount": {
    ///      "description": "Number of inactive Doc Makers.",
    ///      "examples": [
    ///        2
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "inactiveEditorCount": {
    ///      "description": "Number of inactive Editor users.",
    ///      "examples": [
    ///        2
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "month": {
    ///      "description": "Month corresponding to the data.",
    ///      "examples": [
    ///        "2020-09-15"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "WorkspaceRoleActivity"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct WorkspaceRoleActivity {
        #[serde(rename = "activeAdminCount")]
        pub active_admin_count: f64,
        #[serde(rename = "activeDocMakerCount")]
        pub active_doc_maker_count: f64,
        #[serde(rename = "activeEditorCount")]
        pub active_editor_count: f64,
        #[serde(rename = "inactiveAdminCount")]
        pub inactive_admin_count: f64,
        #[serde(rename = "inactiveDocMakerCount")]
        pub inactive_doc_maker_count: f64,
        #[serde(rename = "inactiveEditorCount")]
        pub inactive_editor_count: f64,
        ///Month corresponding to the data.
        pub month: ::std::string::String,
    }

    impl ::std::convert::From<&WorkspaceRoleActivity> for WorkspaceRoleActivity {
        fn from(value: &WorkspaceRoleActivity) -> Self {
            value.clone()
        }
    }

    ///The type of this resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of this resource.",
    ///  "type": "string",
    ///  "enum": [
    ///    "workspace"
    ///  ],
    ///  "x-tsType": "Type.Workspace"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum WorkspaceType {
        #[serde(rename = "workspace")]
        Workspace,
    }

    impl ::std::convert::From<&Self> for WorkspaceType {
        fn from(value: &WorkspaceType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for WorkspaceType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Workspace => f.write_str("workspace"),
            }
        }
    }

    impl ::std::str::FromStr for WorkspaceType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "workspace" => Ok(Self::Workspace),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for WorkspaceType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for WorkspaceType {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for WorkspaceType {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Metadata of a workspace user.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Metadata of a workspace user.",
    ///  "type": "object",
    ///  "required": [
    ///    "email",
    ///    "name",
    ///    "registeredAt",
    ///    "role"
    ///  ],
    ///  "properties": {
    ///    "docCollaboratorCount": {
    ///      "description": "Number of collaborators that have interacted with
    /// docs owned by the user in the last 90 days.",
    ///      "examples": [
    ///        2
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "docsLastActiveAt": {
    ///      "description": "Date when anyone last accessed a doc that the user
    /// owns in this workspace.",
    ///      "examples": [
    ///        "2018-04-11"
    ///      ],
    ///      "type": "string",
    ///      "format": "date"
    ///    },
    ///    "email": {
    ///      "description": "Email of the user.",
    ///      "examples": [
    ///        "hello@coda.io"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "lastActiveAt": {
    ///      "description": "Date when the user last took an action in any
    /// workspace.",
    ///      "examples": [
    ///        "2018-04-11"
    ///      ],
    ///      "type": "string",
    ///      "format": "date"
    ///    },
    ///    "name": {
    ///      "description": "Name of the user.",
    ///      "examples": [
    ///        "Sally Jane"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "ownedDocs": {
    ///      "description": "Number of docs the user owns in this workspace.",
    ///      "examples": [
    ///        2
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "pictureUrl": {
    ///      "description": "Picture url of the user.",
    ///      "examples": [
    ///        "codahosted.io/123"
    ///      ],
    ///      "type": "string",
    ///      "format": "url"
    ///    },
    ///    "registeredAt": {
    ///      "description": "Timestamp for when the user registered in this
    /// workspace",
    ///      "examples": [
    ///        "2018-04-11T00:18:57.946Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "role": {
    ///      "$ref": "#/components/schemas/WorkspaceUserRole"
    ///    },
    ///    "roleChangedAt": {
    ///      "description": "Timestamp for when the user's role last changed in
    /// this workspace.",
    ///      "examples": [
    ///        "2018-04-11T00:18:57.946Z"
    ///      ],
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "totalDocCollaboratorsLast90Days": {
    ///      "description": "Number of unique users that have viewed any doc the
    /// user owns, manages, or has added pages to in the last 90 days.",
    ///      "examples": [
    ///        2
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "totalDocs": {
    ///      "description": "Number of docs the user owns, manages, or to which
    /// they have added pages in the last 90 days.",
    ///      "examples": [
    ///        2
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "totalDocsLastActiveAt": {
    ///      "description": "Date when anyone last accessed a doc the member
    /// owns or contributed to.",
    ///      "examples": [
    ///        "2018-04-11"
    ///      ],
    ///      "type": "string",
    ///      "format": "date"
    ///    }
    ///  },
    ///  "additionalProperties": false,
    ///  "x-schema-name": "WorkspaceUser"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct WorkspaceUser {
        #[serde(rename = "docCollaboratorCount", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub doc_collaborator_count: ::std::option::Option<f64>,
        ///Date when anyone last accessed a doc that the user owns in this
        /// workspace.
        #[serde(rename = "docsLastActiveAt", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub docs_last_active_at: ::std::option::Option<::chrono::naive::NaiveDate>,
        ///Email of the user.
        pub email: ::std::string::String,
        ///Date when the user last took an action in any workspace.
        #[serde(rename = "lastActiveAt", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_active_at: ::std::option::Option<::chrono::naive::NaiveDate>,
        ///Name of the user.
        pub name: ::std::string::String,
        #[serde(rename = "ownedDocs", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub owned_docs: ::std::option::Option<f64>,
        ///Picture url of the user.
        #[serde(rename = "pictureUrl", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub picture_url: ::std::option::Option<::std::string::String>,
        ///Timestamp for when the user registered in this workspace
        #[serde(rename = "registeredAt")]
        pub registered_at: ::chrono::DateTime<::chrono::offset::Utc>,
        pub role: WorkspaceUserRole,
        ///Timestamp for when the user's role last changed in this workspace.
        #[serde(rename = "roleChangedAt", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub role_changed_at: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        #[serde(rename = "totalDocCollaboratorsLast90Days", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub total_doc_collaborators_last90_days: ::std::option::Option<f64>,
        #[serde(rename = "totalDocs", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub total_docs: ::std::option::Option<f64>,
        ///Date when anyone last accessed a doc the member owns or contributed
        /// to.
        #[serde(rename = "totalDocsLastActiveAt", default, skip_serializing_if = "::std::option::Option::is_none")]
        pub total_docs_last_active_at: ::std::option::Option<::chrono::naive::NaiveDate>,
    }

    impl ::std::convert::From<&WorkspaceUser> for WorkspaceUser {
        fn from(value: &WorkspaceUser) -> Self {
            value.clone()
        }
    }

    ///`WorkspaceUserRole`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "Admin",
    ///    "DocMaker",
    ///    "Editor"
    ///  ],
    ///  "x-schema-name": "WorkspaceUserRole",
    ///  "x-tsEnumNames": [
    ///    "Admin",
    ///    "DocMaker",
    ///    "Editor"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub enum WorkspaceUserRole {
        Admin,
        DocMaker,
        Editor,
    }

    impl ::std::convert::From<&Self> for WorkspaceUserRole {
        fn from(value: &WorkspaceUserRole) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for WorkspaceUserRole {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Admin => f.write_str("Admin"),
                Self::DocMaker => f.write_str("DocMaker"),
                Self::Editor => f.write_str("Editor"),
            }
        }
    }

    impl ::std::str::FromStr for WorkspaceUserRole {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "Admin" => Ok(Self::Admin),
                "DocMaker" => Ok(Self::DocMaker),
                "Editor" => Ok(Self::Editor),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for WorkspaceUserRole {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for WorkspaceUserRole {
        type Error = self::error::ConversionError;
        fn try_from(value: &::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for WorkspaceUserRole {
        type Error = self::error::ConversionError;
        fn try_from(value: ::std::string::String) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
}

#[derive(Clone, Debug)]
///Client for Coda API
///
///# Introduction
///
///The Coda API is a RESTful API that lets you programmatically interact with
/// Coda docs:
///
/// * List and search Coda docs
/// * Create new docs and copy existing ones
/// * Share and publish docs
/// * Discover pages, tables, formulas, and controls
/// * Read, insert, upsert, update, and delete rows
///
///As we update and release newer versions of the API, we reserve the right to
/// remove older APIs and functionality with a 3-month deprecation notice. We
/// will post about such changes as well as announce new features in the [Developers Central](https://community.coda.io/c/developers-central) section of our Community,
///and update the [API updates](https://coda.io/api-updates) doc.
///
///# Getting Started
///
///Our [Getting Started Guide](https://coda.io/@oleg/getting-started-guide-coda-api) helps you learn the
///basic of working with the API and shows a few ways you can use it. Check it
/// out, and learn how to:
///
/// - Read data from Coda tables and write back to them
/// - Build a one-way sync from one Coda doc to another
/// - Automate reminders
/// - Sync your Google Calendar to Coda
///
///# Using the API
///
///Coda's REST API is designed to be straightforward to use. You can use the
/// language and platform of your choice to make requests. To get a feel for the API, you can also use a tool like [Postman](https://www.getpostman.com/) or
///[Insomnia](https://insomnia.rest/).
///
///## API Endpoint
///
///This API uses a base path of `https://coda.io/apis/v1`.
///
///## Resource IDs and Links
///
///Each resource instance retrieved via the API has the following fields:
///
///  - `id`: The resource's immutable ID, which can be used to refer to it
///    within its context
///  - `type`: The type of resource, useful for identifying it in a heterogenous
///    collection of results
///  - `href`: A fully qualified URI that can be used to refer to and get the
///    latest details on the resource
///
///Most resources can be queried by their name or ID. We recommend sticking
/// with IDs where possible, as names are fragile and prone to being changed by
/// your doc's users.
///
///### List Endpoints
///
///Endpoints supporting listing of resources have the following fields:
///
///  - `items`: An array containing the listed resources, limited by the `limit`
///    or `pageToken` query parameters
///  - `nextPageLink`: If more results are available, an API link to the next
///    page of results
///  - `nextPageToken`: If more results are available, a page token that can be
///    passed into the `pageToken` query parameter
///
///**The maximum page size may change at any time, and may be different for
/// different endpoints.** Please do not rely on it for any behavior of your
/// application. If you pass a `limit` parameter that is larger than our maximum
/// allowed limit, we will only return as many results as our maximum limit. You
/// should look for the presence of the `nextPageToken` on the response to see
/// if there are more results available, rather than relying on a result set
/// that matches your provided limit.
///
///To fetch a subsequent page of results, pass the `pageToken` parameter. Set
/// this parameter to the value given to you as the `nextPageToken`
/// in a page response. If no value is provided, there are no more results
/// available. You only need to pass the `pageToken` to get the next page of
/// results, you don't need to pass any of the parameters from your original
/// request, as they are all implied by the `pageToken`. Any other parameters
/// provided alongside a `pageToken` will be ignored.
///
///### Doc IDs
///
///While most object IDs will have to be discovered via the API, you may find
/// yourself frequently wanting to get the ID of a specific Coda doc.
///
///Here's a handy tool that will extract it for you. (See if you can find the
/// pattern!)
///
///<form>
///  <fieldset style="margin: 0px 25px 25px 25px; display: inline;">
///    <legend>Doc ID Extractor</legend>
///    <input type="text" id="de_docUrl" placeholder="Paste in a Coda doc URL"
///           style="width: 250px; padding: 8px; margin-right: 20px;" />
///    <span>
///      Your doc ID is:&nbsp;&nbsp;&nbsp;
///      <input id="de_docId" readonly="true"
///             style="width: 150px; padding: 8px; font-family: monospace;
/// border: 1px dashed gray;" />  </fieldset>
///</form>
///
///<script>
///  (() => {
///    const docUrl = document.getElementById('de_docUrl');
///    const docId = document.getElementById('de_docId');
///    docUrl.addEventListener('input', () => {
///      docId.value = (docUrl.value.match(/_d([\w-]+)/) || [])[1] || '';
///    });
///    docId.addEventListener('mousedown', () => docId.select());
///    docId.addEventListener('click', () => docId.select());
///  })();
///</script>
///
///## Rate Limiting
///
///The Coda API sets a reasonable limit on the number of requests that can be
/// made per minute. Once this limit is reached, calls to the API will start
/// returning errors with an HTTP status code of 429.
///
///These are the current rate limits. They are subject to change at any time
/// without notice. For robustness, all API scripts should check for HTTP 429
/// Too Many Requests errors and back off and retry the request. Limits apply
/// per-user across all endpoints that share the same limit and across all docs.
///
///Reading data (with the exceptions below): {{READ_RATE_LIMIT}}
///<br/>
///Writing data (POST/PUT/PATCH): {{WRITE_RATE_LIMIT}}
///<br/>
///Writing doc content data (POST/PUT/PATCH): {{WRITE_DOC_CONTENT_RATE_LIMIT}}
///<br/>
///Listing docs: {{LIST_DOCS_RATE_LIMIT}}
///<br/>
///Reading analytics: {{ANALYTICS_RATE_LIMIT}}
///
///## Consistency
///
///While edits made in Coda are shared with other collaborators in real-time,
/// it can take a few seconds for them to become available via the API. You may
/// also notice that changes made via the API, such as updating a row, are not
/// immediate. These endpoints all return an HTTP 202 status code, instead of a
/// standard 200, indicating that the edit has been accepted and queued for
/// processing. This generally takes a few seconds, and the edit may fail if
/// invalid. Each such edit will return a `requestId` in the response, and you
/// can pass this `requestId` to the [`#getMutationStatus`](#operation/
/// getMutationStatus) endpoint to find out if it has been applied.
///
///Similarly, when you get doc data from the API (rows, pages, columns, etc),
/// the data you receive comes from the most recent "snapshot" of the doc, which
/// might be slightly stale relative to the data you observe in your browser. If
/// you want to ensure that the data you receive is up to date and are ok
/// getting an error if not, you can pass this header in your request:
/// `X-Coda-Doc-Version: latest`. If the API's view of the doc is
/// not up to date, the API will return an HTTP 400 response.
///
///## Volatile Formulas
///
///Coda exposes a number of "volatile" formulas, as as `Today()`, `Now()`, and
/// `User()`. When used in a live Coda doc, these formulas affect what's visible
/// in realtime, tailored to the current user.
///
///Such formulas behave differently with the API. Time-based values may only be
/// current to the last edit made to the doc. User-based values may be blank or
/// invalid.
///
///## Free and Paid Workspaces
///
///We make the Coda API available to all of our users free of charge, in both
/// free and paid workspaces. However, API usage is subject to the role of the
/// user associated with the API token in the workspace applicable to each API
/// request. What this means is:
///
/// - For the [`#createDoc`](#operation/createDoc) endpoint specifically, the
///   owner of the API token must be a Doc
///  Maker (or Admin) in the workspace. If the "Any member can create docs"
/// option in enabled in the workspace  settings, they can be an Editor and will
/// get auto-promoted to Doc Maker upon using this endpoint. Lastly, if in
///  addition, the API key owner matches the "Auto-join email domains" setting,
/// they will be auto-added to the  workspace and promoted to Doc Maker upon
/// using this endpoint
///
///This behavior applies to the API as well as any integrations that may use
/// it, such as Zapier.
///
///## Examples
///
///To help you get started, this documentation provides code examples in
/// Python, Unix shell, and Google Apps Script. These examples are based on a
/// simple doc that looks something like this:
///
/// ![](https://cdn.coda.io/external/img/api_example_doc.png)
///
///### Python examples
///
///These examples use Python 3.6+. If you don't already have the `requests`
/// module, use `pip` or `easy_install` to get it.
///
///### Shell examples
///
///The shell examples are intended to be run in a Unix shell. If you're on
/// Windows, you will need to install [WSL](https://docs.microsoft.com/en-us/windows/wsl/install-win10).
///
///These examples use the standard cURL utility to pull from the API, and then
/// process it with `jq` to extract and format example output. If you don't already have it, you can either [install it](https://stedolan.github.io/jq/)
///or run the command without it to see the raw JSON output.
///
///### Google Apps Script examples
///
/// ![](https://cdn.coda.io/external/img/api_gas.png)
///
///[Google Apps Script](https://script.google.com/) makes it easy to write code in a JavaScript-like syntax and
///easily access many Google products with built-in libraries. You can set up
/// your scripts to run periodically, which makes it a good environment for
/// writing tools without maintaining your own server.
///
///Coda provides a library for Google Apps Script. To use it, go into
/// `Resources -> Libraries...` and enter the following library ID:
/// `15IQuWOk8MqT50FDWomh57UqWGH23gjsWVWYFms3ton6L-UHmefYHS9Vl`. If you want to
/// see the library's source code, it's available
///[here](https://script.google.com/d/15IQuWOk8MqT50FDWomh57UqWGH23gjsWVWYFms3ton6L-UHmefYHS9Vl/edit).
///
///Google provides autocomplete for API functions as well as generated docs.
/// You can access these docs via the Libraries dialog by clicking on the
/// library name. Required parameters that would be included in the URL path are
/// positional arguments in each of these functions, followed by the request
/// body, if applicable. All remaining parameters can be specified in the
/// options object.
///
///## OpenAPI/Swagger Spec
///
///In an effort to standardize our API and make it accessible, we offer an
/// OpenAPI 3.0 specification:
///
/// - [OpenAPI 3.0 spec - YAML](https://coda.io/apis/v1/openapi.yaml)
/// - [OpenAPI 3.0 spec - JSON](https://coda.io/apis/v1/openapi.json)
///
///#### Postman collection
///
///To get started with prototyping the API quickly in Postman, you can use one
/// of links above to import the Coda API into a collection. You'll then need to
/// set the [appropriate header](#section/Authentication) and environment
/// variables.
///
///## Client libraries
///
///We do not currently support client libraries apart from Google Apps Script.
/// To work with the Coda API, you can either use standard network libraries for
/// your language, or use the appropriate Swagger Generator tool to
/// auto-generate Coda API client libraries for your language of choice. We do
/// not provide any guarantees that these autogenerated libraries are compatible
/// with our API (e.g., some libraries may not work with Bearer authentication).
///
///### OpenAPI 3.0
///
///[Swagger Generator 3](https://generator3.swagger.io/) (that link takes you to the docs for the generator API) can
///generate client libraries for [these languages](https://generator3.swagger.io/v2/clients). It's relatively new
///and thus only has support for a limited set of languages at this time.
///
///### Third-party client libraries
///
///Some members of our amazing community have written libraries to work with
/// our API. These aren't officially supported by Coda, but are listed here for
/// convenience. (Please let us know if you've written a library and would
/// like to have it included here.)
///
/// - [PHP](https://github.com/danielstieber/CodaPHP) by Daniel Stieber
/// - [Node-RED](https://github.com/serene-water/node-red-contrib-coda-io) by
///   Mori Sugimoto
/// - [NodeJS](https://www.npmjs.com/package/coda-js) by Parker McMullin
/// - [Ruby](https://rubygems.org/gems/coda_docs/) by Carlos Muñoz at Getro
/// - [Python](https://github.com/Blasterai/codaio) by Mikhail Beliansky
/// - [Go](https://github.com/artsafin/coda-schema-generator) by Artur Safin
///
///
///https://coda.io/trust/tos
///
///Version: 1.4.19
pub struct Client {
    pub(crate) baseurl: String,
    pub(crate) client: reqwest::Client,
}

impl Client {
    /// Create a new client.
    ///
    /// `baseurl` is the base URL provided to the internal
    /// `reqwest::Client`, and should include a scheme and hostname,
    /// as well as port and a path stem if applicable.
    pub fn new(baseurl: &str) -> Self {
        #[cfg(not(target_arch = "wasm32"))]
        let client = {
            let dur = std::time::Duration::from_secs(15);
            reqwest::ClientBuilder::new()
                .connect_timeout(dur)
                .timeout(dur)
        };
        #[cfg(target_arch = "wasm32")]
        let client = reqwest::ClientBuilder::new();
        Self::new_with_client(baseurl, client.build().unwrap())
    }

    /// Construct a new client with an existing `reqwest::Client`,
    /// allowing more control over its configuration.
    ///
    /// `baseurl` is the base URL provided to the internal
    /// `reqwest::Client`, and should include a scheme and hostname,
    /// as well as port and a path stem if applicable.
    pub fn new_with_client(baseurl: &str, client: reqwest::Client) -> Self {
        Self {
            baseurl: baseurl.to_string(),
            client,
        }
    }
}

impl ClientInfo<()> for Client {
    fn api_version() -> &'static str {
        "1.4.19"
    }

    fn baseurl(&self) -> &str {
        self.baseurl.as_str()
    }

    fn client(&self) -> &reqwest::Client {
        &self.client
    }

    fn inner(&self) -> &() {
        &()
    }
}

impl ClientHooks<()> for &Client {}
#[allow(clippy::all)]
impl Client {
    ///Get doc categories
    ///
    ///Gets all available doc categories.
    ///
    ///Sends a `GET` request to `/categories`
    pub async fn list_categories<'a>(&'a self) -> Result<ResponseValue<types::DocCategoryList>, Error<types::ListCategoriesResponse>> {
        let url = format!("{}/categories", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_categories",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List available docs
    ///
    ///Returns a list of Coda docs accessible by the user, and which they have
    /// opened at least once. These are returned in the same order as on the
    /// docs page: reverse chronological by the latest event relevant to the
    /// user (last viewed, edited, or shared).
    ///
    ///
    ///Sends a `GET` request to `/docs`
    ///
    ///Arguments:
    /// - `folder_id`: Show only docs belonging to the given folder.
    /// - `in_gallery`: Show only docs visible within the gallery.
    /// - `is_owner`: Show only docs owned by the user.
    /// - `is_published`: Show only published docs.
    /// - `is_starred`: If true, returns docs that are starred. If false,
    ///   returns docs that are not starred.
    /// - `limit`: Maximum number of results to return in this query.
    /// - `page_token`: An opaque token used to fetch the next page of results.
    /// - `query`: Search term used to filter down results.
    /// - `source_doc`: Show only docs copied from the specified doc ID.
    /// - `workspace_id`: Show only docs belonging to the given workspace.
    pub async fn list_docs<'a>(&'a self, folder_id: Option<&'a str>, in_gallery: Option<bool>, is_owner: Option<bool>, is_published: Option<bool>, is_starred: Option<bool>, limit: Option<::std::num::NonZeroU64>, page_token: Option<&'a str>, query: Option<&'a str>, source_doc: Option<&'a str>, workspace_id: Option<&'a str>) -> Result<ResponseValue<types::DocList>, Error<types::ListDocsResponse>> {
        let url = format!("{}/docs", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .query(&progenitor_client::QueryParam::new("folderId", &folder_id))
            .query(&progenitor_client::QueryParam::new("inGallery", &in_gallery))
            .query(&progenitor_client::QueryParam::new("isOwner", &is_owner))
            .query(&progenitor_client::QueryParam::new("isPublished", &is_published))
            .query(&progenitor_client::QueryParam::new("isStarred", &is_starred))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("pageToken", &page_token))
            .query(&progenitor_client::QueryParam::new("query", &query))
            .query(&progenitor_client::QueryParam::new("sourceDoc", &source_doc))
            .query(&progenitor_client::QueryParam::new("workspaceId", &workspace_id))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_docs",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create doc
    ///
    ///Creates a new Coda doc, optionally copying an existing doc. Note that
    /// creating a doc requires you to be a Doc Maker in the applicable
    /// workspace (or be auto-promoted to one).
    ///
    ///
    ///Sends a `POST` request to `/docs`
    ///
    ///Arguments:
    /// - `body`: Parameters for creating the doc.
    pub async fn create_doc<'a>(&'a self, body: &'a types::DocCreate) -> Result<ResponseValue<types::DocumentCreationResult>, Error<types::CreateDocResponse>> {
        let url = format!("{}/docs", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_doc",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get info about a doc
    ///
    ///Returns metadata for the specified doc.
    ///
    ///Sends a `GET` request to `/docs/{docId}`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    pub async fn get_doc<'a>(&'a self, doc_id: &'a str) -> Result<ResponseValue<types::Doc>, Error<types::GetDocResponse>> {
        let url = format!("{}/docs/{}", self.baseurl, encode_path(&doc_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_doc",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Delete doc
    ///
    ///Deletes a doc.
    ///
    ///Sends a `DELETE` request to `/docs/{docId}`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    pub async fn delete_doc<'a>(&'a self, doc_id: &'a str) -> Result<ResponseValue<types::DocDelete>, Error<types::DeleteDocResponse>> {
        let url = format!("{}/docs/{}", self.baseurl, encode_path(&doc_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "delete_doc",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update doc
    ///
    ///Updates metadata for a doc. Note that updating a doc title requires you
    /// to be a Doc Maker in the applicable workspace.
    ///
    ///Sends a `PATCH` request to `/docs/{docId}`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    /// - `body`: Parameters for updating the doc.
    pub async fn update_doc<'a>(&'a self, doc_id: &'a str, body: &'a types::DocUpdate) -> Result<ResponseValue<types::DocUpdateResult>, Error<types::UpdateDocResponse>> {
        let url = format!("{}/docs/{}", self.baseurl, encode_path(&doc_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .patch(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_doc",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get sharing metadata
    ///
    ///Returns metadata associated with sharing for this Coda doc.
    ///
    ///Sends a `GET` request to `/docs/{docId}/acl/metadata`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    pub async fn get_sharing_metadata<'a>(&'a self, doc_id: &'a str) -> Result<ResponseValue<types::AclMetadata>, Error<types::GetSharingMetadataResponse>> {
        let url = format!("{}/docs/{}/acl/metadata", self.baseurl, encode_path(&doc_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_sharing_metadata",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List permissions
    ///
    ///Returns a list of permissions for this Coda doc.
    ///
    ///Sends a `GET` request to `/docs/{docId}/acl/permissions`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    /// - `limit`: Maximum number of results to return in this query.
    /// - `page_token`: An opaque token used to fetch the next page of results.
    pub async fn get_permissions<'a>(&'a self, doc_id: &'a str, limit: Option<::std::num::NonZeroU64>, page_token: Option<&'a str>) -> Result<ResponseValue<types::Acl>, Error<types::GetPermissionsResponse>> {
        let url = format!("{}/docs/{}/acl/permissions", self.baseurl, encode_path(&doc_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("pageToken", &page_token))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_permissions",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Add permission
    ///
    ///Adds a new permission to the doc.
    ///
    ///
    ///Sends a `POST` request to `/docs/{docId}/acl/permissions`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    /// - `body`: Parameters for adding the new permission.
    pub async fn add_permission<'a>(&'a self, doc_id: &'a str, body: &'a types::AddPermissionRequest) -> Result<ResponseValue<types::AddPermissionResult>, Error<types::AddPermissionResponse>> {
        let url = format!("{}/docs/{}/acl/permissions", self.baseurl, encode_path(&doc_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "add_permission",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Delete permission
    ///
    ///Deletes an existing permission.
    ///
    ///
    ///Sends a `DELETE` request to
    /// `/docs/{docId}/acl/permissions/{permissionId}`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    /// - `permission_id`: ID of a permission on a doc.
    pub async fn delete_permission<'a>(&'a self, doc_id: &'a str, permission_id: &'a str) -> Result<ResponseValue<types::DeletePermissionResult>, Error<types::DeletePermissionResponse>> {
        let url = format!("{}/docs/{}/acl/permissions/{}", self.baseurl, encode_path(&doc_id.to_string()), encode_path(&permission_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "delete_permission",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Search principals
    ///
    ///Searches for user and group principals matching the query that this doc
    /// can be shared with. At most 20 results will be returned for both
    /// users and groups. If no query is given then no results are returned.
    ///
    ///
    ///Sends a `GET` request to `/docs/{docId}/acl/principals/search`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    /// - `query`: Search term used to filter down results.
    pub async fn search_principals<'a>(&'a self, doc_id: &'a str, query: Option<&'a str>) -> Result<ResponseValue<types::SearchPrincipalsResponse>, Error<types::SearchPrincipalsResponse>> {
        let url = format!("{}/docs/{}/acl/principals/search", self.baseurl, encode_path(&doc_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .query(&progenitor_client::QueryParam::new("query", &query))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "search_principals",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get ACL settings
    ///
    ///Returns settings associated with ACLs for this Coda doc.
    ///
    ///Sends a `GET` request to `/docs/{docId}/acl/settings`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    pub async fn get_acl_settings<'a>(&'a self, doc_id: &'a str) -> Result<ResponseValue<types::AclSettings>, Error<types::GetAclSettingsResponse>> {
        let url = format!("{}/docs/{}/acl/settings", self.baseurl, encode_path(&doc_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_acl_settings",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update ACL settings
    ///
    ///Update settings associated with ACLs for this Coda doc.
    ///
    ///Sends a `PATCH` request to `/docs/{docId}/acl/settings`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    /// - `body`: Parameters for updating the ACL settings.
    pub async fn update_acl_settings<'a>(&'a self, doc_id: &'a str, body: &'a types::UpdateAclSettingsRequest) -> Result<ResponseValue<types::AclSettings>, Error<types::UpdateAclSettingsResponse>> {
        let url = format!("{}/docs/{}/acl/settings", self.baseurl, encode_path(&doc_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .patch(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_acl_settings",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Publish doc
    ///
    ///Update publish settings for a doc.
    ///
    ///Sends a `PUT` request to `/docs/{docId}/publish`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    /// - `body`: Parameters for changing publish settings.
    pub async fn publish_doc<'a>(&'a self, doc_id: &'a str, body: &'a types::DocPublish) -> Result<ResponseValue<types::PublishResult>, Error<types::PublishDocResponse>> {
        let url = format!("{}/docs/{}/publish", self.baseurl, encode_path(&doc_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "publish_doc",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Unpublish doc
    ///
    ///Unpublishes a doc.
    ///
    ///Sends a `DELETE` request to `/docs/{docId}/publish`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    pub async fn unpublish_doc<'a>(&'a self, doc_id: &'a str) -> Result<ResponseValue<types::UnpublishResult>, Error<types::UnpublishDocResponse>> {
        let url = format!("{}/docs/{}/publish", self.baseurl, encode_path(&doc_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "unpublish_doc",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List pages
    ///
    ///Returns a list of pages in a Coda doc.
    ///
    ///Sends a `GET` request to `/docs/{docId}/pages`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    /// - `limit`: Maximum number of results to return in this query.
    /// - `page_token`: An opaque token used to fetch the next page of results.
    pub async fn list_pages<'a>(&'a self, doc_id: &'a str, limit: Option<::std::num::NonZeroU64>, page_token: Option<&'a str>) -> Result<ResponseValue<types::PageList>, Error<types::ListPagesResponse>> {
        let url = format!("{}/docs/{}/pages", self.baseurl, encode_path(&doc_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("pageToken", &page_token))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_pages",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create a page
    ///
    ///Create a new page in a doc. Note that creating a page requires you to be
    /// a Doc Maker in the applicable workspace.
    ///
    ///
    ///Sends a `POST` request to `/docs/{docId}/pages`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    /// - `body`: Parameters for creating a page.
    pub async fn create_page<'a>(&'a self, doc_id: &'a str, body: &'a types::PageCreate) -> Result<ResponseValue<types::PageCreateResult>, Error<types::CreatePageResponse>> {
        let url = format!("{}/docs/{}/pages", self.baseurl, encode_path(&doc_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_page",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get a page
    ///
    ///Returns details about a page.
    ///
    ///Sends a `GET` request to `/docs/{docId}/pages/{pageIdOrName}`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    /// - `page_id_or_name`: ID or name of the page. Names are discouraged
    ///   because they're easily prone to being changed by users. If you're
    ///   using a name, be sure to URI-encode it. If you provide a name and
    ///   there are multiple pages with the same name, an arbitrary one will be
    ///   selected.
    pub async fn get_page<'a>(&'a self, doc_id: &'a str, page_id_or_name: &'a str) -> Result<ResponseValue<types::Page>, Error<types::GetPageResponse>> {
        let url = format!("{}/docs/{}/pages/{}", self.baseurl, encode_path(&doc_id.to_string()), encode_path(&page_id_or_name.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_page",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            410u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update a page
    ///
    ///Update properties for a page. Note that updating a page title or icon
    /// requires you to be a Doc Maker in the applicable workspace.
    ///
    ///
    ///Sends a `PUT` request to `/docs/{docId}/pages/{pageIdOrName}`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    /// - `page_id_or_name`: ID or name of the page. Names are discouraged
    ///   because they're easily prone to being changed by users. If you're
    ///   using a name, be sure to URI-encode it. If you provide a name and
    ///   there are multiple pages with the same name, an arbitrary one will be
    ///   selected.
    ///
    /// - `body`: Parameters for updating a page.
    pub async fn update_page<'a>(&'a self, doc_id: &'a str, page_id_or_name: &'a str, body: &'a types::PageUpdate) -> Result<ResponseValue<types::PageUpdateResult>, Error<types::UpdatePageResponse>> {
        let url = format!("{}/docs/{}/pages/{}", self.baseurl, encode_path(&doc_id.to_string()), encode_path(&page_id_or_name.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_page",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Delete a page
    ///
    ///Deletes the specified page.
    ///
    ///Sends a `DELETE` request to `/docs/{docId}/pages/{pageIdOrName}`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    /// - `page_id_or_name`: ID or name of the page. Names are discouraged
    ///   because they're easily prone to being changed by users. If you're
    ///   using a name, be sure to URI-encode it. If you provide a name and
    ///   there are multiple pages with the same name, an arbitrary one will be
    ///   selected.
    pub async fn delete_page<'a>(&'a self, doc_id: &'a str, page_id_or_name: &'a str) -> Result<ResponseValue<types::PageDeleteResult>, Error<types::DeletePageResponse>> {
        let url = format!("{}/docs/{}/pages/{}", self.baseurl, encode_path(&doc_id.to_string()), encode_path(&page_id_or_name.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "delete_page",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Begin content export
    ///
    ///Initiate an export of content for the given page.
    ///
    ///Sends a `POST` request to `/docs/{docId}/pages/{pageIdOrName}/export`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    /// - `page_id_or_name`: ID or name of the page. Names are discouraged
    ///   because they're easily prone to being changed by users. If you're
    ///   using a name, be sure to URI-encode it. If you provide a name and
    ///   there are multiple pages with the same name, an arbitrary one will be
    ///   selected.
    ///
    /// - `body`: Parameters for requesting a page content export.
    pub async fn begin_page_content_export<'a>(&'a self, doc_id: &'a str, page_id_or_name: &'a str, body: &'a types::BeginPageContentExportRequest) -> Result<ResponseValue<types::BeginPageContentExportResponse>, Error<types::BeginPageContentExportResponse>> {
        let url = format!("{}/docs/{}/pages/{}/export", self.baseurl, encode_path(&doc_id.to_string()), encode_path(&page_id_or_name.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "begin_page_content_export",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            410u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Content export status
    ///
    ///Check the status of a page content export
    ///
    ///Sends a `GET` request to
    /// `/docs/{docId}/pages/{pageIdOrName}/export/{requestId}`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    /// - `page_id_or_name`: ID or name of the page. Names are discouraged
    ///   because they're easily prone to being changed by users. If you're
    ///   using a name, be sure to URI-encode it. If you provide a name and
    ///   there are multiple pages with the same name, an arbitrary one will be
    ///   selected.
    ///
    /// - `request_id`: ID of the request.
    pub async fn get_page_content_export_status<'a>(&'a self, doc_id: &'a str, page_id_or_name: &'a str, request_id: &'a str) -> Result<ResponseValue<types::PageContentExportStatusResponse>, Error<types::GetPageContentExportStatusResponse>> {
        let url = format!("{}/docs/{}/pages/{}/export/{}", self.baseurl, encode_path(&doc_id.to_string()), encode_path(&page_id_or_name.to_string()), encode_path(&request_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_page_content_export_status",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            410u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List tables
    ///
    ///Returns a list of tables in a Coda doc.
    ///
    ///Sends a `GET` request to `/docs/{docId}/tables`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    /// - `limit`: Maximum number of results to return in this query.
    /// - `page_token`: An opaque token used to fetch the next page of results.
    /// - `sort_by`: Determines how to sort the given objects.
    /// - `table_types`: Comma-separated list of table types to include in
    ///   results. If omitted, includes both tables and views.
    pub async fn list_tables<'a>(&'a self, doc_id: &'a str, limit: Option<::std::num::NonZeroU64>, page_token: Option<&'a str>, sort_by: Option<types::SortBy>, table_types: Option<&'a ::std::vec::Vec<types::TableTypeEnum>>) -> Result<ResponseValue<types::TableList>, Error<types::ListTablesResponse>> {
        let url = format!("{}/docs/{}/tables", self.baseurl, encode_path(&doc_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("pageToken", &page_token))
            .query(&progenitor_client::QueryParam::new("sortBy", &sort_by))
            .query(&progenitor_client::QueryParam::new("tableTypes", &table_types))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_tables",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get a table
    ///
    ///Returns details about a specific table or view.
    ///
    ///Sends a `GET` request to `/docs/{docId}/tables/{tableIdOrName}`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    /// - `table_id_or_name`: ID or name of the table. Names are discouraged
    ///   because they're easily prone to being changed by users. If you're
    ///   using a name, be sure to URI-encode it.
    /// - `use_updated_table_layouts`: Return "detail" and "form" for the
    ///   `layout` field of detail and form layouts respectively (instead of
    ///   "masterDetail" for both)
    pub async fn get_table<'a>(&'a self, doc_id: &'a str, table_id_or_name: &'a str, use_updated_table_layouts: Option<bool>) -> Result<ResponseValue<types::Table>, Error<types::GetTableResponse>> {
        let url = format!("{}/docs/{}/tables/{}", self.baseurl, encode_path(&doc_id.to_string()), encode_path(&table_id_or_name.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .query(&progenitor_client::QueryParam::new("useUpdatedTableLayouts", &use_updated_table_layouts))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_table",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List columns
    ///
    ///Returns a list of columns in a table.
    ///
    ///Sends a `GET` request to `/docs/{docId}/tables/{tableIdOrName}/columns`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    /// - `table_id_or_name`: ID or name of the table. Names are discouraged
    ///   because they're easily prone to being changed by users. If you're
    ///   using a name, be sure to URI-encode it.
    /// - `limit`: Maximum number of results to return in this query.
    /// - `page_token`: An opaque token used to fetch the next page of results.
    /// - `visible_only`: If true, returns only visible columns for the table.
    ///   This parameter only applies to base tables, and not views.
    pub async fn list_columns<'a>(&'a self, doc_id: &'a str, table_id_or_name: &'a str, limit: Option<::std::num::NonZeroU64>, page_token: Option<&'a str>, visible_only: Option<bool>) -> Result<ResponseValue<types::ColumnList>, Error<types::ListColumnsResponse>> {
        let url = format!("{}/docs/{}/tables/{}/columns", self.baseurl, encode_path(&doc_id.to_string()), encode_path(&table_id_or_name.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("pageToken", &page_token))
            .query(&progenitor_client::QueryParam::new("visibleOnly", &visible_only))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_columns",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List table rows
    ///
    ///Returns a list of rows in a table.
    ///### Value results
    ///The `valueFormat` parameter dictates in what format the API should
    /// return values for individual cells.
    /// * `simple` (default): Returns cell values as the following JSON values:
    ///   `string`, `number`, or `boolean`. Array values (like multiselects) are
    ///   returned as comma-delimited strings.
    /// * `simpleWithArrays`: Singleton values are returned as `simple`. Array
    ///   values are returned as JSON arrays and the values within are `simple`
    ///   values (including nested arrays).
    /// * `rich`: If applicable, returns many values with further encoding,
    ///   allowing API users to have lossless access to data in Coda.
    ///  * For `text` values, returns data in Markdown syntax. If the text field
    ///    is simple text (e.g. has no formatting),
    ///  the field will be fully escaped with triple-ticks. E.g
    ///  `
    ///  ```This is plain text```
    ///  `
    ///  * For `currency`, `lookup`, `image`, `person` and `hyperlink` values, the value will be encoded in [JSON-LD](https://json-ld.org/) format.
    ///
    ///```json
    ///  // Currency
    ///  {
    ///    "@context": "http://schema.org",
    ///    "@type": "MonetaryAmount",
    ///    "currency": "USD",
    ///    "amount": 42.42
    ///  }
    ///
    ///  // Lookup
    ///  {
    ///    "@context": "http://schema.org",
    ///    "@type": "StructuredValue",
    ///    "additionalType": "row",
    ///    "name": "Row Name",
    ///    "rowId": "i-123456789",
    ///    "tableId": "grid-123456789",
    ///    "tableUrl": "https://coda.io/d/_d123456789/grid-123456789",
    ///    "url": "https://coda.io/d/_d123456789/grid-123456789#_r42",
    ///  }
    ///
    ///  // Hyperlink
    ///  {
    ///    "@context": "http://schema.org",
    ///    "@type": "WebPage",
    ///    "name": "Coda",
    ///    "url": "https://coda.io"
    ///  }
    ///
    ///  // Image
    ///  {
    ///    "@context": "http://schema.org",
    ///    "@type": "ImageObject",
    ///    "name": "Coda logo",
    ///    "url": "https://coda.io/logo.jpg"
    ///  }
    ///
    ///  // People
    ///  {
    ///    "@context": "http://schema.org",
    ///    "@type": "Person",
    ///    "name": "Art Vandalay",
    ///    "email": "art@vandalayindustries.com"
    ///  }
    /// ```
    ///
    ///
    ///Sends a `GET` request to `/docs/{docId}/tables/{tableIdOrName}/rows`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    /// - `table_id_or_name`: ID or name of the table. Names are discouraged
    ///   because they're easily prone to being changed by users. If you're
    ///   using a name, be sure to URI-encode it.
    /// - `limit`: Maximum number of results to return in this query.
    /// - `page_token`: An opaque token used to fetch the next page of results.
    /// - `query`: Query used to filter returned rows, specified as
    ///   `<column_id_or_name>:<value>`. If you'd like to use a column name
    ///   instead of an ID, you must quote it (e.g., `"My Column":123`). Also
    ///   note that `value` is a JSON value; if you'd like to use a string, you
    ///   must surround it in quotes (e.g., `"groceries"`).
    ///
    /// - `sort_by`: Specifies the sort order of the rows returned. If left
    ///   unspecified, rows are returned by creation time ascending. "UpdatedAt"
    ///   sort ordering is the order of rows based upon when they were last
    ///   updated. This does not include updates to calculated values. "Natural"
    ///   sort ordering is the order that the rows appear in the table view in
    ///   the application. This ordering is only meaningfully defined for rows
    ///   that are visible (unfiltered). Because of this, using this sort order
    ///   will imply visibleOnly=true, that is, to only return visible rows. If
    ///   you pass sortBy=natural and visibleOnly=false explicitly, this will
    ///   result in a Bad Request error as this condition cannot be satisfied.
    ///
    /// - `sync_token`: An opaque token returned from a previous call that can
    ///   be used to return results that are relevant to the query since the
    ///   call where the syncToken was generated.
    ///
    /// - `use_column_names`: Use column names instead of column IDs in the
    ///   returned output. This is generally discouraged as it is fragile. If
    ///   columns are renamed, code using original names may throw errors.
    ///
    /// - `value_format`: The format that cell values are returned as.
    /// - `visible_only`: If true, returns only visible rows and columns for the
    ///   table.
    pub async fn list_rows<'a>(&'a self, doc_id: &'a str, table_id_or_name: &'a str, limit: Option<::std::num::NonZeroU64>, page_token: Option<&'a str>, query: Option<&'a str>, sort_by: Option<types::RowsSortBy>, sync_token: Option<&'a str>, use_column_names: Option<bool>, value_format: Option<types::ValueFormat>, visible_only: Option<bool>) -> Result<ResponseValue<types::RowList>, Error<types::ListRowsResponse>> {
        let url = format!("{}/docs/{}/tables/{}/rows", self.baseurl, encode_path(&doc_id.to_string()), encode_path(&table_id_or_name.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("pageToken", &page_token))
            .query(&progenitor_client::QueryParam::new("query", &query))
            .query(&progenitor_client::QueryParam::new("sortBy", &sort_by))
            .query(&progenitor_client::QueryParam::new("syncToken", &sync_token))
            .query(&progenitor_client::QueryParam::new("useColumnNames", &use_column_names))
            .query(&progenitor_client::QueryParam::new("valueFormat", &value_format))
            .query(&progenitor_client::QueryParam::new("visibleOnly", &visible_only))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_rows",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Insert/upsert rows
    ///
    ///Inserts rows into a table, optionally updating existing rows if any
    /// upsert key columns are provided. This endpoint will always return a 202,
    /// so long as the doc and table exist and are accessible (and the update is
    /// structurally valid). Row inserts/upserts are generally processed within
    /// several seconds. Note: this endpoint only works for base tables, not
    /// views. When upserting, if multiple rows match the specified key
    /// column(s), they will all be updated with the specified value.
    ///
    ///
    ///Sends a `POST` request to `/docs/{docId}/tables/{tableIdOrName}/rows`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    /// - `table_id_or_name`: ID or name of the table. Names are discouraged
    ///   because they're easily prone to being changed by users. If you're
    ///   using a name, be sure to URI-encode it.
    /// - `disable_parsing`: If true, the API will not attempt to parse the data
    ///   in any way.
    /// - `body`: Rows to insert or upsert.
    pub async fn upsert_rows<'a>(&'a self, doc_id: &'a str, table_id_or_name: &'a str, disable_parsing: Option<bool>, body: &'a types::RowsUpsert) -> Result<ResponseValue<types::RowsUpsertResult>, Error<types::UpsertRowsResponse>> {
        let url = format!("{}/docs/{}/tables/{}/rows", self.baseurl, encode_path(&doc_id.to_string()), encode_path(&table_id_or_name.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .json(&body)
            .query(&progenitor_client::QueryParam::new("disableParsing", &disable_parsing))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "upsert_rows",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Delete multiple rows
    ///
    ///Deletes the specified rows from the table or view. This endpoint will
    /// always return a 202. Row deletions are generally processed within
    /// several seconds.
    ///
    ///
    ///Sends a `DELETE` request to `/docs/{docId}/tables/{tableIdOrName}/rows`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    /// - `table_id_or_name`: ID or name of the table. Names are discouraged
    ///   because they're easily prone to being changed by users. If you're
    ///   using a name, be sure to URI-encode it.
    /// - `body`: Rows to delete.
    pub async fn delete_rows<'a>(&'a self, doc_id: &'a str, table_id_or_name: &'a str, body: &'a types::RowsDelete) -> Result<ResponseValue<types::RowsDeleteResult>, Error<types::DeleteRowsResponse>> {
        let url = format!("{}/docs/{}/tables/{}/rows", self.baseurl, encode_path(&doc_id.to_string()), encode_path(&table_id_or_name.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "delete_rows",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get a row
    ///
    ///Returns details about a row in a table.
    ///
    ///Sends a `GET` request to
    /// `/docs/{docId}/tables/{tableIdOrName}/rows/{rowIdOrName}`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    /// - `table_id_or_name`: ID or name of the table. Names are discouraged
    ///   because they're easily prone to being changed by users. If you're
    ///   using a name, be sure to URI-encode it.
    /// - `row_id_or_name`: ID or name of the row. Names are discouraged because
    ///   they're easily prone to being changed by users. If you're using a
    ///   name, be sure to URI-encode it. If there are multiple rows with the
    ///   same value in the identifying column, an arbitrary one will be
    ///   selected.
    ///
    /// - `use_column_names`: Use column names instead of column IDs in the
    ///   returned output. This is generally discouraged as it is fragile. If
    ///   columns are renamed, code using original names may throw errors.
    ///
    /// - `value_format`: The format that cell values are returned as.
    pub async fn get_row<'a>(&'a self, doc_id: &'a str, table_id_or_name: &'a str, row_id_or_name: &'a str, use_column_names: Option<bool>, value_format: Option<types::ValueFormat>) -> Result<ResponseValue<types::RowDetail>, Error<types::GetRowResponse>> {
        let url = format!("{}/docs/{}/tables/{}/rows/{}", self.baseurl, encode_path(&doc_id.to_string()), encode_path(&table_id_or_name.to_string()), encode_path(&row_id_or_name.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .query(&progenitor_client::QueryParam::new("useColumnNames", &use_column_names))
            .query(&progenitor_client::QueryParam::new("valueFormat", &value_format))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_row",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update row
    ///
    ///Updates the specified row in the table. This endpoint will always return
    /// a 202, so long as the row exists and is accessible (and the update is
    /// structurally valid). Row updates are generally processed within several
    /// seconds. When updating using a name as opposed to an ID, an arbitrary
    /// row will be affected.
    ///
    ///
    ///Sends a `PUT` request to
    /// `/docs/{docId}/tables/{tableIdOrName}/rows/{rowIdOrName}`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    /// - `table_id_or_name`: ID or name of the table. Names are discouraged
    ///   because they're easily prone to being changed by users. If you're
    ///   using a name, be sure to URI-encode it.
    /// - `row_id_or_name`: ID or name of the row. Names are discouraged because
    ///   they're easily prone to being changed by users. If you're using a
    ///   name, be sure to URI-encode it. If there are multiple rows with the
    ///   same value in the identifying column, an arbitrary one will be
    ///   selected.
    ///
    /// - `disable_parsing`: If true, the API will not attempt to parse the data
    ///   in any way.
    /// - `body`: Row update.
    pub async fn update_row<'a>(&'a self, doc_id: &'a str, table_id_or_name: &'a str, row_id_or_name: &'a str, disable_parsing: Option<bool>, body: &'a types::RowUpdate) -> Result<ResponseValue<types::RowUpdateResult>, Error<types::UpdateRowResponse>> {
        let url = format!("{}/docs/{}/tables/{}/rows/{}", self.baseurl, encode_path(&doc_id.to_string()), encode_path(&table_id_or_name.to_string()), encode_path(&row_id_or_name.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .json(&body)
            .query(&progenitor_client::QueryParam::new("disableParsing", &disable_parsing))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_row",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Delete row
    ///
    ///Deletes the specified row from the table or view. This endpoint will
    /// always return a 202, so long as the row exists and is accessible (and
    /// the update is structurally valid). Row deletions are generally processed
    /// within several seconds. When deleting using a name as opposed to an ID,
    /// an arbitrary row will be removed.
    ///
    ///
    ///Sends a `DELETE` request to
    /// `/docs/{docId}/tables/{tableIdOrName}/rows/{rowIdOrName}`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    /// - `table_id_or_name`: ID or name of the table. Names are discouraged
    ///   because they're easily prone to being changed by users. If you're
    ///   using a name, be sure to URI-encode it.
    /// - `row_id_or_name`: ID or name of the row. Names are discouraged because
    ///   they're easily prone to being changed by users. If you're using a
    ///   name, be sure to URI-encode it. If there are multiple rows with the
    ///   same value in the identifying column, an arbitrary one will be
    ///   selected.
    pub async fn delete_row<'a>(&'a self, doc_id: &'a str, table_id_or_name: &'a str, row_id_or_name: &'a str) -> Result<ResponseValue<types::RowDeleteResult>, Error<types::DeleteRowResponse>> {
        let url = format!("{}/docs/{}/tables/{}/rows/{}", self.baseurl, encode_path(&doc_id.to_string()), encode_path(&table_id_or_name.to_string()), encode_path(&row_id_or_name.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "delete_row",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Push a button
    ///
    ///Pushes a button on a row in a table.
    ///Authorization note: This action is available to API tokens that are
    /// authorized to write to the table. However, the underlying button can
    /// perform any action on the document, including writing to other tables
    /// and performing Pack actions.
    ///
    ///
    ///Sends a `POST` request to
    /// `/docs/{docId}/tables/{tableIdOrName}/rows/{rowIdOrName}/buttons/
    /// {columnIdOrName}`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    /// - `table_id_or_name`: ID or name of the table. Names are discouraged
    ///   because they're easily prone to being changed by users. If you're
    ///   using a name, be sure to URI-encode it.
    /// - `row_id_or_name`: ID or name of the row. Names are discouraged because
    ///   they're easily prone to being changed by users. If you're using a
    ///   name, be sure to URI-encode it. If there are multiple rows with the
    ///   same value in the identifying column, an arbitrary one will be
    ///   selected.
    ///
    /// - `column_id_or_name`: ID or name of the column. Names are discouraged
    ///   because they're easily prone to being changed by users. If you're
    ///   using a name, be sure to URI-encode it.
    pub async fn push_button<'a>(&'a self, doc_id: &'a str, table_id_or_name: &'a str, row_id_or_name: &'a str, column_id_or_name: &'a str) -> Result<ResponseValue<types::PushButtonResult>, Error<types::PushButtonResponse>> {
        let url = format!("{}/docs/{}/tables/{}/rows/{}/buttons/{}", self.baseurl, encode_path(&doc_id.to_string()), encode_path(&table_id_or_name.to_string()), encode_path(&row_id_or_name.to_string()), encode_path(&column_id_or_name.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "push_button",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get a column
    ///
    ///Returns details about a column in a table.
    ///
    ///Sends a `GET` request to
    /// `/docs/{docId}/tables/{tableIdOrName}/columns/{columnIdOrName}`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    /// - `table_id_or_name`: ID or name of the table. Names are discouraged
    ///   because they're easily prone to being changed by users. If you're
    ///   using a name, be sure to URI-encode it.
    /// - `column_id_or_name`: ID or name of the column. Names are discouraged
    ///   because they're easily prone to being changed by users. If you're
    ///   using a name, be sure to URI-encode it.
    pub async fn get_column<'a>(&'a self, doc_id: &'a str, table_id_or_name: &'a str, column_id_or_name: &'a str) -> Result<ResponseValue<types::ColumnDetail>, Error<types::GetColumnResponse>> {
        let url = format!("{}/docs/{}/tables/{}/columns/{}", self.baseurl, encode_path(&doc_id.to_string()), encode_path(&table_id_or_name.to_string()), encode_path(&column_id_or_name.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_column",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List formulas
    ///
    ///Returns a list of named formulas in a Coda doc.
    ///
    ///Sends a `GET` request to `/docs/{docId}/formulas`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    /// - `limit`: Maximum number of results to return in this query.
    /// - `page_token`: An opaque token used to fetch the next page of results.
    /// - `sort_by`: Determines how to sort the given objects.
    pub async fn list_formulas<'a>(&'a self, doc_id: &'a str, limit: Option<::std::num::NonZeroU64>, page_token: Option<&'a str>, sort_by: Option<types::SortBy>) -> Result<ResponseValue<types::FormulaList>, Error<types::ListFormulasResponse>> {
        let url = format!("{}/docs/{}/formulas", self.baseurl, encode_path(&doc_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("pageToken", &page_token))
            .query(&progenitor_client::QueryParam::new("sortBy", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_formulas",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get a formula
    ///
    ///Returns info on a formula.
    ///
    ///Sends a `GET` request to `/docs/{docId}/formulas/{formulaIdOrName}`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    /// - `formula_id_or_name`: ID or name of the formula. Names are discouraged
    ///   because they're easily prone to being changed by users. If you're
    ///   using a name, be sure to URI-encode it.
    pub async fn get_formula<'a>(&'a self, doc_id: &'a str, formula_id_or_name: &'a str) -> Result<ResponseValue<types::Formula>, Error<types::GetFormulaResponse>> {
        let url = format!("{}/docs/{}/formulas/{}", self.baseurl, encode_path(&doc_id.to_string()), encode_path(&formula_id_or_name.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_formula",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List controls
    ///
    ///Returns a list of controls in a Coda doc.
    ///
    ///Sends a `GET` request to `/docs/{docId}/controls`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    /// - `limit`: Maximum number of results to return in this query.
    /// - `page_token`: An opaque token used to fetch the next page of results.
    /// - `sort_by`: Determines how to sort the given objects.
    pub async fn list_controls<'a>(&'a self, doc_id: &'a str, limit: Option<::std::num::NonZeroU64>, page_token: Option<&'a str>, sort_by: Option<types::SortBy>) -> Result<ResponseValue<types::ControlList>, Error<types::ListControlsResponse>> {
        let url = format!("{}/docs/{}/controls", self.baseurl, encode_path(&doc_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("pageToken", &page_token))
            .query(&progenitor_client::QueryParam::new("sortBy", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_controls",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get a control
    ///
    ///Returns info on a control.
    ///
    ///Sends a `GET` request to `/docs/{docId}/controls/{controlIdOrName}`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    /// - `control_id_or_name`: ID or name of the control. Names are discouraged
    ///   because they're easily prone to being changed by users. If you're
    ///   using a name, be sure to URI-encode it.
    pub async fn get_control<'a>(&'a self, doc_id: &'a str, control_id_or_name: &'a str) -> Result<ResponseValue<types::Control>, Error<types::GetControlResponse>> {
        let url = format!("{}/docs/{}/controls/{}", self.baseurl, encode_path(&doc_id.to_string()), encode_path(&control_id_or_name.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_control",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List custom doc domains
    ///
    ///List all custom domains for a published doc.
    ///
    ///Sends a `GET` request to `/docs/${docId}/domains`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    pub async fn list_custom_doc_domains<'a>(&'a self, doc_id: &'a str) -> Result<ResponseValue<types::CustomDocDomainList>, Error<types::ListCustomDocDomainsResponse>> {
        let url = format!("{}/docs/${}/domains", self.baseurl, encode_path(&doc_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_custom_doc_domains",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Add custom domain
    ///
    ///Add a custom domain to a published doc.
    ///
    ///Sends a `POST` request to `/docs/${docId}/domains`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    /// - `body`: Parameters for adding a custom domain to a published doc.
    pub async fn add_custom_doc_domain<'a>(&'a self, doc_id: &'a str, body: &'a types::AddCustomDocDomainRequest) -> Result<ResponseValue<types::AddCustomDocDomainResponse>, Error<types::AddCustomDocDomainResponse>> {
        let url = format!("{}/docs/${}/domains", self.baseurl, encode_path(&doc_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "add_custom_doc_domain",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Deletes a custom domain
    ///
    ///Deletes a custom domain from a published doc.
    ///
    ///Sends a `DELETE` request to `/docs/{docId}/domains/{customDocDomain}`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    /// - `custom_doc_domain`: A custom domain for a published doc.
    pub async fn delete_custom_doc_domain<'a>(&'a self, doc_id: &'a str, custom_doc_domain: &'a str) -> Result<ResponseValue<types::DeleteCustomDocDomainResponse>, Error<types::DeleteCustomDocDomainResponse>> {
        let url = format!("{}/docs/{}/domains/{}", self.baseurl, encode_path(&doc_id.to_string()), encode_path(&custom_doc_domain.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "delete_custom_doc_domain",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates a custom domain
    ///
    ///Updates properties of a document's custom domain.
    ///
    ///Sends a `PATCH` request to `/docs/{docId}/domains/{customDocDomain}`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    /// - `custom_doc_domain`: A custom domain for a published doc.
    /// - `body`: Properties of a custom domain to update.
    pub async fn update_custom_doc_domain<'a>(&'a self, doc_id: &'a str, custom_doc_domain: &'a str, body: &'a types::UpdateCustomDocDomainRequest) -> Result<ResponseValue<types::UpdateCustomDocDomainResponse>, Error<types::UpdateCustomDocDomainResponse>> {
        let url = format!("{}/docs/{}/domains/{}", self.baseurl, encode_path(&doc_id.to_string()), encode_path(&custom_doc_domain.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .patch(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_custom_doc_domain",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Gets custom doc domains providers
    ///
    ///Gets the provider (ie. GoDaddy) of a custom domain.
    ///
    ///Sends a `GET` request to `/domains/provider/{customDocDomain}`
    ///
    ///Arguments:
    /// - `custom_doc_domain`: A custom domain for a published doc.
    pub async fn get_custom_doc_domain_provider<'a>(&'a self, custom_doc_domain: &'a str) -> Result<ResponseValue<types::CustomDocDomainProviderResponse>, Error<types::GetCustomDocDomainProviderResponse>> {
        let url = format!("{}/domains/provider/{}", self.baseurl, encode_path(&custom_doc_domain.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_custom_doc_domain_provider",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get folder
    ///
    ///Returns the requested folder.
    ///
    ///
    ///Sends a `GET` request to `/folders/{folderId}`
    ///
    ///Arguments:
    /// - `folder_id`: ID of the folder.
    pub async fn get_folder<'a>(&'a self, folder_id: &'a str) -> Result<ResponseValue<types::Folder>, Error<types::GetFolderResponse>> {
        let url = format!("{}/folders/{}", self.baseurl, encode_path(&folder_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_folder",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get user info
    ///
    ///Returns basic info about the current user.
    ///
    ///Sends a `GET` request to `/whoami`
    pub async fn whoami<'a>(&'a self) -> Result<ResponseValue<types::User>, Error<types::WhoamiResponse>> {
        let url = format!("{}/whoami", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "whoami",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Resolve browser link
    ///
    ///Given a browser link to a Coda object, attempts to find it and return
    /// metadata that can be used to get more info on it. Returns a 400 if the
    /// URL does not appear to be a Coda URL or a 404 if the resource cannot be
    /// located with the current credentials.
    ///
    ///
    ///Sends a `GET` request to `/resolveBrowserLink`
    ///
    ///Arguments:
    /// - `degrade_gracefully`: By default, attempting to resolve the Coda URL
    ///   of a deleted object will result in an error. If this flag is set, the
    ///   next-available object, all the way up to the doc itself, will be
    ///   resolved.
    ///
    /// - `url`: The browser link to try to resolve.
    pub async fn resolve_browser_link<'a>(&'a self, degrade_gracefully: Option<bool>, url: &'a str) -> Result<ResponseValue<types::ApiLink>, Error<types::ResolveBrowserLinkResponse>> {
        let _url = format!("{}/resolveBrowserLink", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(_url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .query(&progenitor_client::QueryParam::new("degradeGracefully", &degrade_gracefully))
            .query(&progenitor_client::QueryParam::new("url", &url))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "resolve_browser_link",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get mutation status
    ///
    ///Get the status for an asynchronous mutation to know whether or not it
    /// has been completed. Each API endpoint that mutates a document will
    /// return a request id that you can pass to this endpoint to check the
    /// completion status. Status information is not guaranteed to be available
    /// for more than one day after the mutation was completed. It is intended
    /// to be used shortly after the request was made.
    ///
    ///
    ///Sends a `GET` request to `/mutationStatus/{requestId}`
    ///
    ///Arguments:
    /// - `request_id`: ID of the request.
    pub async fn get_mutation_status<'a>(&'a self, request_id: &'a str) -> Result<ResponseValue<types::MutationStatus>, Error<types::GetMutationStatusResponse>> {
        let url = format!("{}/mutationStatus/{}", self.baseurl, encode_path(&request_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_mutation_status",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Trigger automation
    ///
    ///Triggers webhook-invoked automation
    ///
    ///Sends a `POST` request to `/docs/{docId}/hooks/automation/{ruleId}`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    /// - `rule_id`: ID of the automation rule.
    /// - `body`: Payload for webhook
    pub async fn trigger_webhook_automation<'a>(&'a self, doc_id: &'a str, rule_id: &'a str, body: &'a types::WebhookTriggerPayload) -> Result<ResponseValue<types::WebhookTriggerResult>, Error<types::TriggerWebhookAutomationResponse>> {
        let url = format!("{}/docs/{}/hooks/automation/{}", self.baseurl, encode_path(&doc_id.to_string()), encode_path(&rule_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "trigger_webhook_automation",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            422u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List doc analytics
    ///
    ///Returns analytics data for available docs per day.
    ///
    ///
    ///Sends a `GET` request to `/analytics/docs`
    ///
    ///Arguments:
    /// - `direction`: Direction to sort results in.
    /// - `doc_ids`: List of docIds to fetch.
    /// - `is_published`: Limit results to only published items.
    /// - `limit`: Maximum number of results to return in this query.
    /// - `order_by`: Use this parameter to order the doc analytics returned.
    /// - `page_token`: An opaque token used to fetch the next page of results.
    /// - `query`: Search term used to filter down results.
    /// - `scale`: Quantization period over which to view analytics. Defaults to
    ///   daily.
    /// - `since_date`: Limit results to activity on or after this date.
    /// - `until_date`: Limit results to activity on or before this date.
    /// - `workspace_id`: ID of the workspace.
    pub async fn list_doc_analytics<'a>(&'a self, direction: Option<types::SortDirection>, doc_ids: Option<&'a ::std::vec::Vec<::std::string::String>>, is_published: Option<bool>, limit: Option<::std::num::NonZeroU64>, order_by: Option<types::DocAnalyticsOrderBy>, page_token: Option<&'a str>, query: Option<&'a str>, scale: Option<types::AnalyticsScale>, since_date: Option<&'a ::chrono::naive::NaiveDate>, until_date: Option<&'a ::chrono::naive::NaiveDate>, workspace_id: Option<&'a str>) -> Result<ResponseValue<types::DocAnalyticsCollection>, Error<types::ListDocAnalyticsResponse>> {
        let url = format!("{}/analytics/docs", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .query(&progenitor_client::QueryParam::new("direction", &direction))
            .query(&progenitor_client::QueryParam::new("docIds", &doc_ids))
            .query(&progenitor_client::QueryParam::new("isPublished", &is_published))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("orderBy", &order_by))
            .query(&progenitor_client::QueryParam::new("pageToken", &page_token))
            .query(&progenitor_client::QueryParam::new("query", &query))
            .query(&progenitor_client::QueryParam::new("scale", &scale))
            .query(&progenitor_client::QueryParam::new("sinceDate", &since_date))
            .query(&progenitor_client::QueryParam::new("untilDate", &until_date))
            .query(&progenitor_client::QueryParam::new("workspaceId", &workspace_id))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_doc_analytics",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List page analytics
    ///
    ///Returns analytics data for a given doc within the day.
    ///This method will return a 401 if the given doc is not in an Enterprise
    /// workspace.
    ///
    ///
    ///Sends a `GET` request to `/analytics/docs/{docId}/pages`
    ///
    ///Arguments:
    /// - `doc_id`: ID of the doc.
    /// - `limit`: Maximum number of results to return in this query.
    /// - `page_token`: An opaque token used to fetch the next page of results.
    /// - `since_date`: Limit results to activity on or after this date.
    /// - `until_date`: Limit results to activity on or before this date.
    pub async fn list_page_analytics<'a>(&'a self, doc_id: &'a str, limit: Option<::std::num::NonZeroU64>, page_token: Option<&'a str>, since_date: Option<&'a ::chrono::naive::NaiveDate>, until_date: Option<&'a ::chrono::naive::NaiveDate>) -> Result<ResponseValue<types::PageAnalyticsCollection>, Error<types::ListPageAnalyticsResponse>> {
        let url = format!("{}/analytics/docs/{}/pages", self.baseurl, encode_path(&doc_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("pageToken", &page_token))
            .query(&progenitor_client::QueryParam::new("sinceDate", &since_date))
            .query(&progenitor_client::QueryParam::new("untilDate", &until_date))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_page_analytics",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get doc analytics summary
    ///
    ///Returns summarized analytics data for available docs.
    ///
    ///
    ///Sends a `GET` request to `/analytics/docs/summary`
    ///
    ///Arguments:
    /// - `is_published`: Limit results to only published items.
    /// - `since_date`: Limit results to activity on or after this date.
    /// - `until_date`: Limit results to activity on or before this date.
    /// - `workspace_id`: ID of the workspace.
    pub async fn list_doc_analytics_summary<'a>(&'a self, is_published: Option<bool>, since_date: Option<&'a ::chrono::naive::NaiveDate>, until_date: Option<&'a ::chrono::naive::NaiveDate>, workspace_id: Option<&'a str>) -> Result<ResponseValue<types::DocAnalyticsSummary>, Error<types::ListDocAnalyticsSummaryResponse>> {
        let url = format!("{}/analytics/docs/summary", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .query(&progenitor_client::QueryParam::new("isPublished", &is_published))
            .query(&progenitor_client::QueryParam::new("sinceDate", &since_date))
            .query(&progenitor_client::QueryParam::new("untilDate", &until_date))
            .query(&progenitor_client::QueryParam::new("workspaceId", &workspace_id))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_doc_analytics_summary",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List Pack analytics
    ///
    ///Returns analytics data for Packs the user can edit.
    ///
    ///
    ///Sends a `GET` request to `/analytics/packs`
    ///
    ///Arguments:
    /// - `direction`: Direction to sort results in.
    /// - `is_published`: Limit results to only published items. If false or
    ///   unspecified, returns all items including published ones.
    ///
    /// - `limit`: Maximum number of results to return in this query.
    /// - `order_by`: Use this parameter to order the Pack analytics returned.
    /// - `pack_ids`: Which Pack IDs to fetch.
    /// - `page_token`: An opaque token used to fetch the next page of results.
    /// - `query`: Search term used to filter down results.
    /// - `scale`: Quantization period over which to view analytics. Defaults to
    ///   daily.
    /// - `since_date`: Limit results to activity on or after this date.
    /// - `until_date`: Limit results to activity on or before this date.
    /// - `workspace_id`: ID of the workspace.
    pub async fn list_pack_analytics<'a>(&'a self, direction: Option<types::SortDirection>, is_published: Option<bool>, limit: Option<::std::num::NonZeroU64>, order_by: Option<types::PackAnalyticsOrderBy>, pack_ids: Option<&'a ::std::vec::Vec<i64>>, page_token: Option<&'a str>, query: Option<&'a str>, scale: Option<types::AnalyticsScale>, since_date: Option<&'a ::chrono::naive::NaiveDate>, until_date: Option<&'a ::chrono::naive::NaiveDate>, workspace_id: Option<&'a str>) -> Result<ResponseValue<types::PackAnalyticsCollection>, Error<types::ListPackAnalyticsResponse>> {
        let url = format!("{}/analytics/packs", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .query(&progenitor_client::QueryParam::new("direction", &direction))
            .query(&progenitor_client::QueryParam::new("isPublished", &is_published))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("orderBy", &order_by))
            .query(&progenitor_client::QueryParam::new("packIds", &pack_ids))
            .query(&progenitor_client::QueryParam::new("pageToken", &page_token))
            .query(&progenitor_client::QueryParam::new("query", &query))
            .query(&progenitor_client::QueryParam::new("scale", &scale))
            .query(&progenitor_client::QueryParam::new("sinceDate", &since_date))
            .query(&progenitor_client::QueryParam::new("untilDate", &until_date))
            .query(&progenitor_client::QueryParam::new("workspaceId", &workspace_id))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_pack_analytics",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get Pack analytics summary
    ///
    ///Returns summarized analytics data for Packs the user can edit.
    ///
    ///
    ///Sends a `GET` request to `/analytics/packs/summary`
    ///
    ///Arguments:
    /// - `is_published`: Limit results to only published items. If false or
    ///   unspecified, returns all items including published ones.
    ///
    /// - `pack_ids`: Which Pack IDs to fetch.
    /// - `since_date`: Limit results to activity on or after this date.
    /// - `until_date`: Limit results to activity on or before this date.
    /// - `workspace_id`: ID of the workspace.
    pub async fn list_pack_analytics_summary<'a>(&'a self, is_published: Option<bool>, pack_ids: Option<&'a ::std::vec::Vec<i64>>, since_date: Option<&'a ::chrono::naive::NaiveDate>, until_date: Option<&'a ::chrono::naive::NaiveDate>, workspace_id: Option<&'a str>) -> Result<ResponseValue<types::PackAnalyticsSummary>, Error<types::ListPackAnalyticsSummaryResponse>> {
        let url = format!("{}/analytics/packs/summary", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .query(&progenitor_client::QueryParam::new("isPublished", &is_published))
            .query(&progenitor_client::QueryParam::new("packIds", &pack_ids))
            .query(&progenitor_client::QueryParam::new("sinceDate", &since_date))
            .query(&progenitor_client::QueryParam::new("untilDate", &until_date))
            .query(&progenitor_client::QueryParam::new("workspaceId", &workspace_id))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_pack_analytics_summary",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List Pack formula analytics
    ///
    ///Returns analytics data for Pack formulas.
    ///
    ///
    ///Sends a `GET` request to `/analytics/packs/{packId}/formulas`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    /// - `direction`: Direction to sort results in.
    /// - `limit`: Maximum number of results to return in this query.
    /// - `order_by`: Use this parameter to order the Pack formula analytics
    ///   returned.
    /// - `pack_formula_names`: A list of Pack formula names (case-sensitive)
    ///   for which to retrieve analytics.
    /// - `pack_formula_types`: A list of Pack formula types corresponding to
    ///   the `packFormulaNames`. If specified, this must have the same length
    ///   as `packFormulaNames`.
    /// - `page_token`: An opaque token used to fetch the next page of results.
    /// - `scale`: Quantization period over which to view analytics. Defaults to
    ///   daily.
    /// - `since_date`: Limit results to activity on or after this date.
    /// - `until_date`: Limit results to activity on or before this date.
    pub async fn list_pack_formula_analytics<'a>(&'a self, pack_id: ::std::num::NonZeroU64, direction: Option<types::SortDirection>, limit: Option<::std::num::NonZeroU64>, order_by: Option<types::PackFormulaAnalyticsOrderBy>, pack_formula_names: Option<&'a ::std::vec::Vec<::std::string::String>>, pack_formula_types: Option<&'a ::std::vec::Vec<types::PackFormulaType>>, page_token: Option<&'a str>, scale: Option<types::AnalyticsScale>, since_date: Option<&'a ::chrono::naive::NaiveDate>, until_date: Option<&'a ::chrono::naive::NaiveDate>) -> Result<ResponseValue<types::PackFormulaAnalyticsCollection>, Error<types::ListPackFormulaAnalyticsResponse>> {
        let url = format!("{}/analytics/packs/{}/formulas", self.baseurl, encode_path(&pack_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .query(&progenitor_client::QueryParam::new("direction", &direction))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("orderBy", &order_by))
            .query(&progenitor_client::QueryParam::new("packFormulaNames", &pack_formula_names))
            .query(&progenitor_client::QueryParam::new("packFormulaTypes", &pack_formula_types))
            .query(&progenitor_client::QueryParam::new("pageToken", &page_token))
            .query(&progenitor_client::QueryParam::new("scale", &scale))
            .query(&progenitor_client::QueryParam::new("sinceDate", &since_date))
            .query(&progenitor_client::QueryParam::new("untilDate", &until_date))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_pack_formula_analytics",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get analytics last updated day
    ///
    ///Returns days based on Pacific Standard Time when analytics were last
    /// updated.
    ///
    ///
    ///Sends a `GET` request to `/analytics/updated`
    pub async fn get_analytics_last_updated<'a>(&'a self) -> Result<ResponseValue<types::AnalyticsLastUpdatedResponse>, Error<types::GetAnalyticsLastUpdatedResponse>> {
        let url = format!("{}/analytics/updated", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_analytics_last_updated",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List workspace users
    ///
    ///Returns a list of members in the given workspace. This list will be
    /// ordered with the requesting user first and then ordered by role.
    ///
    ///
    ///Sends a `GET` request to `/workspaces/{workspaceId}/users`
    ///
    ///Arguments:
    /// - `workspace_id`: ID of the workspace.
    /// - `included_roles`: Show only the members that match the included roles.
    ///   Multiple roles can be specified with a comma-delimited list.
    /// - `page_token`: An opaque token used to fetch the next page of results.
    pub async fn list_workspace_members<'a>(&'a self, workspace_id: &'a str, included_roles: Option<&'a ::std::vec::Vec<types::WorkspaceUserRole>>, page_token: Option<&'a str>) -> Result<ResponseValue<types::WorkspaceMembersList>, Error<types::ListWorkspaceMembersResponse>> {
        let url = format!("{}/workspaces/{}/users", self.baseurl, encode_path(&workspace_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .query(&progenitor_client::QueryParam::new("includedRoles", &included_roles))
            .query(&progenitor_client::QueryParam::new("pageToken", &page_token))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_workspace_members",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Updates user role
    ///
    ///Updates the workspace user role of a user that matches the parameters.
    /// Only succeeds if the requesting user has admin permissions in the
    /// workspace.
    ///
    ///
    ///Sends a `POST` request to `/workspaces/{workspaceId}/users/role`
    ///
    ///Arguments:
    /// - `workspace_id`: ID of the workspace.
    /// - `body`: Parameters for changing the user role.
    pub async fn change_user_role<'a>(&'a self, workspace_id: &'a str, body: &'a types::ChangeRole) -> Result<ResponseValue<types::ChangeRoleResult>, Error<types::ChangeUserRoleResponse>> {
        let url = format!("{}/workspaces/{}/users/role", self.baseurl, encode_path(&workspace_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "change_user_role",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List workspace roles
    ///
    ///Returns a list of the counts of users over time by role for the
    /// workspace.
    ///
    ///
    ///Sends a `GET` request to `/workspaces/{workspaceId}/roles`
    ///
    ///Arguments:
    /// - `workspace_id`: ID of the workspace.
    pub async fn list_workspace_role_activity<'a>(&'a self, workspace_id: &'a str) -> Result<ResponseValue<types::GetWorkspaceRoleActivity>, Error<types::ListWorkspaceRoleActivityResponse>> {
        let url = format!("{}/workspaces/{}/roles", self.baseurl, encode_path(&workspace_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_workspace_role_activity",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List Packs
    ///
    ///Get the list of accessible Packs.
    ///
    ///
    ///Sends a `GET` request to `/packs`
    ///
    ///Arguments:
    /// - `access_type`: Deprecated, use accessTypes instead. Filter to only
    ///   return the Packs for which the current user has this access type
    /// - `access_types`: Filter to only return the Packs for which the current
    ///   user has these access types.
    /// - `direction`: Direction to sort results in.
    /// - `exclude_individual_acls`: Do not include Packs that are only shared
    ///   with the user individually.
    /// - `exclude_public_packs`: Only get Packs shared with users/workspaces,
    ///   not publicly.
    /// - `exclude_workspace_acls`: Do not include Packs that are only shared
    ///   with workspaces.
    /// - `include_brain_only_packs`: Include Packs that only support Coda
    ///   Brain.
    /// - `limit`: Maximum number of results to return in this query.
    /// - `only_workspace_id`: Use only this workspace (not all of a user's
    ///   workspaces) to check for Packs shared via workspace ACL.
    /// - `page_token`: An opaque token used to fetch the next page of results.
    /// - `parent_workspace_ids`: Filter to only Packs whose parent workspace is
    ///   one of the given IDs.
    /// - `sort_by`: The sort order of the Packs returned.
    pub async fn list_packs<'a>(&'a self, access_type: Option<types::PackAccessType>, access_types: Option<&'a ::std::vec::Vec<types::PackAccessType>>, direction: Option<types::SortDirection>, exclude_individual_acls: Option<bool>, exclude_public_packs: Option<bool>, exclude_workspace_acls: Option<bool>, include_brain_only_packs: Option<bool>, limit: Option<::std::num::NonZeroU64>, only_workspace_id: Option<&'a str>, page_token: Option<&'a str>, parent_workspace_ids: Option<&'a ::std::vec::Vec<::std::string::String>>, sort_by: Option<types::PacksSortBy>) -> Result<ResponseValue<types::PackSummaryList>, Error<types::ListPacksResponse>> {
        let url = format!("{}/packs", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .query(&progenitor_client::QueryParam::new("accessType", &access_type))
            .query(&progenitor_client::QueryParam::new("accessTypes", &access_types))
            .query(&progenitor_client::QueryParam::new("direction", &direction))
            .query(&progenitor_client::QueryParam::new("excludeIndividualAcls", &exclude_individual_acls))
            .query(&progenitor_client::QueryParam::new("excludePublicPacks", &exclude_public_packs))
            .query(&progenitor_client::QueryParam::new("excludeWorkspaceAcls", &exclude_workspace_acls))
            .query(&progenitor_client::QueryParam::new("includeBrainOnlyPacks", &include_brain_only_packs))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("onlyWorkspaceId", &only_workspace_id))
            .query(&progenitor_client::QueryParam::new("pageToken", &page_token))
            .query(&progenitor_client::QueryParam::new("parentWorkspaceIds", &parent_workspace_ids))
            .query(&progenitor_client::QueryParam::new("sortBy", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_packs",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create Pack
    ///
    ///Creates a new Pack, essentially registering a new Pack ID. The contents
    /// of the Pack will be uploaded separately.
    ///
    ///
    ///Sends a `POST` request to `/packs`
    ///
    ///Arguments:
    /// - `body`: Parameters for creating the Pack.
    pub async fn create_pack<'a>(&'a self, body: &'a types::CreatePackRequest) -> Result<ResponseValue<types::CreatePackResponse>, Error<types::CreatePackResponse>> {
        let url = format!("{}/packs", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_pack",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get a single Pack
    ///
    ///Returns a single Pack.
    ///
    ///
    ///Sends a `GET` request to `/packs/{packId}`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    pub async fn get_pack<'a>(&'a self, pack_id: ::std::num::NonZeroU64) -> Result<ResponseValue<types::Pack>, Error<types::GetPackResponse>> {
        let url = format!("{}/packs/{}", self.baseurl, encode_path(&pack_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_pack",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Delete Pack
    ///
    ///Delete a given Pack.
    ///
    ///
    ///Sends a `DELETE` request to `/packs/{packId}`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    pub async fn delete_pack<'a>(&'a self, pack_id: ::std::num::NonZeroU64) -> Result<ResponseValue<types::DeletePackResponse>, Error<types::DeletePackResponse>> {
        let url = format!("{}/packs/{}", self.baseurl, encode_path(&pack_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "delete_pack",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update Pack
    ///
    ///Update an existing Pack for non-versioned fields.
    ///
    ///
    ///Sends a `PATCH` request to `/packs/{packId}`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    /// - `body`: Parameters for updating the Pack.
    pub async fn update_pack<'a>(&'a self, pack_id: ::std::num::NonZeroU64, body: &'a types::UpdatePackRequest) -> Result<ResponseValue<types::Pack>, Error<types::UpdatePackResponse>> {
        let url = format!("{}/packs/{}", self.baseurl, encode_path(&pack_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .patch(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_pack",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Gets the JSON Schema for Pack configuration
    ///
    ///Returns a JSON Schema applicable for customizing the pack using Pack
    /// configurations.
    ///
    ///
    ///Sends a `GET` request to `/packs/{packId}/configurations/schema`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    pub async fn get_pack_configuration_schema<'a>(&'a self, pack_id: ::std::num::NonZeroU64) -> Result<ResponseValue<types::GetPackConfigurationJsonSchemaResponse>, Error<types::GetPackConfigurationSchemaResponse>> {
        let url = format!("{}/packs/{}/configurations/schema", self.baseurl, encode_path(&pack_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_pack_configuration_schema",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List the versions for a Pack
    ///
    ///Get the list of versions of a Pack.
    ///
    ///
    ///Sends a `GET` request to `/packs/{packId}/versions`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    /// - `limit`: Maximum number of results to return in this query.
    /// - `page_token`: An opaque token used to fetch the next page of results.
    pub async fn list_pack_versions<'a>(&'a self, pack_id: ::std::num::NonZeroU64, limit: Option<::std::num::NonZeroU64>, page_token: Option<&'a str>) -> Result<ResponseValue<types::PackVersionList>, Error<types::ListPackVersionsResponse>> {
        let url = format!("{}/packs/{}/versions", self.baseurl, encode_path(&pack_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("pageToken", &page_token))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_pack_versions",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get the next valid version for a Pack
    ///
    ///Get the next valid version based on the proposed metadata.
    ///
    ///
    ///Sends a `POST` request to `/packs/{packId}/nextVersion`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    /// - `body`
    pub async fn get_next_pack_version<'a>(&'a self, pack_id: ::std::num::NonZeroU64, body: &'a types::GetNextPackVersionRequest) -> Result<ResponseValue<types::NextPackVersionInfo>, Error<types::GetNextPackVersionResponse>> {
        let url = format!("{}/packs/{}/nextVersion", self.baseurl, encode_path(&pack_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_next_pack_version",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get the difference between two pack versions
    ///
    ///Gets information about the difference between the specified previous
    /// version and next version of a Pack.
    ///
    ///
    ///Sends a `GET` request to
    /// `/packs/{packId}/versions/{basePackVersion}/diff/{targetPackVersion}`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    /// - `base_pack_version`: Semantic version of the previous Pack version.
    /// - `target_pack_version`: Semantic version of the new Pack version.
    pub async fn get_pack_version_diffs<'a>(&'a self, pack_id: ::std::num::NonZeroU64, base_pack_version: &'a str, target_pack_version: &'a str) -> Result<ResponseValue<types::PackVersionDiffs>, Error<types::GetPackVersionDiffsResponse>> {
        let url = format!("{}/packs/{}/versions/{}/diff/{}", self.baseurl, encode_path(&pack_id.to_string()), encode_path(&base_pack_version.to_string()), encode_path(&target_pack_version.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_pack_version_diffs",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Register Pack version
    ///
    ///Registers a new Pack version. This simply returns a signed URL to use
    /// for uploading the Pack version definition. Following the completion of
    /// the upload, POST to /apis/v1/packs/{packId}/versions/{packVersion}
    /// trigger the rest of the creation process.
    ///
    ///
    ///Sends a `POST` request to
    /// `/packs/{packId}/versions/{packVersion}/register`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    /// - `pack_version`: Semantic version of a Pack
    /// - `body`: Parameters for registering the Pack.
    pub async fn register_pack_version<'a>(&'a self, pack_id: ::std::num::NonZeroU64, pack_version: &'a str, body: &'a types::RegisterPackVersionRequest) -> Result<ResponseValue<types::PackVersionUploadInfo>, Error<types::RegisterPackVersionResponse>> {
        let url = format!("{}/packs/{}/versions/{}/register", self.baseurl, encode_path(&pack_id.to_string()), encode_path(&pack_version.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "register_pack_version",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Pack version upload complete
    ///
    ///Note the completion of the upload of a Pack version bundle in order to
    /// create that Pack version.
    ///
    ///
    ///Sends a `POST` request to
    /// `/packs/{packId}/versions/{packVersion}/uploadComplete`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    /// - `pack_version`: Semantic version of a Pack
    /// - `body`: Parameters for Pack version upload complete.
    pub async fn pack_version_upload_complete<'a>(&'a self, pack_id: ::std::num::NonZeroU64, pack_version: &'a str, body: &'a types::CreatePackVersionRequest) -> Result<ResponseValue<types::CreatePackVersionResponse>, Error<types::PackVersionUploadCompleteResponse>> {
        let url = format!("{}/packs/{}/versions/{}/uploadComplete", self.baseurl, encode_path(&pack_id.to_string()), encode_path(&pack_version.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "pack_version_upload_complete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List the releases for a Pack
    ///
    ///Get the list of releases of a Pack.
    ///
    ///
    ///Sends a `GET` request to `/packs/{packId}/releases`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    /// - `limit`: Maximum number of results to return in this query.
    /// - `page_token`: An opaque token used to fetch the next page of results.
    pub async fn list_pack_releases<'a>(&'a self, pack_id: ::std::num::NonZeroU64, limit: Option<::std::num::NonZeroU64>, page_token: Option<&'a str>) -> Result<ResponseValue<types::PackReleaseList>, Error<types::ListPackReleasesResponse>> {
        let url = format!("{}/packs/{}/releases", self.baseurl, encode_path(&pack_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("pageToken", &page_token))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_pack_releases",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create a new Pack release
    ///
    ///Creates a new Pack release based on an existing Pack version.
    ///
    ///
    ///Sends a `POST` request to `/packs/{packId}/releases`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    /// - `body`: Parameters to create the Pack release.
    pub async fn create_pack_release<'a>(&'a self, pack_id: ::std::num::NonZeroU64, body: &'a types::CreatePackReleaseRequest) -> Result<ResponseValue<types::PackRelease>, Error<types::CreatePackReleaseResponse>> {
        let url = format!("{}/packs/{}/releases", self.baseurl, encode_path(&pack_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_pack_release",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update an existing Pack release
    ///
    ///Update details of a Pack release.
    ///
    ///
    ///Sends a `PUT` request to `/packs/{packId}/releases/{packReleaseId}`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    /// - `pack_release_id`: ID of a Pack release
    /// - `body`: Parameters to update the Pack release.
    pub async fn update_pack_release<'a>(&'a self, pack_id: ::std::num::NonZeroU64, pack_release_id: ::std::num::NonZeroU64, body: &'a types::UpdatePackReleaseRequest) -> Result<ResponseValue<types::PackRelease>, Error<types::UpdatePackReleaseResponse>> {
        let url = format!("{}/packs/{}/releases/{}", self.baseurl, encode_path(&pack_id.to_string()), encode_path(&pack_release_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_pack_release",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieve the OAuth configuration of the Pack
    ///
    ///Retrieve the OAuth configuration of the Pack for display purpose.
    /// Secrets will be returned with masks.
    ///
    ///
    ///Sends a `GET` request to `/packs/{packId}/oauthConfig`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    pub async fn get_pack_oauth_config<'a>(&'a self, pack_id: ::std::num::NonZeroU64) -> Result<ResponseValue<types::PackOauthConfigMetadata>, Error<types::GetPackOauthConfigResponse>> {
        let url = format!("{}/packs/{}/oauthConfig", self.baseurl, encode_path(&pack_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_pack_oauth_config",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Set the OAuth configurations of the Pack
    ///
    ///Set the OAuth configurations of the Pack, including client id and
    /// secret.
    ///
    ///
    ///Sends a `PUT` request to `/packs/{packId}/oauthConfig`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    /// - `body`: Parameters to set the Pack OAuth configuration.
    pub async fn set_pack_oauth_config<'a>(&'a self, pack_id: ::std::num::NonZeroU64, body: &'a types::SetPackOauthConfigRequest) -> Result<ResponseValue<types::PackOauthConfigMetadata>, Error<types::SetPackOauthConfigResponse>> {
        let url = format!("{}/packs/{}/oauthConfig", self.baseurl, encode_path(&pack_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "set_pack_oauth_config",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieve the system connection metadata of the Pack
    ///
    ///Retrieve the system connection metadata of the Pack.
    ///
    ///
    ///Sends a `GET` request to `/packs/{packId}/systemConnection`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    pub async fn get_pack_system_connection<'a>(&'a self, pack_id: ::std::num::NonZeroU64) -> Result<ResponseValue<types::PackSystemConnectionMetadata>, Error<types::GetPackSystemConnectionResponse>> {
        let url = format!("{}/packs/{}/systemConnection", self.baseurl, encode_path(&pack_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_pack_system_connection",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Set the system connection credentials of the Pack
    ///
    ///Set the system connection credentials of the Pack.
    ///
    ///
    ///Sends a `PUT` request to `/packs/{packId}/systemConnection`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    /// - `body`: Parameters to set the Pack system connection credentials.
    pub async fn set_pack_system_connection<'a>(&'a self, pack_id: ::std::num::NonZeroU64, body: &'a types::SetPackSystemConnectionRequest) -> Result<ResponseValue<types::PackSystemConnectionMetadata>, Error<types::SetPackSystemConnectionResponse>> {
        let url = format!("{}/packs/{}/systemConnection", self.baseurl, encode_path(&pack_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "set_pack_system_connection",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Patch the system connection credentials of the Pack
    ///
    ///Patch the system connection credentials of the Pack.
    ///
    ///
    ///Sends a `PATCH` request to `/packs/{packId}/systemConnection`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    /// - `body`: Parameters to patch the Pack system connection credentials.
    pub async fn patch_pack_system_connection<'a>(&'a self, pack_id: ::std::num::NonZeroU64, body: &'a types::PatchPackSystemConnectionRequest) -> Result<ResponseValue<types::PackSystemConnectionMetadata>, Error<types::PatchPackSystemConnectionResponse>> {
        let url = format!("{}/packs/{}/systemConnection", self.baseurl, encode_path(&pack_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .patch(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "patch_pack_system_connection",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List permissions for a Pack
    ///
    ///Get user, workspace, and/or global permissions for a given Pack.
    ///
    ///
    ///Sends a `GET` request to `/packs/{packId}/permissions`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    pub async fn get_pack_permissions<'a>(&'a self, pack_id: ::std::num::NonZeroU64) -> Result<ResponseValue<types::PackPermissionList>, Error<types::GetPackPermissionsResponse>> {
        let url = format!("{}/packs/{}/permissions", self.baseurl, encode_path(&pack_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_pack_permissions",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Add a permission for Pack
    ///
    ///Create or modify user, workspace, or global permissions for a given
    /// Pack.
    ///
    ///
    ///Sends a `POST` request to `/packs/{packId}/permissions`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    /// - `body`: Parameters for creating/updating Pack permissions.
    pub async fn add_pack_permission<'a>(&'a self, pack_id: ::std::num::NonZeroU64, body: &'a types::AddPackPermissionRequest) -> Result<ResponseValue<types::AddPackPermissionResponse>, Error<types::AddPackPermissionResponse>> {
        let url = format!("{}/packs/{}/permissions", self.baseurl, encode_path(&pack_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "add_pack_permission",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Delete a permission for Pack
    ///
    ///Delete user, workspace, or global permissions for a given Pack.
    ///
    ///
    ///Sends a `DELETE` request to `/packs/{packId}/permissions/{permissionId}`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    /// - `permission_id`: ID of a permission on a doc.
    pub async fn delete_pack_permission<'a>(&'a self, pack_id: ::std::num::NonZeroU64, permission_id: &'a str) -> Result<ResponseValue<types::DeletePackPermissionResponse>, Error<types::DeletePackPermissionResponse>> {
        let url = format!("{}/packs/{}/permissions/{}", self.baseurl, encode_path(&pack_id.to_string()), encode_path(&permission_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "delete_pack_permission",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List makers for Pack
    ///
    ///List makers for a given pack.
    ///
    ///
    ///Sends a `GET` request to `/packs/{packId}/makers`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    pub async fn list_pack_makers<'a>(&'a self, pack_id: ::std::num::NonZeroU64) -> Result<ResponseValue<types::ListPackMakersResponse>, Error<types::ListPackMakersResponse>> {
        let url = format!("{}/packs/{}/makers", self.baseurl, encode_path(&pack_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_pack_makers",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Add a maker for Pack
    ///
    ///Set a maker for a given Pack. Used to display makers for a pack in the
    /// corresponding packs page.
    ///
    ///
    ///Sends a `POST` request to `/packs/{packId}/maker`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    /// - `body`: Payload for adding a Pack maker.
    pub async fn add_pack_maker<'a>(&'a self, pack_id: ::std::num::NonZeroU64, body: &'a types::AddPackMakerRequest) -> Result<ResponseValue<types::AddPackMakerResponse>, Error<types::AddPackMakerResponse>> {
        let url = format!("{}/packs/{}/maker", self.baseurl, encode_path(&pack_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "add_pack_maker",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Delete a maker for Pack
    ///
    ///Delete a maker for a given Pack, who will not be displayed in the
    /// corresponding packs page.
    ///
    ///
    ///Sends a `DELETE` request to `/packs/{packId}/maker/{loginId}`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    /// - `login_id`: Email of a Coda user.
    pub async fn delete_pack_maker<'a>(&'a self, pack_id: ::std::num::NonZeroU64, login_id: &'a str) -> Result<ResponseValue<types::DeletePackMakerResponse>, Error<types::DeletePackMakerResponse>> {
        let url = format!("{}/packs/{}/maker/{}", self.baseurl, encode_path(&pack_id.to_string()), encode_path(&login_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "delete_pack_maker",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List categories for Pack
    ///
    ///List publishing categories for a given pack.
    ///
    ///
    ///Sends a `GET` request to `/packs/{packId}/categories`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    pub async fn list_pack_categories<'a>(&'a self, pack_id: ::std::num::NonZeroU64) -> Result<ResponseValue<types::ListPackCategoriesResponse>, Error<types::ListPackCategoriesResponse>> {
        let url = format!("{}/packs/{}/categories", self.baseurl, encode_path(&pack_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_pack_categories",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Add a category for Pack
    ///
    ///Add a publishing category for a given pack.
    ///
    ///
    ///Sends a `POST` request to `/packs/{packId}/category`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    /// - `body`: Payload for adding a Pack category.
    pub async fn add_pack_category<'a>(&'a self, pack_id: ::std::num::NonZeroU64, body: &'a types::AddPackCategoryRequest) -> Result<ResponseValue<types::AddPackCategoryResponse>, Error<types::AddPackCategoryResponse>> {
        let url = format!("{}/packs/{}/category", self.baseurl, encode_path(&pack_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "add_pack_category",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Delete a category for Pack
    ///
    ///Delete a publishing category for a given pack.
    ///
    ///
    ///Sends a `DELETE` request to `/packs/{packId}/category/{categoryName}`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    /// - `category_name`: Name of a publishing category
    pub async fn delete_pack_category<'a>(&'a self, pack_id: ::std::num::NonZeroU64, category_name: &'a str) -> Result<ResponseValue<types::DeletePackCategoryResponse>, Error<types::DeletePackCategoryResponse>> {
        let url = format!("{}/packs/{}/category/{}", self.baseurl, encode_path(&pack_id.to_string()), encode_path(&category_name.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "delete_pack_category",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Upload a Pack asset
    ///
    ///Request a signed s3 URL to upload your Pack asset.
    ///
    ///
    ///Sends a `POST` request to `/packs/{packId}/uploadAsset`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    /// - `body`: Parameters to specify the asset being uploaded.
    pub async fn upload_pack_asset<'a>(&'a self, pack_id: ::std::num::NonZeroU64, body: &'a types::UploadPackAssetRequest) -> Result<ResponseValue<types::PackAssetUploadInfo>, Error<types::UploadPackAssetResponse>> {
        let url = format!("{}/packs/{}/uploadAsset", self.baseurl, encode_path(&pack_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "upload_pack_asset",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Upload Pack source code
    ///
    ///Request a signed s3 URL to upload your Pack source code.
    ///
    ///
    ///Sends a `POST` request to `/packs/{packId}/uploadSourceCode`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    /// - `body`: Parameters to specify the source code being uploaded.
    pub async fn upload_pack_source_code<'a>(&'a self, pack_id: ::std::num::NonZeroU64, body: &'a types::UploadPackSourceCodeRequest) -> Result<ResponseValue<types::PackSourceCodeUploadInfo>, Error<types::UploadPackSourceCodeResponse>> {
        let url = format!("{}/packs/{}/uploadSourceCode", self.baseurl, encode_path(&pack_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "upload_pack_source_code",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Pack asset upload complete
    ///
    ///Note the completion of the upload of a Pack asset.
    ///
    ///
    ///Sends a `POST` request to
    /// `/packs/{packId}/assets/{packAssetId}/assetType/{packAssetType}/
    /// uploadComplete`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    /// - `pack_asset_id`: Unique identifier for a Pack asset.
    /// - `pack_asset_type`: Pack asset type.
    pub async fn pack_asset_upload_complete<'a>(&'a self, pack_id: ::std::num::NonZeroU64, pack_asset_id: &'a str, pack_asset_type: types::PackAssetType) -> Result<ResponseValue<types::PackAssetUploadCompleteResponse>, Error<types::PackAssetUploadCompleteResponse>> {
        let url = format!("{}/packs/{}/assets/{}/assetType/{}/uploadComplete", self.baseurl, encode_path(&pack_id.to_string()), encode_path(&pack_asset_id.to_string()), encode_path(&pack_asset_type.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "pack_asset_upload_complete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Pack source code upload complete
    ///
    ///Note the completion of the upload of a Pack source code.
    ///
    ///
    ///Sends a `POST` request to
    /// `/packs/{packId}/versions/{packVersion}/sourceCode/uploadComplete`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    /// - `pack_version`: Semantic version of a Pack
    /// - `body`: Parameters to specify the source code being uploaded.
    pub async fn pack_source_code_upload_complete<'a>(&'a self, pack_id: ::std::num::NonZeroU64, pack_version: &'a str, body: &'a types::PackSourceCodeUploadCompleteRequest) -> Result<ResponseValue<types::PackSourceCodeUploadCompleteResponse>, Error<types::PackSourceCodeUploadCompleteResponse>> {
        let url = format!("{}/packs/{}/versions/{}/sourceCode/uploadComplete", self.baseurl, encode_path(&pack_id.to_string()), encode_path(&pack_version.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "pack_source_code_upload_complete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///get the source code for a Pack version
    ///
    ///Get temporary links used to download the source code for the given
    /// packId and version
    ///
    ///
    ///Sends a `GET` request to
    /// `/packs/{packId}/versions/{packVersion}/sourceCode`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    /// - `pack_version`: Semantic version of a Pack
    pub async fn get_pack_source_code<'a>(&'a self, pack_id: ::std::num::NonZeroU64, pack_version: &'a str) -> Result<ResponseValue<types::PackSourceCodeInfo>, Error<types::GetPackSourceCodeResponse>> {
        let url = format!("{}/packs/{}/versions/{}/sourceCode", self.baseurl, encode_path(&pack_id.to_string()), encode_path(&pack_version.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_pack_source_code",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List the Pack listings accessible to a user
    ///
    ///Get listings of public Packs and Packs created by you.
    ///
    ///
    ///Sends a `GET` request to `/packs/listings`
    ///
    ///Arguments:
    /// - `direction`: Direction to sort results in.
    /// - `exclude_individual_acls`: Do not include Packs that are only shared
    ///   with the user individually.
    /// - `exclude_public_packs`: Only get Packs shared with users/workspaces,
    ///   not publicly.
    /// - `exclude_workspace_acls`: Do not include Packs that are only shared
    ///   with workspaces.
    /// - `include_brain_only_packs`: Include Packs that only support Coda
    ///   Brain.
    /// - `install_context`: Type of installation context for which Pack
    ///   information is being requested.
    /// - `limit`: Maximum number of results to return in this query.
    /// - `only_workspace_id`: Use only this workspace (not all of a user's
    ///   workspaces) to check for Packs shared via workspace ACL.
    /// - `order_by`: Deprecated: use sortBy instead.
    /// - `pack_access_types`: Pack access types.
    /// - `pack_ids`: Which Pack IDs to fetch.
    /// - `page_token`: An opaque token used to fetch the next page of results.
    /// - `parent_workspace_ids`: Filter to only Packs whose parent workspace is
    ///   one of the given IDs.
    /// - `sort_by`: Specify a sort order for the returned Pack listings
    ///   returned.
    pub async fn list_pack_listings<'a>(&'a self, direction: Option<types::SortDirection>, exclude_individual_acls: Option<bool>, exclude_public_packs: Option<bool>, exclude_workspace_acls: Option<bool>, include_brain_only_packs: Option<bool>, install_context: Option<types::PackListingInstallContextType>, limit: Option<::std::num::NonZeroU64>, only_workspace_id: Option<&'a str>, order_by: Option<types::PackListingsSortBy>, pack_access_types: Option<&'a types::PackAccessTypes>, pack_ids: Option<&'a ::std::vec::Vec<i64>>, page_token: Option<&'a str>, parent_workspace_ids: Option<&'a ::std::vec::Vec<::std::string::String>>, sort_by: Option<types::PackListingsSortBy>) -> Result<ResponseValue<types::PackListingList>, Error<types::ListPackListingsResponse>> {
        let url = format!("{}/packs/listings", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .query(&progenitor_client::QueryParam::new("direction", &direction))
            .query(&progenitor_client::QueryParam::new("excludeIndividualAcls", &exclude_individual_acls))
            .query(&progenitor_client::QueryParam::new("excludePublicPacks", &exclude_public_packs))
            .query(&progenitor_client::QueryParam::new("excludeWorkspaceAcls", &exclude_workspace_acls))
            .query(&progenitor_client::QueryParam::new("includeBrainOnlyPacks", &include_brain_only_packs))
            .query(&progenitor_client::QueryParam::new("installContext", &install_context))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("onlyWorkspaceId", &only_workspace_id))
            .query(&progenitor_client::QueryParam::new("orderBy", &order_by))
            .query(&progenitor_client::QueryParam::new("packAccessTypes", &pack_access_types))
            .query(&progenitor_client::QueryParam::new("packIds", &pack_ids))
            .query(&progenitor_client::QueryParam::new("pageToken", &page_token))
            .query(&progenitor_client::QueryParam::new("parentWorkspaceIds", &parent_workspace_ids))
            .query(&progenitor_client::QueryParam::new("sortBy", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_pack_listings",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get detailed listing information for a Pack
    ///
    ///Get detailed listing information for a Pack.
    ///
    ///
    ///Sends a `GET` request to `/packs/{packId}/listing`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    /// - `doc_id`: ID of the target document for checking installation
    ///   privileges
    /// - `ingestion_id`: ID of the target ingestion for checking limit settings
    /// - `install_context`: Type of installation context for which Pack
    ///   information is being requested.
    /// - `release_channel`: Release channel for which Pack information is being
    ///   requested.
    /// - `workspace_id`: ID of the target workspace (if applicable) for
    ///   checking installation privileges.
    pub async fn get_pack_listing<'a>(&'a self, pack_id: ::std::num::NonZeroU64, doc_id: Option<&'a str>, ingestion_id: Option<&'a str>, install_context: Option<types::PackListingInstallContextType>, release_channel: Option<types::IngestionPackReleaseChannel>, workspace_id: Option<&'a str>) -> Result<ResponseValue<types::PackListingDetail>, Error<types::GetPackListingResponse>> {
        let url = format!("{}/packs/{}/listing", self.baseurl, encode_path(&pack_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .query(&progenitor_client::QueryParam::new("docId", &doc_id))
            .query(&progenitor_client::QueryParam::new("ingestionId", &ingestion_id))
            .query(&progenitor_client::QueryParam::new("installContext", &install_context))
            .query(&progenitor_client::QueryParam::new("releaseChannel", &release_channel))
            .query(&progenitor_client::QueryParam::new("workspaceId", &workspace_id))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_pack_listing",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieve the logs of a Pack
    ///
    ///Retrieve the logs of a Pack for debugging purpose.
    ///
    ///
    ///Sends a `GET` request to `/packs/{packId}/docs/{docId}/logs`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    /// - `doc_id`: ID of the doc.
    /// - `after_timestamp`: Only return logs after the given time
    ///   (non-inclusive).
    ///
    /// - `before_timestamp`: Only return logs before the given time
    ///   (non-inclusive).
    ///
    /// - `limit`: Maximum number of results to return in this query.
    /// - `log_types`: Only return logs of the given types.
    /// - `order`: Specifies if the logs will be returned in time desc or asc.
    ///   Default is desc.
    ///
    /// - `page_token`: An opaque token used to fetch the next page of results.
    /// - `q`: A search query that follows Lucene syntax.
    ///
    /// - `request_ids`: Only return logs matching provided request IDs.
    pub async fn list_pack_logs<'a>(&'a self, pack_id: ::std::num::NonZeroU64, doc_id: &'a str, after_timestamp: Option<&'a ::chrono::DateTime<::chrono::offset::Utc>>, before_timestamp: Option<&'a ::chrono::DateTime<::chrono::offset::Utc>>, limit: Option<::std::num::NonZeroU64>, log_types: Option<&'a ::std::vec::Vec<types::PackLogType>>, order: Option<types::ListPackLogsOrder>, page_token: Option<&'a str>, q: Option<&'a str>, request_ids: Option<&'a ::std::vec::Vec<::std::string::String>>) -> Result<ResponseValue<types::PackLogsList>, Error<types::ListPackLogsResponse>> {
        let url = format!("{}/packs/{}/docs/{}/logs", self.baseurl, encode_path(&pack_id.to_string()), encode_path(&doc_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .query(&progenitor_client::QueryParam::new("afterTimestamp", &after_timestamp))
            .query(&progenitor_client::QueryParam::new("beforeTimestamp", &before_timestamp))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("logTypes", &log_types))
            .query(&progenitor_client::QueryParam::new("order", &order))
            .query(&progenitor_client::QueryParam::new("pageToken", &page_token))
            .query(&progenitor_client::QueryParam::new("q", &q))
            .query(&progenitor_client::QueryParam::new("requestIds", &request_ids))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_pack_logs",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieve the logs of a Ingestion
    ///
    ///Retrieve the logs of a Ingestion for debugging purpose.
    ///
    ///Sends a `GET` request to
    /// `/packs/{packId}/tenantId/{tenantId}/rootIngestionId/{rootIngestionId}/
    /// logs`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    /// - `tenant_id`: ID of the tenant.
    /// - `root_ingestion_id`: ID of the root ingestion.
    /// - `after_timestamp`: Only return logs after the given time
    ///   (non-inclusive).
    ///
    /// - `before_timestamp`: Only return logs before the given time
    ///   (non-inclusive).
    ///
    /// - `ingestion_execution_id`: ID of the ingestion execution.
    /// - `ingestion_status`: Only fetch logs with the given ingestion status.
    ///   This only works in combination with the onlyExecutionCompletions
    ///   parameter.
    ///
    /// - `limit`: Maximum number of results to return in this query.
    /// - `log_types`: Only return logs of the given types.
    /// - `only_execution_completions`: Only fetch logs that represent the
    ///   completion of a child execution.
    /// - `order`: Specifies if the logs will be returned in time desc or asc.
    ///   Default is desc.
    ///
    /// - `page_token`: An opaque token used to fetch the next page of results.
    /// - `q`: A search query that follows Lucene syntax.
    ///
    /// - `request_ids`: Only return logs matching provided request IDs.
    pub async fn list_ingestion_logs<'a>(&'a self, pack_id: ::std::num::NonZeroU64, tenant_id: &'a str, root_ingestion_id: &'a ::uuid::Uuid, after_timestamp: Option<&'a ::chrono::DateTime<::chrono::offset::Utc>>, before_timestamp: Option<&'a ::chrono::DateTime<::chrono::offset::Utc>>, ingestion_execution_id: Option<&'a ::uuid::Uuid>, ingestion_status: Option<types::IngestionStatus>, limit: Option<::std::num::NonZeroU64>, log_types: Option<&'a ::std::vec::Vec<types::PackLogType>>, only_execution_completions: Option<bool>, order: Option<types::ListIngestionLogsOrder>, page_token: Option<&'a str>, q: Option<&'a str>, request_ids: Option<&'a ::std::vec::Vec<::std::string::String>>) -> Result<ResponseValue<types::PackLogsList>, Error<types::ListIngestionLogsResponse>> {
        let url = format!("{}/packs/{}/tenantId/{}/rootIngestionId/{}/logs", self.baseurl, encode_path(&pack_id.to_string()), encode_path(&tenant_id.to_string()), encode_path(&root_ingestion_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .query(&progenitor_client::QueryParam::new("afterTimestamp", &after_timestamp))
            .query(&progenitor_client::QueryParam::new("beforeTimestamp", &before_timestamp))
            .query(&progenitor_client::QueryParam::new("ingestionExecutionId", &ingestion_execution_id))
            .query(&progenitor_client::QueryParam::new("ingestionStatus", &ingestion_status))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("logTypes", &log_types))
            .query(&progenitor_client::QueryParam::new("onlyExecutionCompletions", &only_execution_completions))
            .query(&progenitor_client::QueryParam::new("order", &order))
            .query(&progenitor_client::QueryParam::new("pageToken", &page_token))
            .query(&progenitor_client::QueryParam::new("q", &q))
            .query(&progenitor_client::QueryParam::new("requestIds", &request_ids))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_ingestion_logs",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieve the grouped logs of a Pack
    ///
    ///Retrieve the grouped logs of a Pack for debugging purpose.
    ///
    ///
    ///Sends a `GET` request to `/packs/{packId}/docs/{docId}/groupedLogs`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    /// - `doc_id`: ID of the doc.
    /// - `after_timestamp`: Only return logs after the given time
    ///   (non-inclusive).
    ///
    /// - `before_timestamp`: Only return logs before the given time
    ///   (non-inclusive).
    ///
    /// - `limit`: Maximum number of results to return in this query.
    /// - `order`: Specifies if the logs will be returned in time desc or asc.
    ///   Default is desc.
    ///
    /// - `page_token`: An opaque token used to fetch the next page of results.
    /// - `q`: A search query that follows Lucene syntax.
    pub async fn list_grouped_pack_logs<'a>(&'a self, pack_id: ::std::num::NonZeroU64, doc_id: &'a str, after_timestamp: Option<&'a ::chrono::DateTime<::chrono::offset::Utc>>, before_timestamp: Option<&'a ::chrono::DateTime<::chrono::offset::Utc>>, limit: Option<::std::num::NonZeroU64>, order: Option<types::ListGroupedPackLogsOrder>, page_token: Option<&'a str>, q: Option<&'a str>) -> Result<ResponseValue<types::GroupedPackLogsList>, Error<types::ListGroupedPackLogsResponse>> {
        let url = format!("{}/packs/{}/docs/{}/groupedLogs", self.baseurl, encode_path(&pack_id.to_string()), encode_path(&doc_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .query(&progenitor_client::QueryParam::new("afterTimestamp", &after_timestamp))
            .query(&progenitor_client::QueryParam::new("beforeTimestamp", &before_timestamp))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("order", &order))
            .query(&progenitor_client::QueryParam::new("pageToken", &page_token))
            .query(&progenitor_client::QueryParam::new("q", &q))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_grouped_pack_logs",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieve the grouped logs of a Pack for a specific ingestionExecutionId
    ///
    ///Retrieve the grouped logs of a Pack for debugging purpose.
    ///
    ///
    ///Sends a `GET` request to
    /// `/packs/{packId}/tenantId/{tenantId}/rootIngestionId/{rootIngestionId}/
    /// groupedLogs`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    /// - `tenant_id`: ID of the tenant.
    /// - `root_ingestion_id`: ID of the root ingestion.
    /// - `after_timestamp`: Only return logs after the given time
    ///   (non-inclusive).
    ///
    /// - `before_timestamp`: Only return logs before the given time
    ///   (non-inclusive).
    ///
    /// - `ingestion_execution_id`: ID of the ingestion execution.
    /// - `limit`: Maximum number of results to return in this query.
    /// - `order`: Specifies if the logs will be returned in time desc or asc.
    ///   Default is desc.
    ///
    /// - `page_token`: An opaque token used to fetch the next page of results.
    /// - `q`: A search query that follows Lucene syntax.
    pub async fn list_grouped_ingestion_logs<'a>(&'a self, pack_id: ::std::num::NonZeroU64, tenant_id: &'a str, root_ingestion_id: &'a ::uuid::Uuid, after_timestamp: Option<&'a ::chrono::DateTime<::chrono::offset::Utc>>, before_timestamp: Option<&'a ::chrono::DateTime<::chrono::offset::Utc>>, ingestion_execution_id: Option<&'a ::uuid::Uuid>, limit: Option<::std::num::NonZeroU64>, order: Option<types::ListGroupedIngestionLogsOrder>, page_token: Option<&'a str>, q: Option<&'a str>) -> Result<ResponseValue<types::GroupedPackLogsList>, Error<types::ListGroupedIngestionLogsResponse>> {
        let url = format!("{}/packs/{}/tenantId/{}/rootIngestionId/{}/groupedLogs", self.baseurl, encode_path(&pack_id.to_string()), encode_path(&tenant_id.to_string()), encode_path(&root_ingestion_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .query(&progenitor_client::QueryParam::new("afterTimestamp", &after_timestamp))
            .query(&progenitor_client::QueryParam::new("beforeTimestamp", &before_timestamp))
            .query(&progenitor_client::QueryParam::new("ingestionExecutionId", &ingestion_execution_id))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("order", &order))
            .query(&progenitor_client::QueryParam::new("pageToken", &page_token))
            .query(&progenitor_client::QueryParam::new("q", &q))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_grouped_ingestion_logs",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieve a list of ingestion batch executions for the given root
    /// ingestion id
    ///
    ///Retrieve the ingestion batch executions of a root ingestion for
    /// debugging purpose.
    ///
    ///
    ///Sends a `GET` request to
    /// `/packs/{packId}/tenantId/{tenantId}/rootIngestionId/{rootIngestionId}/
    /// ingestionBatchExecutions`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    /// - `tenant_id`: ID of the tenant.
    /// - `root_ingestion_id`: ID of the root ingestion.
    /// - `datasource`: Only show batch executions for this datasource (sync
    ///   table).
    /// - `execution_type`: Only show batch executions with this execution type.
    /// - `include_deleted_ingestions`: Include deleted ingestion executions in
    ///   the response
    /// - `ingestion_execution_id`: Only retrieve this single batch execution.
    /// - `ingestion_id`: Only show batch executions for this sync table
    ///   ingestion.
    /// - `ingestion_status`: Only show batch executions with this status.
    /// - `limit`: Maximum number of results to return in this query.
    /// - `page_token`: An opaque token used to fetch the next page of results.
    pub async fn list_ingestion_batch_executions<'a>(&'a self, pack_id: ::std::num::NonZeroU64, tenant_id: &'a str, root_ingestion_id: &'a ::uuid::Uuid, datasource: Option<&'a str>, execution_type: Option<types::IngestionExecutionType>, include_deleted_ingestions: Option<bool>, ingestion_execution_id: Option<&'a str>, ingestion_id: Option<&'a str>, ingestion_status: Option<types::IngestionStatus>, limit: Option<::std::num::NonZeroU64>, page_token: Option<&'a str>) -> Result<ResponseValue<types::IngestionBatchExecutionsList>, Error<types::ListIngestionBatchExecutionsResponse>> {
        let url = format!("{}/packs/{}/tenantId/{}/rootIngestionId/{}/ingestionBatchExecutions", self.baseurl, encode_path(&pack_id.to_string()), encode_path(&tenant_id.to_string()), encode_path(&root_ingestion_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .query(&progenitor_client::QueryParam::new("datasource", &datasource))
            .query(&progenitor_client::QueryParam::new("executionType", &execution_type))
            .query(&progenitor_client::QueryParam::new("includeDeletedIngestions", &include_deleted_ingestions))
            .query(&progenitor_client::QueryParam::new("ingestionExecutionId", &ingestion_execution_id))
            .query(&progenitor_client::QueryParam::new("ingestionId", &ingestion_id))
            .query(&progenitor_client::QueryParam::new("ingestionStatus", &ingestion_status))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("pageToken", &page_token))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_ingestion_batch_executions",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieve a list of parent items for the given ingestion batch execution
    /// id
    ///
    ///Retrieve the parent items of a ingestion batch execution for debugging
    /// purpose.
    ///
    ///
    ///Sends a `GET` request to
    /// `/packs/{packId}/tenantId/{tenantId}/rootIngestionId/{rootIngestionId}/
    /// ingestionBatchExecutions/{ingestionExecutionId}/parentItems`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    /// - `tenant_id`: ID of the tenant.
    /// - `root_ingestion_id`: ID of the root ingestion.
    /// - `ingestion_execution_id`: Only show parent items for this ingestion
    ///   batch execution.
    /// - `ingestion_id`: The ID of the sync table ingestion. Enables faster
    ///   lookup.
    /// - `ingestion_status`: Only show parent items with this status.
    /// - `limit`: Maximum number of results to return in this query.
    /// - `page_token`: An opaque token used to fetch the next page of results.
    pub async fn list_ingestion_parent_items<'a>(&'a self, pack_id: ::std::num::NonZeroU64, tenant_id: &'a str, root_ingestion_id: &'a ::uuid::Uuid, ingestion_execution_id: &'a ::uuid::Uuid, ingestion_id: &'a ::uuid::Uuid, ingestion_status: Option<types::IngestionStatus>, limit: Option<::std::num::NonZeroU64>, page_token: Option<&'a str>) -> Result<ResponseValue<types::IngestionParentItemsList>, Error<types::ListIngestionParentItemsResponse>> {
        let url = format!("{}/packs/{}/tenantId/{}/rootIngestionId/{}/ingestionBatchExecutions/{}/parentItems", self.baseurl, encode_path(&pack_id.to_string()), encode_path(&tenant_id.to_string()), encode_path(&root_ingestion_id.to_string()), encode_path(&ingestion_execution_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .query(&progenitor_client::QueryParam::new("ingestionId", &ingestion_id))
            .query(&progenitor_client::QueryParam::new("ingestionStatus", &ingestion_status))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("pageToken", &page_token))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_ingestion_parent_items",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Retrieve the information for a specific log
    ///
    ///Retrieve the ingestion execution ids of a root ingestion for debugging
    /// purpose.
    ///
    ///
    ///Sends a `GET` request to
    /// `/packs/{packId}/tenantId/{tenantId}/rootIngestionId/{rootIngestionId}/
    /// logs/{logId}`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    /// - `tenant_id`: ID of the tenant.
    /// - `root_ingestion_id`: ID of the root ingestion.
    /// - `log_id`: The id of the log to retrieve.
    ///
    /// - `details_key`: The key of the details to retrieve.
    pub async fn get_pack_log_details<'a>(&'a self, pack_id: ::std::num::NonZeroU64, tenant_id: &'a str, root_ingestion_id: &'a ::uuid::Uuid, log_id: &'a str, details_key: &'a str) -> Result<ResponseValue<types::PackLogDetails>, Error<types::GetPackLogDetailsResponse>> {
        let url = format!("{}/packs/{}/tenantId/{}/rootIngestionId/{}/logs/{}", self.baseurl, encode_path(&pack_id.to_string()), encode_path(&tenant_id.to_string()), encode_path(&root_ingestion_id.to_string()), encode_path(&log_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .query(&progenitor_client::QueryParam::new("detailsKey", &details_key))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_pack_log_details",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List featured docs for a Pack
    ///
    ///Returns a list of featured doc ids for a Pack.
    ///
    ///
    ///Sends a `GET` request to `/packs/{packId}/featuredDocs`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    pub async fn list_pack_featured_docs<'a>(&'a self, pack_id: ::std::num::NonZeroU64) -> Result<ResponseValue<types::PackFeaturedDocsResponse>, Error<types::ListPackFeaturedDocsResponse>> {
        let url = format!("{}/packs/{}/featuredDocs", self.baseurl, encode_path(&pack_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_pack_featured_docs",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update featured docs for a Pack
    ///
    ///Create or replace the featured docs for a Pack.
    ///
    ///
    ///Sends a `PUT` request to `/packs/{packId}/featuredDocs`
    ///
    ///Arguments:
    /// - `pack_id`: ID of a Pack
    /// - `body`: Parameters for updating the Pack's featured docs.
    pub async fn update_pack_featured_docs<'a>(&'a self, pack_id: ::std::num::NonZeroU64, body: &'a types::UpdatePackFeaturedDocsRequest) -> Result<ResponseValue<types::UpdatePackFeaturedDocsResponse>, Error<types::UpdatePackFeaturedDocsResponse>> {
        let url = format!("{}/packs/{}/featuredDocs", self.baseurl, encode_path(&pack_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_pack_featured_docs",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            401u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            429u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Add a go link
    ///
    ///Adds a new go link for the organization.
    ///
    ///Sends a `POST` request to `/organizations/{organizationId}/goLinks`
    ///
    ///Arguments:
    /// - `organization_id`: ID of the organization.
    /// - `body`: The request body for creating a go link.
    pub async fn add_go_link<'a>(&'a self, organization_id: &'a str, body: &'a types::AddGoLinkRequest) -> Result<ResponseValue<types::AddGoLinkResult>, Error<types::AddGoLinkResponse>> {
        let url = format!("{}/organizations/{}/goLinks", self.baseurl, encode_path(&organization_id.to_string()),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(::reqwest::header::HeaderName::from_static("api-version"), ::reqwest::header::HeaderValue::from_static(Self::api_version()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(::reqwest::header::ACCEPT, ::reqwest::header::HeaderValue::from_static("application/json"))
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "add_go_link",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            403u16 => Err(Error::ErrorResponse(ResponseValue::from_response(response).await?)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
}

/// Items consumers will typically use such as the Client.
pub mod prelude {
    #[allow(unused_imports)]
    pub use super::Client;
}

mod ext;

pub use ext::*;

#[cfg(test)]
pub mod test;
